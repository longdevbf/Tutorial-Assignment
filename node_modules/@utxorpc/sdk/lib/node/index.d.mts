import { PromiseClient } from '@connectrpc/connect';
import { PartialMessage } from '@bufbuild/protobuf';
import { submit, syncConnect, cardano, queryConnect, query, submitConnect, watchConnect } from '@utxorpc/spec';

type GenericTipEvent<Block, Point> = {
    action: "apply";
    block: Block;
} | {
    action: "undo";
    block: Block;
} | {
    action: "reset";
    point: Point;
};
type GenericTxEvent<Tx> = {
    action: "apply";
    Tx: Tx | undefined;
} | {
    action: "undo";
    Tx: Tx | undefined;
};
type GenericTxInMempoolEvent<Tx> = {
    stage: submit.Stage;
    txoRef: Uint8Array<ArrayBuffer>;
    nativeBytes: Uint8Array<ArrayBuffer>;
    Tx: Tx | undefined;
};
type GenericUtxo<Ref, Parsed> = {
    txoRef: Ref;
    parsedValued: Parsed | undefined;
    nativeBytes: Uint8Array<ArrayBuffer> | undefined;
};
type ClientBuilderOptions = {
    uri: string;
    headers?: Record<string, string>;
};

type ChainPoint = {
    slot: number | string;
    hash: string;
};
type Utxo = GenericUtxo<query.TxoRef, cardano.TxOutput>;
type TipEvent = GenericTipEvent<cardano.Block, ChainPoint>;
type TxEvent = GenericTxEvent<cardano.Tx>;
type MempoolEvent = GenericTxInMempoolEvent<cardano.Tx>;
type TxHash = Uint8Array;
type TxCbor = Uint8Array;
declare class SyncClient {
    inner: PromiseClient<typeof syncConnect.SyncService>;
    constructor(options: ClientBuilderOptions);
    followTip(intersect?: ChainPoint[]): AsyncIterable<TipEvent>;
    readTip(): Promise<ChainPoint>;
    fetchBlock(p: ChainPoint): Promise<cardano.Block>;
    fetchHistory(p: ChainPoint | undefined, maxItems?: number): Promise<cardano.Block>;
}
declare class QueryClient {
    inner: PromiseClient<typeof queryConnect.QueryService>;
    constructor(options: ClientBuilderOptions);
    readParams(): Promise<cardano.PParams>;
    readUtxosByOutputRef(refs: {
        txHash: Uint8Array<ArrayBuffer>;
        outputIndex: number;
    }[]): Promise<Utxo[]>;
    private searchUtxosByMatch;
    searchUtxosByAddress(address: Uint8Array<ArrayBuffer>): Promise<Utxo[]>;
    searchUtxosByPaymentPart(paymentPart: Uint8Array<ArrayBuffer>): Promise<Utxo[]>;
    searchUtxosByDelegationPart(delegationPart: Uint8Array<ArrayBuffer>): Promise<Utxo[]>;
    searchUtxosByAsset(policyId?: Uint8Array<ArrayBuffer>, name?: Uint8Array<ArrayBuffer>): Promise<Utxo[]>;
    searchUtxosByAddressWithAsset(address: Uint8Array<ArrayBuffer>, policyId?: Uint8Array<ArrayBuffer>, name?: Uint8Array<ArrayBuffer>): Promise<Utxo[]>;
    searchUtxosByPaymentPartWithAsset(paymentPart: Uint8Array<ArrayBuffer>, policyId?: Uint8Array<ArrayBuffer>, name?: Uint8Array<ArrayBuffer>): Promise<Utxo[]>;
    searchUtxosByDelegationPartWithAsset(delegationPart: Uint8Array<ArrayBuffer>, policyId?: Uint8Array<ArrayBuffer>, name?: Uint8Array<ArrayBuffer>): Promise<Utxo[]>;
}
declare class SubmitClient {
    inner: PromiseClient<typeof submitConnect.SubmitService>;
    constructor(options: ClientBuilderOptions);
    submitTx(tx: TxCbor): Promise<TxHash>;
    evalTx(tx: TxCbor): Promise<submit.EvalTxResponse>;
    waitForTx(txHash: TxHash): AsyncIterable<submit.Stage>;
    watchMempoolByMatch(pattern: PartialMessage<cardano.TxPattern>): AsyncIterable<MempoolEvent>;
    watchMempool(): AsyncIterable<MempoolEvent>;
    watchMempoolForAddress(address: Uint8Array<ArrayBuffer>): AsyncIterable<MempoolEvent>;
    watchMempoolForPaymentPart(paymentPart: Uint8Array<ArrayBuffer>): AsyncIterable<MempoolEvent>;
    watchMempoolForDelegationPart(delegationPart: Uint8Array<ArrayBuffer>): AsyncIterable<MempoolEvent>;
    watchMempoolForAsset(policyId?: Uint8Array<ArrayBuffer>, assetName?: Uint8Array<ArrayBuffer>): AsyncIterable<MempoolEvent>;
}
declare class WatchClient {
    inner: PromiseClient<typeof watchConnect.WatchService>;
    constructor(options: ClientBuilderOptions);
    watchTxByMatch(pattern: PartialMessage<cardano.TxPattern>, intersect?: ChainPoint[]): AsyncIterable<TxEvent>;
    watchTx(intersect?: ChainPoint[]): AsyncIterable<TxEvent>;
    watchTxForAddress(address: Uint8Array<ArrayBuffer>, intersect?: ChainPoint[]): AsyncIterable<TxEvent>;
    watchTxForPaymentPart(paymentPart: Uint8Array<ArrayBuffer>, intersect?: ChainPoint[]): AsyncIterable<TxEvent>;
    watchTxForDelegationPart(delegationPart: Uint8Array<ArrayBuffer>, intersect?: ChainPoint[]): AsyncIterable<TxEvent>;
    watchTxForAsset(policyId?: Uint8Array<ArrayBuffer>, assetName?: Uint8Array<ArrayBuffer>, intersect?: ChainPoint[]): AsyncIterable<TxEvent>;
}

export { type ChainPoint as CardanoChainPoint, type MempoolEvent as CardanoMempoolEvent, QueryClient as CardanoQueryClient, SubmitClient as CardanoSubmitClient, SyncClient as CardanoSyncClient, type TipEvent as CardanoTipEvent, type TxCbor as CardanoTxCbor, type TxEvent as CardanoTxEvent, type TxHash as CardanoTxHash, type Utxo as CardanoUtxo, WatchClient as CardanoWatchClient, type ClientBuilderOptions, type GenericTipEvent, type GenericTxEvent, type GenericTxInMempoolEvent, type GenericUtxo };
