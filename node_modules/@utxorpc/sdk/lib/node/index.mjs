// src/cardano.ts
import { createPromiseClient } from "@connectrpc/connect";

// src/grpcTransport.node.ts
import { createGrpcTransport as createGrpcNodeTransport } from "@connectrpc/connect-node";
var createGrpcTransport = createGrpcNodeTransport;

// src/cardano.ts
import { Buffer } from "buffer";
import {
  sync,
  syncConnect,
  queryConnect,
  submitConnect,
  watchConnect,
  watch
} from "@utxorpc/spec";

// src/common.ts
function metadataInterceptor(options) {
  return (next) => async (req) => {
    if (!!(options == null ? void 0 : options.headers)) {
      Object.entries(options.headers).forEach(
        ([key, value]) => req.header.set(key, value)
      );
    }
    return await next(req);
  };
}

// src/cardano.ts
function toMempoolEvent(txInMempool) {
  return {
    txoRef: txInMempool.ref,
    stage: txInMempool.stage,
    nativeBytes: txInMempool.nativeBytes,
    Tx: txInMempool.parsedState.case == "cardano" ? txInMempool.parsedState.value : void 0
  };
}
function toTxEvent(response) {
  var _a, _b;
  return {
    action: response.action.case,
    Tx: ((_a = response.action.value) == null ? void 0 : _a.chain.case) == "cardano" ? (_b = response.action.value) == null ? void 0 : _b.chain.value : void 0
  };
}
function anyChainToBlock(msg) {
  return msg.chain.case == "cardano" ? msg.chain.value : null;
}
function pointToBlockRef(p) {
  return new sync.BlockRef({
    index: BigInt(p.slot),
    hash: new Uint8Array(Buffer.from(p.hash, "hex"))
  });
}
function blockRefToPoint(r) {
  return {
    slot: r.index.toString(),
    hash: Buffer.from(r.hash).toString("hex")
  };
}
function anyUtxoToChain(u) {
  switch (u.parsedState.case) {
    case "cardano":
      return {
        txoRef: u.txoRef,
        parsedValued: u.parsedState.value,
        nativeBytes: u.nativeBytes
      };
    default:
      throw Error("source is not Cardano data");
  }
}
function anyParamsToChain(p) {
  switch (p.params.case) {
    case "cardano":
      return p.params.value;
    default:
      throw Error("source is not Cardano data");
  }
}
var SyncClient = class {
  constructor(options) {
    let headerInterceptor = metadataInterceptor(options);
    const transport = createGrpcTransport({
      httpVersion: "2",
      baseUrl: options.uri,
      interceptors: [headerInterceptor]
    });
    this.inner = createPromiseClient(syncConnect.SyncService, transport);
  }
  async *followTip(intersect) {
    const req = new sync.FollowTipRequest({
      intersect: intersect == null ? void 0 : intersect.map((p) => pointToBlockRef(p))
    });
    const res = this.inner.followTip(req);
    for await (const any of res) {
      switch (any.action.case) {
        case "apply":
          yield {
            action: "apply",
            block: anyChainToBlock(any.action.value)
          };
          break;
        case "undo":
          yield {
            action: "undo",
            block: anyChainToBlock(any.action.value)
          };
          break;
        case "reset":
          yield {
            action: "reset",
            point: blockRefToPoint(any.action.value)
          };
      }
    }
  }
  async readTip() {
    const res = await this.inner.readTip({});
    return blockRefToPoint(res.tip);
  }
  async fetchBlock(p) {
    const req = pointToBlockRef(p);
    const res = await this.inner.fetchBlock({ ref: [req] });
    return anyChainToBlock(res.block[0]);
  }
  async fetchHistory(p, maxItems = 1) {
    const req = new sync.DumpHistoryRequest({
      startToken: p ? new sync.BlockRef({
        index: BigInt(p.slot),
        hash: Buffer.from(p.hash, "hex")
      }) : void 0,
      maxItems
    });
    const res = await this.inner.dumpHistory(req);
    if (res.block.length === 0) {
      throw new Error("No block history found for the provided ChainPoint.");
    }
    const block = anyChainToBlock(res.block[0]);
    return block;
  }
};
var QueryClient = class {
  constructor(options) {
    let headerInterceptor = metadataInterceptor(options);
    const transport = createGrpcTransport({
      httpVersion: "2",
      baseUrl: options.uri,
      interceptors: [headerInterceptor]
    });
    this.inner = createPromiseClient(queryConnect.QueryService, transport);
  }
  async readParams() {
    const res = await this.inner.readParams({});
    return anyParamsToChain(res.values);
  }
  async readUtxosByOutputRef(refs) {
    const searchResponse = await this.inner.readUtxos({
      keys: refs.map((ref) => {
        return {
          hash: ref.txHash,
          index: ref.outputIndex
        };
      })
    });
    return searchResponse.items.map(anyUtxoToChain);
  }
  async searchUtxosByMatch(pattern) {
    const searchResponse = await this.inner.searchUtxos({
      predicate: {
        match: { utxoPattern: { value: pattern, case: "cardano" } }
      }
    });
    return searchResponse.items.map(anyUtxoToChain);
  }
  async searchUtxosByAddress(address) {
    return this.searchUtxosByMatch({
      address: {
        exactAddress: address
      }
    });
  }
  async searchUtxosByPaymentPart(paymentPart) {
    return this.searchUtxosByMatch({
      address: {
        paymentPart
      }
    });
  }
  async searchUtxosByDelegationPart(delegationPart) {
    return this.searchUtxosByMatch({
      address: {
        delegationPart
      }
    });
  }
  async searchUtxosByAsset(policyId, name) {
    return this.searchUtxosByMatch({
      asset: policyId && name ? { policyId, assetName: name } : policyId ? { policyId } : { assetName: name }
    });
  }
  async searchUtxosByAddressWithAsset(address, policyId, name) {
    return this.searchUtxosByMatch({
      address: {
        exactAddress: address
      },
      asset: policyId && name ? { policyId, assetName: name } : policyId ? { policyId } : { assetName: name }
    });
  }
  async searchUtxosByPaymentPartWithAsset(paymentPart, policyId, name) {
    return this.searchUtxosByMatch({
      address: {
        paymentPart
      },
      asset: policyId && name ? { policyId, assetName: name } : policyId ? { policyId } : { assetName: name }
    });
  }
  async searchUtxosByDelegationPartWithAsset(delegationPart, policyId, name) {
    return this.searchUtxosByMatch({
      address: {
        delegationPart
      },
      asset: policyId && name ? { policyId, assetName: name } : policyId ? { policyId } : { assetName: name }
    });
  }
};
var SubmitClient = class {
  constructor(options) {
    let headerInterceptor = metadataInterceptor(options);
    const transport = createGrpcTransport({
      httpVersion: "2",
      baseUrl: options.uri,
      interceptors: [headerInterceptor]
    });
    this.inner = createPromiseClient(submitConnect.SubmitService, transport);
  }
  async submitTx(tx) {
    const res = await this.inner.submitTx({
      tx: [tx].map((cbor) => ({ type: { case: "raw", value: cbor } }))
    });
    return res.ref[0];
  }
  async evalTx(tx) {
    const res = await this.inner.evalTx({
      tx: [tx].map((cbor) => ({ type: { case: "raw", value: cbor } }))
    });
    return res;
  }
  async *waitForTx(txHash) {
    const updates = this.inner.waitForTx({
      ref: [txHash]
    });
    for await (const change of updates) {
      yield change.stage;
    }
  }
  async *watchMempoolByMatch(pattern) {
    const stream = this.inner.watchMempool({
      predicate: {
        match: { chain: { value: pattern, case: "cardano" } }
      }
    });
    for await (const response of stream) {
      if (response.tx) {
        yield toMempoolEvent(response.tx);
      }
    }
  }
  async *watchMempool() {
    yield* this.watchMempoolByMatch({});
  }
  async *watchMempoolForAddress(address) {
    yield* this.watchMempoolByMatch({
      hasAddress: { exactAddress: address }
    });
  }
  async *watchMempoolForPaymentPart(paymentPart) {
    yield* this.watchMempoolByMatch({
      hasAddress: { paymentPart }
    });
  }
  async *watchMempoolForDelegationPart(delegationPart) {
    yield* this.watchMempoolByMatch({
      hasAddress: { delegationPart }
    });
  }
  async *watchMempoolForAsset(policyId, assetName) {
    yield* this.watchMempoolByMatch({
      movesAsset: policyId ? { policyId } : { assetName }
    });
  }
};
var WatchClient = class {
  constructor(options) {
    let headerInterceptor = metadataInterceptor(options);
    const transport = createGrpcTransport({
      httpVersion: "2",
      baseUrl: options.uri,
      interceptors: [headerInterceptor]
    });
    this.inner = createPromiseClient(watchConnect.WatchService, transport);
  }
  async *watchTxByMatch(pattern, intersect) {
    const request = new watch.WatchTxRequest({
      intersect: intersect ? intersect.map(pointToBlockRef) : [],
      predicate: {
        match: {
          chain: {
            value: pattern,
            case: "cardano"
          }
        }
      }
    });
    const stream = this.inner.watchTx(request);
    for await (const response of stream) {
      switch (response.action.case) {
        case "apply":
          yield toTxEvent(response);
          break;
        case "undo":
          yield toTxEvent(response);
          break;
      }
    }
  }
  async *watchTx(intersect) {
    const pattern = {};
    yield* this.watchTxByMatch(pattern, intersect);
  }
  async *watchTxForAddress(address, intersect) {
    const pattern = { hasAddress: { exactAddress: address } };
    yield* this.watchTxByMatch(pattern, intersect);
  }
  async *watchTxForPaymentPart(paymentPart, intersect) {
    const pattern = { hasAddress: { paymentPart } };
    yield* this.watchTxByMatch(pattern, intersect);
  }
  async *watchTxForDelegationPart(delegationPart, intersect) {
    const pattern = { hasAddress: { delegationPart } };
    yield* this.watchTxByMatch(pattern, intersect);
  }
  async *watchTxForAsset(policyId, assetName, intersect) {
    const pattern = policyId ? { movesAsset: { policyId } } : { movesAsset: { assetName } };
    yield* this.watchTxByMatch(pattern, intersect);
  }
};
export {
  QueryClient as CardanoQueryClient,
  SubmitClient as CardanoSubmitClient,
  SyncClient as CardanoSyncClient,
  WatchClient as CardanoWatchClient
};
//# sourceMappingURL=index.mjs.map