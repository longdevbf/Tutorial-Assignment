{"version":3,"sources":["../../src/index.ts","../../src/cardano.ts","../../src/grpcTransport.node.ts","../../src/common.ts"],"sourcesContent":["export {\n  SyncClient as CardanoSyncClient,\n  QueryClient as CardanoQueryClient,\n  SubmitClient as CardanoSubmitClient,\n  WatchClient as CardanoWatchClient,\n  ChainPoint as CardanoChainPoint,\n  Utxo as CardanoUtxo,\n  TipEvent as CardanoTipEvent,\n  TxEvent as CardanoTxEvent,\n  MempoolEvent as CardanoMempoolEvent,\n  TxHash as CardanoTxHash,\n  TxCbor as CardanoTxCbor,\n} from \"./cardano.js\";\nexport type {\n  ClientBuilderOptions,\n  GenericTipEvent,\n  GenericTxEvent,\n  GenericTxInMempoolEvent,\n  GenericUtxo,\n} from \"./common.js\";\n","import { PromiseClient, createPromiseClient } from \"@connectrpc/connect\";\n\nimport { createGrpcTransport } from \"@sdk/grpcTransport\";\n\nimport { PartialMessage } from \"@bufbuild/protobuf\";\n\nimport { Buffer } from \"buffer\";\n\nimport {\n  sync,\n  syncConnect,\n  query,\n  queryConnect,\n  submit,\n  submitConnect,\n  watchConnect,\n  watch,\n  cardano\n} from \"@utxorpc/spec\";\n\nimport {\n  ClientBuilderOptions,\n  GenericTipEvent,\n  GenericUtxo,\n  GenericTxEvent,\n  GenericTxInMempoolEvent,\n  metadataInterceptor,\n} from \"./common.js\";\n\nexport type ChainPoint = { slot: number | string; hash: string };\nexport type Utxo = GenericUtxo<query.TxoRef, cardano.TxOutput>;\nexport type TipEvent = GenericTipEvent<cardano.Block, ChainPoint>;\nexport type TxEvent = GenericTxEvent<cardano.Tx>;\nexport type MempoolEvent = GenericTxInMempoolEvent<cardano.Tx>;\nexport type TxHash = Uint8Array;\nexport type TxCbor = Uint8Array;\n\nfunction toMempoolEvent(txInMempool: submit.TxInMempool): MempoolEvent {\n  return {\n    txoRef: txInMempool.ref,\n    stage: txInMempool.stage,\n    nativeBytes: txInMempool.nativeBytes,\n    Tx:\n      txInMempool.parsedState.case == \"cardano\"\n        ? txInMempool.parsedState.value\n        : undefined,\n  };\n}\nfunction toTxEvent(response: watch.WatchTxResponse): TxEvent {\n  return {\n    action: response.action.case as \"apply\" | \"undo\",\n    Tx:\n      response.action.value?.chain.case == \"cardano\"\n        ? response.action.value?.chain.value\n        : undefined,\n  };\n}\n\nfunction anyChainToBlock(msg: sync.AnyChainBlock) {\n  return msg.chain.case == \"cardano\" ? msg.chain.value : null;\n}\n\nfunction pointToBlockRef(p: ChainPoint) {\n  return new sync.BlockRef({\n    index: BigInt(p.slot),\n    hash: new Uint8Array(Buffer.from(p.hash, \"hex\")),\n  });\n}\n\nfunction blockRefToPoint(r: sync.BlockRef) {\n  return {\n    slot: r.index.toString(),\n    hash: Buffer.from(r.hash).toString(\"hex\"),\n  };\n}\n\nfunction anyUtxoToChain(u: query.AnyUtxoData): Utxo {\n  switch (u.parsedState.case) {\n    case \"cardano\":\n      return {\n        txoRef: u.txoRef!,\n        parsedValued: u.parsedState.value,\n        nativeBytes: u.nativeBytes,\n      };\n    default:\n      throw Error(\"source is not Cardano data\");\n  }\n}\n\nfunction anyParamsToChain(p: query.AnyChainParams): cardano.PParams {\n  switch (p.params.case) {\n    case \"cardano\":\n      return p.params.value;\n    default:\n      throw Error(\"source is not Cardano data\");\n  }\n}\n\nexport class SyncClient {\n  inner: PromiseClient<typeof syncConnect.SyncService>;\n\n  constructor(options: ClientBuilderOptions) {\n    let headerInterceptor = metadataInterceptor(options);\n\n    const transport = createGrpcTransport({\n      httpVersion: \"2\",\n      baseUrl: options.uri,\n      interceptors: [headerInterceptor],\n    });\n\n    this.inner = createPromiseClient(syncConnect.SyncService, transport);\n  }\n\n  async *followTip(intersect?: ChainPoint[]): AsyncIterable<TipEvent> {\n    const req = new sync.FollowTipRequest({\n      intersect: intersect?.map((p) => pointToBlockRef(p)),\n    });\n\n    const res = this.inner.followTip(req);\n\n    for await (const any of res) {\n      switch (any.action.case) {\n        case \"apply\":\n          yield {\n            action: \"apply\",\n            block: anyChainToBlock(any.action.value)!,\n          };\n          break;\n        case \"undo\":\n          yield {\n            action: \"undo\",\n            block: anyChainToBlock(any.action.value)!,\n          };\n          break;\n        case \"reset\":\n          yield {\n            action: \"reset\",\n            point: blockRefToPoint(any.action.value),\n          };\n      }\n    }\n  }\n\n  async readTip(): Promise<ChainPoint> {\n    const res = await this.inner.readTip({});\n    return blockRefToPoint(res.tip!);\n  }\n\n  async fetchBlock(p: ChainPoint): Promise<cardano.Block> {\n    const req = pointToBlockRef(p);\n    const res = await this.inner.fetchBlock({ ref: [req] });\n    return anyChainToBlock(res.block[0])!;\n  }\n\n  async fetchHistory(p: ChainPoint | undefined, maxItems = 1): Promise<cardano.Block> {\n    const req = new sync.DumpHistoryRequest({\n      startToken: p ? new sync.BlockRef({\n        index: BigInt(p.slot),\n        hash: Buffer.from(p.hash, \"hex\"),\n      }) : undefined,\n      maxItems: maxItems,\n    });\n\n    const res = await this.inner.dumpHistory(req);\n\n    if (res.block.length === 0) {\n      throw new Error(\"No block history found for the provided ChainPoint.\");\n    }\n\n    const block = anyChainToBlock(res.block[0]);\n\n    return block!;\n  }\n}\n\nexport class QueryClient {\n  inner: PromiseClient<typeof queryConnect.QueryService>;\n\n  constructor(options: ClientBuilderOptions) {\n    let headerInterceptor = metadataInterceptor(options);\n\n    const transport = createGrpcTransport({\n      httpVersion: \"2\",\n      baseUrl: options.uri,\n      interceptors: [headerInterceptor],\n    });\n\n    this.inner = createPromiseClient(queryConnect.QueryService, transport);\n  }\n\n  async readParams(): Promise<cardano.PParams> {\n    const res = await this.inner.readParams({});\n    return anyParamsToChain(res.values!);\n  }\n\n  async readUtxosByOutputRef(\n    refs: { txHash: Uint8Array<ArrayBuffer>; outputIndex: number }[]\n  ): Promise<Utxo[]> {\n    const searchResponse = await this.inner.readUtxos({\n      keys: refs.map((ref) => {\n        return {\n          hash: ref.txHash,\n          index: ref.outputIndex,\n        };\n      }),\n    });\n\n    return searchResponse.items.map(anyUtxoToChain);\n  }\n\n  private async searchUtxosByMatch(\n    pattern: PartialMessage<cardano.TxOutputPattern>\n  ): Promise<Utxo[]> {\n    const searchResponse = await this.inner.searchUtxos({\n      predicate: {\n        match: { utxoPattern: { value: pattern, case: \"cardano\" } },\n      },\n    });\n\n    return searchResponse.items.map(anyUtxoToChain);\n  }\n\n  async searchUtxosByAddress(address: Uint8Array<ArrayBuffer>): Promise<Utxo[]> {\n    return this.searchUtxosByMatch({\n      address: {\n        exactAddress: address,\n      },\n    });\n  }\n\n  async searchUtxosByPaymentPart(paymentPart: Uint8Array<ArrayBuffer>): Promise<Utxo[]> {\n    return this.searchUtxosByMatch({\n      address: {\n        paymentPart: paymentPart,\n      },\n    });\n  }\n\n  async searchUtxosByDelegationPart(\n    delegationPart: Uint8Array<ArrayBuffer>\n  ): Promise<Utxo[]> {\n    return this.searchUtxosByMatch({\n      address: {\n        delegationPart: delegationPart,\n      },\n    });\n  }\n\n  async searchUtxosByAsset(\n    policyId?: Uint8Array<ArrayBuffer>,\n    name?: Uint8Array<ArrayBuffer>\n  ): Promise<Utxo[]> {\n    return this.searchUtxosByMatch({\n      asset: (policyId && name) ? { policyId: policyId, assetName: name } : policyId ? { policyId } : { assetName: name },\n    });\n  }\n\n  async searchUtxosByAddressWithAsset(\n    address: Uint8Array<ArrayBuffer>,\n    policyId?: Uint8Array<ArrayBuffer>,\n    name?: Uint8Array<ArrayBuffer>\n  ): Promise<Utxo[]> {\n    return this.searchUtxosByMatch({\n      address: {\n        exactAddress: address,\n      },\n      asset: (policyId && name) ? { policyId: policyId, assetName: name } : policyId ? { policyId } : { assetName: name },\n    });\n  }\n\n  async searchUtxosByPaymentPartWithAsset(\n    paymentPart: Uint8Array<ArrayBuffer>,\n    policyId?: Uint8Array<ArrayBuffer>,\n    name?: Uint8Array<ArrayBuffer>\n  ): Promise<Utxo[]> {\n    return this.searchUtxosByMatch({\n      address: {\n        paymentPart: paymentPart,\n      },\n      asset: (policyId && name) ? { policyId: policyId, assetName: name } : policyId ? { policyId } : { assetName: name },\n    });\n  }\n\n  async searchUtxosByDelegationPartWithAsset(\n    delegationPart: Uint8Array<ArrayBuffer>,\n    policyId?: Uint8Array<ArrayBuffer>,\n    name?: Uint8Array<ArrayBuffer>\n  ): Promise<Utxo[]> {\n    return this.searchUtxosByMatch({\n      address: {\n        delegationPart: delegationPart,\n      },\n      asset: (policyId && name) ? { policyId: policyId, assetName: name } : policyId ? { policyId } : { assetName: name },\n    });\n  }\n}\n\nexport class SubmitClient {\n  inner: PromiseClient<typeof submitConnect.SubmitService>;\n\n  constructor(options: ClientBuilderOptions) {\n    let headerInterceptor = metadataInterceptor(options);\n\n    const transport = createGrpcTransport({\n      httpVersion: \"2\",\n      baseUrl: options.uri,\n      interceptors: [headerInterceptor],\n    });\n\n    this.inner = createPromiseClient(submitConnect.SubmitService, transport);\n  }\n\n  async submitTx(tx: TxCbor): Promise<TxHash> {\n    const res = await this.inner.submitTx({\n      tx: [tx].map((cbor) => ({ type: { case: \"raw\", value: cbor } })),\n    });\n\n    return res.ref[0];\n  }\n\n  async evalTx(tx: TxCbor): Promise<submit.EvalTxResponse> {\n    const res = await this.inner.evalTx({\n      tx: [tx].map((cbor) => ({ type: { case: \"raw\", value: cbor } })),\n    });\n    \n    return res;\n  }\n\n  async *waitForTx(txHash: TxHash): AsyncIterable<submit.Stage> {\n    const updates = this.inner.waitForTx({\n      ref: [txHash],\n    });\n\n    for await (const change of updates) {\n      yield change.stage;\n    }\n  }\n\n  async *watchMempoolByMatch(\n    pattern: PartialMessage<cardano.TxPattern>\n  ): AsyncIterable<MempoolEvent> {\n    const stream = this.inner.watchMempool({\n      predicate: {\n        match: { chain: { value: pattern, case: \"cardano\" } },\n      },\n    });\n\n    for await (const response of stream) {\n      if (response.tx) {\n        yield toMempoolEvent(response.tx);\n      }\n    }\n  }\n\n  async *watchMempool(): AsyncIterable<MempoolEvent> {\n    yield* this.watchMempoolByMatch({});\n  }\n\n  async *watchMempoolForAddress(\n    address: Uint8Array<ArrayBuffer>\n  ): AsyncIterable<MempoolEvent> {\n    yield* this.watchMempoolByMatch({\n      hasAddress: { exactAddress: address },\n    });\n  }\n\n  async *watchMempoolForPaymentPart(\n    paymentPart: Uint8Array<ArrayBuffer>\n  ): AsyncIterable<MempoolEvent> {\n    yield* this.watchMempoolByMatch({\n      hasAddress: { paymentPart: paymentPart },\n    });\n  }\n\n  async *watchMempoolForDelegationPart(\n    delegationPart: Uint8Array<ArrayBuffer>\n  ): AsyncIterable<MempoolEvent> {\n    yield* this.watchMempoolByMatch({\n      hasAddress: { delegationPart: delegationPart },\n    });\n  }\n\n  async *watchMempoolForAsset(\n    policyId?: Uint8Array<ArrayBuffer>,\n    assetName?: Uint8Array<ArrayBuffer>\n  ): AsyncIterable<MempoolEvent> {\n    yield* this.watchMempoolByMatch({\n      movesAsset: policyId ? { policyId } : { assetName },\n    });\n  }\n}\n\nexport class WatchClient {\n  inner: PromiseClient<typeof watchConnect.WatchService>;\n\n  constructor(options: ClientBuilderOptions) {\n    let headerInterceptor = metadataInterceptor(options);\n\n    const transport = createGrpcTransport({\n      httpVersion: \"2\",\n      baseUrl: options.uri,\n      interceptors: [headerInterceptor],\n    });\n\n    this.inner = createPromiseClient(watchConnect.WatchService, transport);\n  }\n\n  async *watchTxByMatch(\n    pattern: PartialMessage<cardano.TxPattern>,\n    intersect?: ChainPoint[]\n  ): AsyncIterable<TxEvent> {\n    const request: watch.WatchTxRequest = new watch.WatchTxRequest({\n      intersect: intersect ? intersect.map(pointToBlockRef) : [],\n      predicate: {\n        match: {\n          chain: {\n            value: pattern,\n            case: \"cardano\",\n          },\n        },\n      },\n    });\n\n    const stream = this.inner.watchTx(request);\n\n    for await (const response of stream) {\n      switch (response.action.case) {\n        case \"apply\":\n          yield toTxEvent(response);\n          break;\n\n        case \"undo\":\n          yield toTxEvent(response);\n          break;\n      }\n    }\n  }\n\n  async *watchTx(intersect?: ChainPoint[]): AsyncIterable<TxEvent> {\n    const pattern = {};\n    yield* this.watchTxByMatch(pattern, intersect);\n  }\n\n  async *watchTxForAddress(\n    address: Uint8Array<ArrayBuffer>,\n    intersect?: ChainPoint[]\n  ): AsyncIterable<TxEvent> {\n    const pattern = { hasAddress: { exactAddress: address } };\n    yield* this.watchTxByMatch(pattern, intersect);\n  }\n\n  async *watchTxForPaymentPart(\n    paymentPart: Uint8Array<ArrayBuffer>,\n    intersect?: ChainPoint[]\n  ): AsyncIterable<TxEvent> {\n    const pattern = { hasAddress: { paymentPart } };\n    yield* this.watchTxByMatch(pattern, intersect);\n  }\n\n  async *watchTxForDelegationPart(\n    delegationPart: Uint8Array<ArrayBuffer>,\n    intersect?: ChainPoint[]\n  ): AsyncIterable<TxEvent> {\n    const pattern = { hasAddress: { delegationPart } };\n    yield* this.watchTxByMatch(pattern, intersect);\n  }\n\n  async *watchTxForAsset(\n    policyId?: Uint8Array<ArrayBuffer>,\n    assetName?: Uint8Array<ArrayBuffer>,\n    intersect?: ChainPoint[]\n  ): AsyncIterable<TxEvent> {\n    const pattern = policyId\n      ? { movesAsset: { policyId } }\n      : { movesAsset: { assetName } };\n    yield* this.watchTxByMatch(pattern, intersect);\n  }\n}\n","import { createGrpcTransport as createGrpcNodeTransport } from \"@connectrpc/connect-node\";\nexport const createGrpcTransport = createGrpcNodeTransport;\n","import { Interceptor } from \"@connectrpc/connect\";\nimport { submit } from \"@utxorpc/spec\";\nexport function metadataInterceptor(\n  options?: ClientBuilderOptions\n): Interceptor {\n  return (next) => async (req) => {\n    if (!!options?.headers) {\n      Object.entries(options.headers).forEach(([key, value]) =>\n        req.header.set(key, value)\n      );\n    }\n\n    return await next(req);\n  };\n}\n\nexport type GenericTipEvent<Block, Point> =\n  | { action: \"apply\"; block: Block }\n  | { action: \"undo\"; block: Block }\n  | { action: \"reset\"; point: Point };\n\nexport type GenericTxEvent<Tx> =\n  | { action: \"apply\"; Tx: Tx | undefined }\n  | { action: \"undo\"; Tx: Tx | undefined };\n\nexport type GenericTxInMempoolEvent<Tx> = {\n  stage: submit.Stage;\n  txoRef: Uint8Array<ArrayBuffer>;\n  nativeBytes: Uint8Array<ArrayBuffer>;\n  Tx: Tx | undefined;\n};\n\nexport type GenericUtxo<Ref, Parsed> = {\n  txoRef: Ref;\n  parsedValued: Parsed | undefined;\n  nativeBytes: Uint8Array<ArrayBuffer> | undefined;\n};\n\nexport type ClientBuilderOptions = {\n  uri: string;\n  headers?: Record<string, string>;\n};\n"],"mappings":"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","names":["createGrpcNodeTransport"]}