/// A consistent view of the state of the ledger

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file utxorpc/v1alpha/query/query.proto (package utxorpc.v1alpha.query, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { FieldMask, Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { PlutusData, PParams, TxOutput, TxOutputPattern } from "../cardano/cardano_pb.js";

/**
 * Represents a specific point in the blockchain.
 *
 * @generated from message utxorpc.v1alpha.query.ChainPoint
 */
export class ChainPoint extends Message<ChainPoint> {
  /**
   * Slot number.
   *
   * @generated from field: uint64 slot = 1;
   */
  slot = protoInt64.zero;

  /**
   * Block hash.
   *
   * @generated from field: bytes hash = 2;
   */
  hash = new Uint8Array(0);

  constructor(data?: PartialMessage<ChainPoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "utxorpc.v1alpha.query.ChainPoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "slot", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChainPoint {
    return new ChainPoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChainPoint {
    return new ChainPoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChainPoint {
    return new ChainPoint().fromJsonString(jsonString, options);
  }

  static equals(a: ChainPoint | PlainMessage<ChainPoint> | undefined, b: ChainPoint | PlainMessage<ChainPoint> | undefined): boolean {
    return proto3.util.equals(ChainPoint, a, b);
  }
}

/**
 * Represents a reference to a transaction output
 *
 * @generated from message utxorpc.v1alpha.query.TxoRef
 */
export class TxoRef extends Message<TxoRef> {
  /**
   * Tx hash.
   *
   * @generated from field: bytes hash = 1;
   */
  hash = new Uint8Array(0);

  /**
   * Output index.
   *
   * @generated from field: uint32 index = 2;
   */
  index = 0;

  constructor(data?: PartialMessage<TxoRef>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "utxorpc.v1alpha.query.TxoRef";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hash", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TxoRef {
    return new TxoRef().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TxoRef {
    return new TxoRef().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TxoRef {
    return new TxoRef().fromJsonString(jsonString, options);
  }

  static equals(a: TxoRef | PlainMessage<TxoRef> | undefined, b: TxoRef | PlainMessage<TxoRef> | undefined): boolean {
    return proto3.util.equals(TxoRef, a, b);
  }
}

/**
 * Request to get the chain parameters
 *
 * @generated from message utxorpc.v1alpha.query.ReadParamsRequest
 */
export class ReadParamsRequest extends Message<ReadParamsRequest> {
  /**
   * Field mask to selectively return fields in the parsed response.
   *
   * @generated from field: google.protobuf.FieldMask field_mask = 1;
   */
  fieldMask?: FieldMask;

  constructor(data?: PartialMessage<ReadParamsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "utxorpc.v1alpha.query.ReadParamsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "field_mask", kind: "message", T: FieldMask },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadParamsRequest {
    return new ReadParamsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadParamsRequest {
    return new ReadParamsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadParamsRequest {
    return new ReadParamsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReadParamsRequest | PlainMessage<ReadParamsRequest> | undefined, b: ReadParamsRequest | PlainMessage<ReadParamsRequest> | undefined): boolean {
    return proto3.util.equals(ReadParamsRequest, a, b);
  }
}

/**
 * An evenlope that holds parameter data from any of the compatible chains
 *
 * @generated from message utxorpc.v1alpha.query.AnyChainParams
 */
export class AnyChainParams extends Message<AnyChainParams> {
  /**
   * @generated from oneof utxorpc.v1alpha.query.AnyChainParams.params
   */
  params: {
    /**
     * Cardano parameters
     *
     * @generated from field: utxorpc.v1alpha.cardano.PParams cardano = 1;
     */
    value: PParams;
    case: "cardano";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AnyChainParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "utxorpc.v1alpha.query.AnyChainParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cardano", kind: "message", T: PParams, oneof: "params" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnyChainParams {
    return new AnyChainParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnyChainParams {
    return new AnyChainParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnyChainParams {
    return new AnyChainParams().fromJsonString(jsonString, options);
  }

  static equals(a: AnyChainParams | PlainMessage<AnyChainParams> | undefined, b: AnyChainParams | PlainMessage<AnyChainParams> | undefined): boolean {
    return proto3.util.equals(AnyChainParams, a, b);
  }
}

/**
 * Response containing the chain parameters
 *
 * @generated from message utxorpc.v1alpha.query.ReadParamsResponse
 */
export class ReadParamsResponse extends Message<ReadParamsResponse> {
  /**
   * The value of the parameters.
   *
   * @generated from field: utxorpc.v1alpha.query.AnyChainParams values = 1;
   */
  values?: AnyChainParams;

  /**
   * The chain point that represent the ledger current position.
   *
   * @generated from field: utxorpc.v1alpha.query.ChainPoint ledger_tip = 2;
   */
  ledgerTip?: ChainPoint;

  constructor(data?: PartialMessage<ReadParamsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "utxorpc.v1alpha.query.ReadParamsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "message", T: AnyChainParams },
    { no: 2, name: "ledger_tip", kind: "message", T: ChainPoint },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadParamsResponse {
    return new ReadParamsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadParamsResponse {
    return new ReadParamsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadParamsResponse {
    return new ReadParamsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReadParamsResponse | PlainMessage<ReadParamsResponse> | undefined, b: ReadParamsResponse | PlainMessage<ReadParamsResponse> | undefined): boolean {
    return proto3.util.equals(ReadParamsResponse, a, b);
  }
}

/**
 * An evenlope that holds an UTxO patterns from any of compatible chains
 *
 * @generated from message utxorpc.v1alpha.query.AnyUtxoPattern
 */
export class AnyUtxoPattern extends Message<AnyUtxoPattern> {
  /**
   * @generated from oneof utxorpc.v1alpha.query.AnyUtxoPattern.utxo_pattern
   */
  utxoPattern: {
    /**
     * @generated from field: utxorpc.v1alpha.cardano.TxOutputPattern cardano = 1;
     */
    value: TxOutputPattern;
    case: "cardano";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AnyUtxoPattern>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "utxorpc.v1alpha.query.AnyUtxoPattern";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cardano", kind: "message", T: TxOutputPattern, oneof: "utxo_pattern" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnyUtxoPattern {
    return new AnyUtxoPattern().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnyUtxoPattern {
    return new AnyUtxoPattern().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnyUtxoPattern {
    return new AnyUtxoPattern().fromJsonString(jsonString, options);
  }

  static equals(a: AnyUtxoPattern | PlainMessage<AnyUtxoPattern> | undefined, b: AnyUtxoPattern | PlainMessage<AnyUtxoPattern> | undefined): boolean {
    return proto3.util.equals(AnyUtxoPattern, a, b);
  }
}

/**
 * Represents a simple utxo predicate that can composed to create more complex ones
 *
 * @generated from message utxorpc.v1alpha.query.UtxoPredicate
 */
export class UtxoPredicate extends Message<UtxoPredicate> {
  /**
   * Predicate is true if tx exhibits pattern.
   *
   * @generated from field: utxorpc.v1alpha.query.AnyUtxoPattern match = 1;
   */
  match?: AnyUtxoPattern;

  /**
   * Predicate is true if tx doesn't exhibit pattern.
   *
   * @generated from field: repeated utxorpc.v1alpha.query.UtxoPredicate not = 2;
   */
  not: UtxoPredicate[] = [];

  /**
   * Predicate is true if utxo exhibits all of the patterns.
   *
   * @generated from field: repeated utxorpc.v1alpha.query.UtxoPredicate all_of = 3;
   */
  allOf: UtxoPredicate[] = [];

  /**
   * Predicate is true if utxo exhibits any of the patterns.
   *
   * @generated from field: repeated utxorpc.v1alpha.query.UtxoPredicate any_of = 4;
   */
  anyOf: UtxoPredicate[] = [];

  constructor(data?: PartialMessage<UtxoPredicate>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "utxorpc.v1alpha.query.UtxoPredicate";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "match", kind: "message", T: AnyUtxoPattern },
    { no: 2, name: "not", kind: "message", T: UtxoPredicate, repeated: true },
    { no: 3, name: "all_of", kind: "message", T: UtxoPredicate, repeated: true },
    { no: 4, name: "any_of", kind: "message", T: UtxoPredicate, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UtxoPredicate {
    return new UtxoPredicate().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UtxoPredicate {
    return new UtxoPredicate().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UtxoPredicate {
    return new UtxoPredicate().fromJsonString(jsonString, options);
  }

  static equals(a: UtxoPredicate | PlainMessage<UtxoPredicate> | undefined, b: UtxoPredicate | PlainMessage<UtxoPredicate> | undefined): boolean {
    return proto3.util.equals(UtxoPredicate, a, b);
  }
}

/**
 * An evenlope that holds an UTxO from any of compatible chains
 *
 * @generated from message utxorpc.v1alpha.query.AnyUtxoData
 */
export class AnyUtxoData extends Message<AnyUtxoData> {
  /**
   * Original bytes as defined by the chain
   *
   * @generated from field: bytes native_bytes = 1;
   */
  nativeBytes = new Uint8Array(0);

  /**
   * Hash of the previous transaction.
   *
   * @generated from field: utxorpc.v1alpha.query.TxoRef txo_ref = 2;
   */
  txoRef?: TxoRef;

  /**
   * @generated from oneof utxorpc.v1alpha.query.AnyUtxoData.parsed_state
   */
  parsedState: {
    /**
     * A cardano UTxO
     *
     * @generated from field: utxorpc.v1alpha.cardano.TxOutput cardano = 3;
     */
    value: TxOutput;
    case: "cardano";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AnyUtxoData>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "utxorpc.v1alpha.query.AnyUtxoData";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "native_bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "txo_ref", kind: "message", T: TxoRef },
    { no: 3, name: "cardano", kind: "message", T: TxOutput, oneof: "parsed_state" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnyUtxoData {
    return new AnyUtxoData().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnyUtxoData {
    return new AnyUtxoData().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnyUtxoData {
    return new AnyUtxoData().fromJsonString(jsonString, options);
  }

  static equals(a: AnyUtxoData | PlainMessage<AnyUtxoData> | undefined, b: AnyUtxoData | PlainMessage<AnyUtxoData> | undefined): boolean {
    return proto3.util.equals(AnyUtxoData, a, b);
  }
}

/**
 * Request to get specific UTxOs
 *
 * @generated from message utxorpc.v1alpha.query.ReadUtxosRequest
 */
export class ReadUtxosRequest extends Message<ReadUtxosRequest> {
  /**
   * List of keys UTxOs.
   *
   * @generated from field: repeated utxorpc.v1alpha.query.TxoRef keys = 1;
   */
  keys: TxoRef[] = [];

  /**
   * Field mask to selectively return fields.
   *
   * @generated from field: google.protobuf.FieldMask field_mask = 2;
   */
  fieldMask?: FieldMask;

  constructor(data?: PartialMessage<ReadUtxosRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "utxorpc.v1alpha.query.ReadUtxosRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "keys", kind: "message", T: TxoRef, repeated: true },
    { no: 2, name: "field_mask", kind: "message", T: FieldMask },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadUtxosRequest {
    return new ReadUtxosRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadUtxosRequest {
    return new ReadUtxosRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadUtxosRequest {
    return new ReadUtxosRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReadUtxosRequest | PlainMessage<ReadUtxosRequest> | undefined, b: ReadUtxosRequest | PlainMessage<ReadUtxosRequest> | undefined): boolean {
    return proto3.util.equals(ReadUtxosRequest, a, b);
  }
}

/**
 * Response containing the UTxOs associated with the requested addresses.
 *
 * @generated from message utxorpc.v1alpha.query.ReadUtxosResponse
 */
export class ReadUtxosResponse extends Message<ReadUtxosResponse> {
  /**
   * List of UTxOs.
   *
   * @generated from field: repeated utxorpc.v1alpha.query.AnyUtxoData items = 1;
   */
  items: AnyUtxoData[] = [];

  /**
   * The chain point that represent the ledger current position.
   *
   * @generated from field: utxorpc.v1alpha.query.ChainPoint ledger_tip = 2;
   */
  ledgerTip?: ChainPoint;

  constructor(data?: PartialMessage<ReadUtxosResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "utxorpc.v1alpha.query.ReadUtxosResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "items", kind: "message", T: AnyUtxoData, repeated: true },
    { no: 2, name: "ledger_tip", kind: "message", T: ChainPoint },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadUtxosResponse {
    return new ReadUtxosResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadUtxosResponse {
    return new ReadUtxosResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadUtxosResponse {
    return new ReadUtxosResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReadUtxosResponse | PlainMessage<ReadUtxosResponse> | undefined, b: ReadUtxosResponse | PlainMessage<ReadUtxosResponse> | undefined): boolean {
    return proto3.util.equals(ReadUtxosResponse, a, b);
  }
}

/**
 * Request to search for UTxO based on a pattern.
 *
 * @generated from message utxorpc.v1alpha.query.SearchUtxosRequest
 */
export class SearchUtxosRequest extends Message<SearchUtxosRequest> {
  /**
   * Pattern to match UTxOs by.
   *
   * @generated from field: utxorpc.v1alpha.query.UtxoPredicate predicate = 1;
   */
  predicate?: UtxoPredicate;

  /**
   * Field mask to selectively return fields.
   *
   * @generated from field: google.protobuf.FieldMask field_mask = 2;
   */
  fieldMask?: FieldMask;

  /**
   * The maximum number of items to return.
   *
   * @generated from field: int32 max_items = 3;
   */
  maxItems = 0;

  /**
   * The next_page_token value returned from a previous request, if any.
   *
   * @generated from field: string start_token = 4;
   */
  startToken = "";

  constructor(data?: PartialMessage<SearchUtxosRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "utxorpc.v1alpha.query.SearchUtxosRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "predicate", kind: "message", T: UtxoPredicate },
    { no: 2, name: "field_mask", kind: "message", T: FieldMask },
    { no: 3, name: "max_items", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "start_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchUtxosRequest {
    return new SearchUtxosRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchUtxosRequest {
    return new SearchUtxosRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchUtxosRequest {
    return new SearchUtxosRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SearchUtxosRequest | PlainMessage<SearchUtxosRequest> | undefined, b: SearchUtxosRequest | PlainMessage<SearchUtxosRequest> | undefined): boolean {
    return proto3.util.equals(SearchUtxosRequest, a, b);
  }
}

/**
 * Response containing the UTxOs that match the requested addresses.
 *
 * @generated from message utxorpc.v1alpha.query.SearchUtxosResponse
 */
export class SearchUtxosResponse extends Message<SearchUtxosResponse> {
  /**
   * List of UTxOs.
   *
   * @generated from field: repeated utxorpc.v1alpha.query.AnyUtxoData items = 1;
   */
  items: AnyUtxoData[] = [];

  /**
   * The chain point that represent the ledger current position.
   *
   * @generated from field: utxorpc.v1alpha.query.ChainPoint ledger_tip = 2;
   */
  ledgerTip?: ChainPoint;

  /**
   * Token to retrieve the next page of results, or empty if there are no more results.
   *
   * @generated from field: string next_token = 3;
   */
  nextToken = "";

  constructor(data?: PartialMessage<SearchUtxosResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "utxorpc.v1alpha.query.SearchUtxosResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "items", kind: "message", T: AnyUtxoData, repeated: true },
    { no: 2, name: "ledger_tip", kind: "message", T: ChainPoint },
    { no: 3, name: "next_token", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchUtxosResponse {
    return new SearchUtxosResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchUtxosResponse {
    return new SearchUtxosResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchUtxosResponse {
    return new SearchUtxosResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SearchUtxosResponse | PlainMessage<SearchUtxosResponse> | undefined, b: SearchUtxosResponse | PlainMessage<SearchUtxosResponse> | undefined): boolean {
    return proto3.util.equals(SearchUtxosResponse, a, b);
  }
}

/**
 * Request to get data (as in plural of datum)
 *
 * @generated from message utxorpc.v1alpha.query.ReadDataRequest
 */
export class ReadDataRequest extends Message<ReadDataRequest> {
  /**
   * @generated from field: repeated bytes keys = 1;
   */
  keys: Uint8Array[] = [];

  /**
   * Field mask to selectively return fields in the response.
   *
   * @generated from field: google.protobuf.FieldMask field_mask = 2;
   */
  fieldMask?: FieldMask;

  constructor(data?: PartialMessage<ReadDataRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "utxorpc.v1alpha.query.ReadDataRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "keys", kind: "scalar", T: 12 /* ScalarType.BYTES */, repeated: true },
    { no: 2, name: "field_mask", kind: "message", T: FieldMask },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadDataRequest {
    return new ReadDataRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadDataRequest {
    return new ReadDataRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadDataRequest {
    return new ReadDataRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReadDataRequest | PlainMessage<ReadDataRequest> | undefined, b: ReadDataRequest | PlainMessage<ReadDataRequest> | undefined): boolean {
    return proto3.util.equals(ReadDataRequest, a, b);
  }
}

/**
 * An evenlope that holds a datum for any of the compatible chains
 *
 * @generated from message utxorpc.v1alpha.query.AnyChainDatum
 */
export class AnyChainDatum extends Message<AnyChainDatum> {
  /**
   * Original bytes as defined by the chain
   *
   * @generated from field: bytes native_bytes = 1;
   */
  nativeBytes = new Uint8Array(0);

  /**
   * @generated from field: bytes key = 2;
   */
  key = new Uint8Array(0);

  /**
   * @generated from oneof utxorpc.v1alpha.query.AnyChainDatum.parsed_state
   */
  parsedState: {
    /**
     * A cardano UTxO
     *
     * @generated from field: utxorpc.v1alpha.cardano.PlutusData cardano = 3;
     */
    value: PlutusData;
    case: "cardano";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<AnyChainDatum>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "utxorpc.v1alpha.query.AnyChainDatum";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "native_bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "key", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 3, name: "cardano", kind: "message", T: PlutusData, oneof: "parsed_state" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AnyChainDatum {
    return new AnyChainDatum().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AnyChainDatum {
    return new AnyChainDatum().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AnyChainDatum {
    return new AnyChainDatum().fromJsonString(jsonString, options);
  }

  static equals(a: AnyChainDatum | PlainMessage<AnyChainDatum> | undefined, b: AnyChainDatum | PlainMessage<AnyChainDatum> | undefined): boolean {
    return proto3.util.equals(AnyChainDatum, a, b);
  }
}

/**
 * Response containing data (as in plural of datum)
 *
 * @generated from message utxorpc.v1alpha.query.ReadDataResponse
 */
export class ReadDataResponse extends Message<ReadDataResponse> {
  /**
   * The value of each datum.
   *
   * @generated from field: repeated utxorpc.v1alpha.query.AnyChainDatum values = 1;
   */
  values: AnyChainDatum[] = [];

  /**
   * The chain point that represent the ledger current position.
   *
   * @generated from field: utxorpc.v1alpha.query.ChainPoint ledger_tip = 2;
   */
  ledgerTip?: ChainPoint;

  constructor(data?: PartialMessage<ReadDataResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "utxorpc.v1alpha.query.ReadDataResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "message", T: AnyChainDatum, repeated: true },
    { no: 2, name: "ledger_tip", kind: "message", T: ChainPoint },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReadDataResponse {
    return new ReadDataResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReadDataResponse {
    return new ReadDataResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReadDataResponse {
    return new ReadDataResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReadDataResponse | PlainMessage<ReadDataResponse> | undefined, b: ReadDataResponse | PlainMessage<ReadDataResponse> | undefined): boolean {
    return proto3.util.equals(ReadDataResponse, a, b);
  }
}

