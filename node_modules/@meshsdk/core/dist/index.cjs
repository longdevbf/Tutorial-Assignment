"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  MintingBlueprint: () => MintingBlueprint,
  SpendingBlueprint: () => SpendingBlueprint,
  WithdrawalBlueprint: () => WithdrawalBlueprint,
  applyCborEncoding: () => applyCborEncoding,
  applyParamsToScript: () => applyParamsToScript2,
  checkSignature: () => import_core_cst.checkSignature,
  core: () => core,
  cst: () => cst,
  deserializeAddress: () => deserializeAddress,
  deserializeDatum: () => deserializeDatum,
  deserializePoolId: () => deserializePoolId,
  generateNonce: () => import_core_cst.generateNonce,
  resolveDataHash: () => resolveDataHash,
  resolveNativeScriptAddress: () => resolveNativeScriptAddress,
  resolveNativeScriptHash: () => resolveNativeScriptHash,
  resolveNativeScriptHex: () => resolveNativeScriptHex,
  resolvePaymentKeyHash: () => resolvePaymentKeyHash,
  resolvePlutusScriptAddress: () => resolvePlutusScriptAddress,
  resolvePlutusScriptHash: () => resolvePlutusScriptHash,
  resolvePoolId: () => resolvePoolId,
  resolvePrivateKey: () => resolvePrivateKey,
  resolveRewardAddress: () => resolveRewardAddress,
  resolveScriptHash: () => resolveScriptHash,
  resolveScriptHashDRepId: () => resolveScriptHashDRepId,
  resolveScriptRef: () => resolveScriptRef,
  resolveStakeKeyHash: () => resolveStakeKeyHash,
  resolveTxHash: () => resolveTxHash,
  serializeAddressObj: () => serializeAddressObj,
  serializeData: () => serializeData,
  serializeNativeScript: () => serializeNativeScript,
  serializePlutusScript: () => serializePlutusScript,
  serializePoolId: () => serializePoolId,
  serializeRewardAddress: () => serializeRewardAddress,
  signData: () => import_core_cst.signData
});
module.exports = __toCommonJS(index_exports);

// src/core.ts
var core = __toESM(require("@meshsdk/core-cst"), 1);
var applyParamsToScript2 = (rawScript, params, type) => core.applyParamsToScript(rawScript, params, type);
var applyCborEncoding = (rawScript) => {
  return Buffer.from(
    core.applyEncoding(Buffer.from(rawScript, "hex"), "SingleCBOR")
  ).toString("hex");
};

// src/utils/resolver.ts
var resolvePrivateKey = (words) => core.resolvePrivateKey(words);
var resolveTxHash = (txHex) => core.resolveTxHash(txHex);
var resolveDataHash = (rawData, type = "Mesh") => core.resolveDataHash(rawData, type);
var resolveNativeScriptHash = (script) => core.resolveNativeScriptHash(script);
var resolveScriptHash = (scriptCode, version) => {
  if (!version) {
    return core.deserializeNativeScript(scriptCode).hash().toString();
  }
  return core.deserializePlutusScript(scriptCode, version).hash().toString();
};
var resolveRewardAddress = (bech32) => core.resolveRewardAddress(bech32);
var resolveStakeKeyHash = (bech32) => core.resolveStakeKeyHash(bech32);
var resolveScriptHashDRepId = (scriptHash) => core.resolveScriptHashDRepId(scriptHash);
var resolvePlutusScriptAddress = (script, networkId) => core.resolvePlutusScriptAddress(script, networkId);
var resolveNativeScriptAddress = (script, networkId) => core.resolveNativeScriptAddress(script, networkId);
var resolveNativeScriptHex = (script) => core.toNativeScript(script).toCbor().toString();
var resolvePaymentKeyHash = (bech32) => core.deserializeBech32Address(bech32).pubKeyHash;
var resolvePlutusScriptHash = (bech32) => core.deserializeBech32Address(bech32).scriptHash;
var resolveScriptRef = (script) => core.resolveScriptRef(script);
var resolvePoolId = (hash) => core.resolvePoolId(hash);

// src/utils/deserializer.ts
var deserializeAddress = (bech32) => core.deserializeBech32Address(bech32);
var deserializeDatum = (datumCbor) => core.parseDatumCbor(datumCbor);
var deserializePoolId = (poolId) => core.resolveEd25519KeyHash(poolId);

// src/utils/serializer.ts
var serializeNativeScript = (script, stakeCredentialHash, networkId = 0, isScriptStakeCredential = false) => {
  if (networkId !== 0 && networkId !== 1) {
    throw new Error("Invalid network id");
  }
  const serializer = new core.CardanoSDKSerializer();
  const { scriptCbor, scriptHash } = serializer.deserializer.script.deserializeNativeScript(script);
  const deserializedAddress = {
    scriptHash
  };
  if (isScriptStakeCredential) {
    deserializedAddress.stakeScriptCredentialHash = stakeCredentialHash;
  } else {
    deserializedAddress.stakeCredentialHash = stakeCredentialHash;
  }
  const address = serializer.serializeAddress(deserializedAddress, networkId);
  return { address, scriptCbor };
};
var serializePlutusScript = (script, stakeCredentialHash, networkId = 0, isScriptStakeCredential = false) => {
  const scriptHash = core.deserializePlutusScript(script.code, script.version).hash().toString();
  const address = core.scriptHashToBech32(
    scriptHash,
    stakeCredentialHash,
    networkId,
    isScriptStakeCredential
  );
  return { address };
};
var serializeAddressObj = (address, networkId = 0) => {
  return core.serializeAddressObj(address, networkId);
};
var serializePoolId = (hash) => core.resolvePoolId(hash);
var serializeRewardAddress = (hash, isScriptHash = false, networkId = 0) => {
  return isScriptHash ? core.scriptHashToRewardAddress(hash, networkId) : core.keyHashToRewardAddress(hash, networkId);
};
var serializeData = (rawData, type = "Mesh") => {
  const serializer = new core.CardanoSDKSerializer();
  const builderData = {
    type,
    content: rawData
  };
  return serializer.serializeData(builderData);
};

// src/utils/blueprint/minting.ts
var MintingBlueprint = class {
  version;
  cbor;
  hash;
  constructor(version) {
    this.version = version;
    this.cbor = "";
    this.hash = "";
  }
  /**
   * Initialize the minting blueprint, with the same parameters to `applyParamsToScript`
   * @param compiledCode The raw script CborHex from blueprint.
   * @param params The parameters to apply, in an array.
   * @param paramsType The type of the parameters, default to be Mesh's Data type. It could also be in JSON and raw CBOR.
   * @returns The minting blueprint object
   */
  paramScript(compiledCode, params, paramsType = "Mesh") {
    const cbor = applyParamsToScript2(compiledCode, params, paramsType);
    const hash = resolveScriptHash(cbor, this.version);
    this.hash = hash;
    this.cbor = cbor;
    return this;
  }
  /**
   * Initialize the minting blueprint, with no parameters
   * @param compiledCode The raw script CborHex from blueprint.
   * @returns The minting blueprint object
   */
  noParamScript(compiledCode) {
    return this.paramScript(compiledCode, []);
  }
};

// src/utils/blueprint/spending.ts
var SpendingBlueprint = class {
  version;
  networkId;
  cbor;
  hash;
  address;
  stakeHash;
  isStakeScriptCredential;
  constructor(version, networkId, stakeHash, isStakeScriptCredential = false) {
    this.version = version;
    this.networkId = networkId;
    this.stakeHash = stakeHash;
    this.cbor = "";
    this.hash = "";
    this.address = "";
    this.isStakeScriptCredential = isStakeScriptCredential;
  }
  /**
   * Initialize the minting blueprint, with the same parameters to `applyParamsToScript`
   * @param compiledCode The raw script CborHex from blueprint.
   * @param params The parameters to apply, in an array.
   * @param paramsType The type of the parameters, default to be Mesh's Data type. It could also be in JSON and raw CBOR.
   * @returns
   */
  paramScript(compiledCode, params, paramsType = "Mesh") {
    const cbor = applyParamsToScript2(compiledCode, params, paramsType);
    const hash = resolveScriptHash(cbor, this.version);
    const plutusScript = {
      code: cbor,
      version: this.version
    };
    const address = serializePlutusScript(
      plutusScript,
      this.stakeHash,
      this.networkId,
      this.isStakeScriptCredential
    ).address;
    this.hash = hash;
    this.cbor = cbor;
    this.address = address;
    return this;
  }
  /**
   * Initialize the minting blueprint, with no parameters
   * @param compiledCode The raw script CborHex from blueprint.
   * @returns The minting blueprint object
   */
  noParamScript(compiledCode) {
    return this.paramScript(compiledCode, []);
  }
};

// src/utils/blueprint/withdrawal.ts
var WithdrawalBlueprint = class {
  version;
  networkId;
  cbor;
  hash;
  address;
  constructor(version, networkId) {
    this.version = version;
    this.networkId = networkId;
    this.cbor = "";
    this.hash = "";
    this.address = "";
  }
  /**
   * Initialize the withdrawal blueprint, with the same parameters to `applyParamsToScript`
   * @param compiledCode The raw script CborHex from blueprint.
   * @param params The parameters to apply, in an array.
   * @param paramsType The type of the parameters, default to be Mesh's Data type. It could also be in JSON and raw CBOR.
   * @returns The withdrawal blueprint object
   */
  paramScript(compiledCode, params, paramsType = "Mesh") {
    const cbor = applyParamsToScript2(compiledCode, params, paramsType);
    const hash = resolveScriptHash(cbor, this.version);
    this.address = serializeRewardAddress(hash, true, this.networkId);
    this.hash = hash;
    this.cbor = cbor;
    return this;
  }
  /**
   * Initialize the withdrawal blueprint, with no parameters
   * @param compiledCode The raw script CborHex from blueprint.
   * @returns The withdrawal blueprint object
   */
  noParamScript(compiledCode) {
    return this.paramScript(compiledCode, []);
  }
};

// src/index.ts
__reExport(index_exports, require("@meshsdk/common"), module.exports);
var cst = __toESM(require("@meshsdk/core-cst"), 1);
__reExport(index_exports, require("@meshsdk/provider"), module.exports);
__reExport(index_exports, require("@meshsdk/transaction"), module.exports);
__reExport(index_exports, require("@meshsdk/wallet"), module.exports);
var import_core_cst = require("@meshsdk/core-cst");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  MintingBlueprint,
  SpendingBlueprint,
  WithdrawalBlueprint,
  applyCborEncoding,
  applyParamsToScript,
  checkSignature,
  core,
  cst,
  deserializeAddress,
  deserializeDatum,
  deserializePoolId,
  generateNonce,
  resolveDataHash,
  resolveNativeScriptAddress,
  resolveNativeScriptHash,
  resolveNativeScriptHex,
  resolvePaymentKeyHash,
  resolvePlutusScriptAddress,
  resolvePlutusScriptHash,
  resolvePoolId,
  resolvePrivateKey,
  resolveRewardAddress,
  resolveScriptHash,
  resolveScriptHashDRepId,
  resolveScriptRef,
  resolveStakeKeyHash,
  resolveTxHash,
  serializeAddressObj,
  serializeData,
  serializeNativeScript,
  serializePlutusScript,
  serializePoolId,
  serializeRewardAddress,
  signData,
  ...require("@meshsdk/common"),
  ...require("@meshsdk/provider"),
  ...require("@meshsdk/transaction"),
  ...require("@meshsdk/wallet")
});
