import { Data, PlutusDataType, BuilderData, NativeScript, LanguageVersion, PlutusScript, DeserializedAddress, PubKeyAddress, ScriptAddress, IMintingBlueprint, ISpendingBlueprint, IWithdrawalBlueprint } from '@meshsdk/common';
export * from '@meshsdk/common';
import * as coreCst from '@meshsdk/core-cst';
export { coreCst as core };
export { coreCst as cst };
export { checkSignature, generateNonce, signData } from '@meshsdk/core-cst';
export * from '@meshsdk/provider';
export * from '@meshsdk/transaction';
export * from '@meshsdk/wallet';

/**
 * Apply parameters to a given CIP57 blueprint compiledCode,
 * making it ready for use in transactions
 *
 * @param rawScript - The raw script CborHex from blueprint.
 * @param params - The parameters to apply, in an array.
 * @param type - The type of the parameters, default to be Mesh's Data type. It could also be in JSON and raw CBOR.
 * @returns The double-cbor encoded script CborHex with the parameters applied.
 */
declare const applyParamsToScript: (rawScript: string, params: object[] | Data[], type?: PlutusDataType) => string;
/**
 * Apply Cbor encoding to rawScript from CIP57 blueprint compiledCode,
 * making it ready for use in transactions
 *
 * @param rawScript - The raw script CborHex from blueprint.
 * @returns The double-cbor encoded script CborHex.
 */
declare const applyCborEncoding: (rawScript: string) => string;

/**
 * Resolve the private key from mnemonic words
 *
 * Update pending to support resolving a tree of private key
 *
 * @param words The mnemonic words
 * @returns The private key
 */
declare const resolvePrivateKey: (words: string[]) => string;
/**
 * Resolve the transaction hash from transaction hex
 * @param txHex The transaction hex
 * @returns The transaction hash
 */
declare const resolveTxHash: (txHex: string) => string;
/**
 * Hash Cardano data
 * @param rawData Cardano data in Mesh, JSON or CBOR type
 * @param type The data type, either Mesh, JSON or CBOR
 * @returns Cardano data hash
 */
declare const resolveDataHash: (rawData: BuilderData["content"], type?: PlutusDataType) => string;
/**
 * Hash Cardano native script
 * @param script Cardano native script in Mesh NativeScript type
 * @returns Cardano native script hash
 */
declare const resolveNativeScriptHash: (script: NativeScript) => string;
/**
 * Converting script cbor hex to script hash
 * @param scriptCode The script cbor hex
 * @param version The language version of the plutus script, without providing indicates it is a native script
 * @returns The script hash
 */
declare const resolveScriptHash: (scriptCode: string, version?: LanguageVersion) => string;
/**
 * Resolve the Ed25519 key hash from bech32 address
 * @param bech32 The bech32 address
 * @returns The Ed25519 key hash
 */
declare const resolveRewardAddress: (bech32: string) => string;
/**
 * Resolve the stake key hash from bech32 address
 * @param bech32 The bech32 address, either in addrxxx or stakexxx
 * @returns The stake key hash
 */
declare const resolveStakeKeyHash: (bech32: string) => string;
/**
 *
 * @param scriptHash
 * @returns
 */
declare const resolveScriptHashDRepId: (scriptHash: string) => string;
/**
 * Deprecated - use `serializePlutusScript` instead
 */
declare const resolvePlutusScriptAddress: (script: PlutusScript, networkId?: number) => string;
/**
 * Deprecated - use `serializeNativeScript` instead
 */
declare const resolveNativeScriptAddress: (script: NativeScript, networkId?: number) => string;
/**
 * Deprecated - use `serializeNativeScript` instead
 */
declare const resolveNativeScriptHex: (script: NativeScript) => string;
/**
 * Deprecated - use `deserializeAddress` instead
 */
declare const resolvePaymentKeyHash: (bech32: string) => string;
/**
 * Deprecated - use `deserializeAddress` instead
 */
declare const resolvePlutusScriptHash: (bech32: string) => string;
/**
 * Deprecated - this is more used with the low level process inside Mesh
 *
 * If you need this, please import @meshsdk/core-csl or @meshsdk/core-cst instead
 */
declare const resolveScriptRef: (script: NativeScript | PlutusScript) => string;
/**
 * Deprecated - use `serializePoolId` instead
 */
declare const resolvePoolId: (hash: string) => string;

/**
 * Deserialize bech32 address into payment and staking parts, with visibility of whether they are script or key hash
 * @param bech32 The bech32 address
 * @returns The deserialized address object:
 *
 * ```ts
 * const { pubKeyHash, scriptHash, stakeCredentialHash, stakeScriptCredentialHash } = deserializeAddress(bech32Address);
 * ```
 */
declare const deserializeAddress: (bech32: string) => DeserializedAddress;
/**
 * Deserialize a datum from a CBOR string to JSON object
 * @param datumCbor The CBOR string
 * @returns The deserialized JSON object
 */
declare const deserializeDatum: <T = any>(datumCbor: string) => T;
/**
 * Deserialize a script from a poolxxxx to Ed25519 key hash
 * @param poolId The poolxxxx bech32 pool id
 * @returns The Ed25519 key hash
 */
declare const deserializePoolId: (poolId: string) => string;

/**
 * Serialize Native script into bech32 address
 * @param script The native script object
 * @param stakeCredentialHash The stake credential hash
 * @param networkId 0 (testnet) or 1 (mainnet). Default to be 0 (testnet).
 * @param isScriptStakeCredential Whether the script is a stake credential. Default to be false.
 * @returns Bech32 address
 */
declare const serializeNativeScript: (script: NativeScript, stakeCredentialHash?: string, networkId?: number, isScriptStakeCredential?: boolean) => {
    address: string;
    scriptCbor: string | undefined;
};
/**
 * Serialize Native script into bech32 address
 * @param script The native script object
 * @param stakeCredentialHash The stake credential hash
 * @param networkId 0 (testnet) or 1 (mainnet). Default to be 0 (testnet).
 * @param isScriptStakeCredential Whether the script is a stake credential. Default to be false.
 * @returns Bech32 address
 */
declare const serializePlutusScript: (script: PlutusScript, stakeCredentialHash?: string, networkId?: number, isScriptStakeCredential?: boolean) => {
    address: string;
};
/**
 * Serialize address in Cardano data JSON format into bech32 address
 * @param address The Cardano address in data JSON format
 * @param networkId 0 (testnet) or 1 (mainnet). Default to be 0 (testnet).
 * @returns Bech32 address
 */
declare const serializeAddressObj: (address: PubKeyAddress | ScriptAddress, networkId?: number) => string;
/**
 * Resolve the pool id from hash
 * @param hash The pool hash
 * @returns The pool id
 */
declare const serializePoolId: (hash: string) => string;
/**
 * Serialize a script hash or key hash into bech32 reward address
 * @param hash The script hash or key hash
 * @param isScriptHash Whether the hash is a script hash
 * @param networkId 0 (testnet) or 1 (mainnet). Default to be 0 (testnet).
 * @returns Bech32 reward address
 */
declare const serializeRewardAddress: (hash: string, isScriptHash?: boolean, networkId?: 0 | 1) => string;
/**
 * Serialize the data from Mesh or JSON format into CBOR hex
 * @param data The data in Mesh or JSON format
 * @param type The data type. Default to be Mesh data type
 * @returns The CBOR hex string
 */
declare const serializeData: (rawData: BuilderData["content"], type?: Omit<PlutusDataType, "CBOR">) => string;

/**
 * Minting blueprint
 * @category Blueprint
 * @implements IMintingBlueprint
 * @class
 * @example
 *
 * const blueprint = new MintingBlueprint("V3");
 * blueprint.paramScript("84xxxxxx", ["params"], "Mesh");
 *
 * const policyId = blueprint.hash;
 * const scriptCbor = blueprint.cbor;
 */
declare class MintingBlueprint implements IMintingBlueprint {
    version: LanguageVersion;
    cbor: string;
    hash: string;
    constructor(version: LanguageVersion);
    /**
     * Initialize the minting blueprint, with the same parameters to `applyParamsToScript`
     * @param compiledCode The raw script CborHex from blueprint.
     * @param params The parameters to apply, in an array.
     * @param paramsType The type of the parameters, default to be Mesh's Data type. It could also be in JSON and raw CBOR.
     * @returns The minting blueprint object
     */
    paramScript(compiledCode: string, params: object[] | Data[], paramsType?: PlutusDataType): this;
    /**
     * Initialize the minting blueprint, with no parameters
     * @param compiledCode The raw script CborHex from blueprint.
     * @returns The minting blueprint object
     */
    noParamScript(compiledCode: string): this;
}

/**
 * Spending blueprint
 * @category Blueprint
 * @implements ISpendingBlueprint
 * @class
 * @example
 *
 * const blueprint = new SpendingBlueprint("V3", 0, stakeHash);
 * blueprint.paramScript("84xxxxxx", ["params"], "Mesh");
 *
 * const scriptHash = blueprint.hash;
 * const scriptCbor = blueprint.cbor;
 * const scriptAddress = blueprint.address;
 */
declare class SpendingBlueprint implements ISpendingBlueprint {
    version: LanguageVersion;
    networkId: number;
    cbor: string;
    hash: string;
    address: string;
    stakeHash?: string;
    isStakeScriptCredential: boolean;
    constructor(version: LanguageVersion, networkId: number, stakeHash: string, isStakeScriptCredential?: boolean);
    /**
     * Initialize the minting blueprint, with the same parameters to `applyParamsToScript`
     * @param compiledCode The raw script CborHex from blueprint.
     * @param params The parameters to apply, in an array.
     * @param paramsType The type of the parameters, default to be Mesh's Data type. It could also be in JSON and raw CBOR.
     * @returns
     */
    paramScript(compiledCode: string, params: object[] | Data[], paramsType?: PlutusDataType): this;
    /**
     * Initialize the minting blueprint, with no parameters
     * @param compiledCode The raw script CborHex from blueprint.
     * @returns The minting blueprint object
     */
    noParamScript(compiledCode: string): this;
}

/**
 * Withdrawal blueprint
 * @category Blueprint
 * @implements IWithdrawalBlueprint
 * @class
 * @example
 *
 * const blueprint = new WithdrawalBlueprint("V3", 0);
 * blueprint.paramScript("84xxxxxx", ["params"], "Mesh");
 *
 * const scriptHash = blueprint.hash;
 * const scriptCbor = blueprint.cbor;
 * const rewardAddress = blueprint.address;
 */
declare class WithdrawalBlueprint implements IWithdrawalBlueprint {
    version: LanguageVersion;
    networkId: number;
    cbor: string;
    hash: string;
    address: string;
    constructor(version: LanguageVersion, networkId: number);
    /**
     * Initialize the withdrawal blueprint, with the same parameters to `applyParamsToScript`
     * @param compiledCode The raw script CborHex from blueprint.
     * @param params The parameters to apply, in an array.
     * @param paramsType The type of the parameters, default to be Mesh's Data type. It could also be in JSON and raw CBOR.
     * @returns The withdrawal blueprint object
     */
    paramScript(compiledCode: string, params: object[] | Data[], paramsType?: PlutusDataType): this;
    /**
     * Initialize the withdrawal blueprint, with no parameters
     * @param compiledCode The raw script CborHex from blueprint.
     * @returns The withdrawal blueprint object
     */
    noParamScript(compiledCode: string): this;
}

export { MintingBlueprint, SpendingBlueprint, WithdrawalBlueprint, applyCborEncoding, applyParamsToScript, deserializeAddress, deserializeDatum, deserializePoolId, resolveDataHash, resolveNativeScriptAddress, resolveNativeScriptHash, resolveNativeScriptHex, resolvePaymentKeyHash, resolvePlutusScriptAddress, resolvePlutusScriptHash, resolvePoolId, resolvePrivateKey, resolveRewardAddress, resolveScriptHash, resolveScriptHashDRepId, resolveScriptRef, resolveStakeKeyHash, resolveTxHash, serializeAddressObj, serializeData, serializeNativeScript, serializePlutusScript, serializePoolId, serializeRewardAddress };
