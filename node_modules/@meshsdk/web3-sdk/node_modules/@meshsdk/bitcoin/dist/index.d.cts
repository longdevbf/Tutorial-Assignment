import * as ecpair from 'ecpair';
import * as _bip32 from 'bip32';
import * as bitcoin from 'bitcoinjs-lib';
export { bitcoin };
import * as bip39 from 'bip39';
export { bip39 };

declare const bip32: _bip32.BIP32API;
declare const ECPair: ecpair.ECPairAPI;

interface IBitcoinWallet {
    getChangeAddress(): Promise<string>;
    getNetworkId(): Promise<0 | 1>;
    signTx(signedTx: string): Promise<string>;
    submitTx(tx: string): Promise<string>;
}

type Address = {
    address: string;
    publicKey: string;
    purpose: "payment" | "ordinals" | "stacks";
    addressType: "p2tr" | "p2wpkh" | "p2sh" | "stacks";
};

type UTxO = {
    status: {
        block_hash: string;
        block_height: number;
        block_time: number;
        confirmed: boolean;
    };
    txid: string;
    value: number;
    vout: number;
};

type ChainStats = {
    funded_txo_count: number;
    funded_txo_sum: number;
    spent_txo_count: number;
    spent_txo_sum: number;
    tx_count: number;
};

type MempoolStats = {
    funded_txo_count: number;
    funded_txo_sum: number;
    spent_txo_count: number;
    spent_txo_sum: number;
    tx_count: number;
};

type AddressInfo = {
    address: string;
    chain_stats: ChainStats;
    mempool_stats: MempoolStats;
};

type ScriptInfo = {
    scripthash: string;
    chain_stats: ChainStats;
    mempool_stats: MempoolStats;
};

type TransactionsStatus = {
    confirmed: boolean;
    block_height: number;
    block_hash: string;
    block_time: number;
};

type TransactionsInfo = {
    txid: string;
    version: number;
    locktime: number;
    vin: {
        txid: string;
        vout: number;
        prevout: {
            scriptpubkey: string;
            scriptpubkey_asm: string;
            scriptpubkey_type: string;
            scriptpubkey_address: string;
            value: number;
        };
        scriptsig: string;
        scriptsig_asm: string;
        witness: string[];
        is_coinbase: boolean;
        sequence: number;
    }[];
    vout: {
        scriptpubkey: string;
        scriptpubkey_asm: string;
        scriptpubkey_type: string;
        scriptpubkey_address: string;
        value: number;
    }[];
    size: number;
    weight: number;
    fee: number;
    status: TransactionsStatus;
};

interface IBitcoinProvider {
    fetchAddress(address: string): Promise<AddressInfo>;
    fetchAddressTransactions(address: string, last_seen_txid?: string): Promise<TransactionsInfo[]>;
    fetchAddressUTxOs(address: string): Promise<UTxO[]>;
    fetchScript(hash: string): Promise<ScriptInfo>;
    fetchScriptTransactions(hash: string, last_seen_txid?: string): Promise<TransactionsInfo[]>;
    fetchScriptUTxOs(hash: string): Promise<UTxO[]>;
    fetchTransactionStatus(txid: string): Promise<TransactionsStatus>;
    submitTx(tx: string): Promise<string>;
}

/**
 * https://github.com/Blockstream/esplora/blob/master/API.md
 */
declare class BlockstreamProvider implements IBitcoinProvider {
    private readonly _axiosInstance;
    constructor(network?: "mainnet" | "testnet");
    /**
     * Get information about an address.
     * @param address - The address.
     * @returns AddressInfo
     */
    fetchAddress(address: string): Promise<AddressInfo>;
    /**
     * Get transaction history for the specified address, sorted with newest first.
     * Returns up to 50 mempool transactions plus the first 25 confirmed transactions. You can request more confirmed transactions using `last_seen_txid`.
     * @param address - The address.
     * @param last_seen_txid - The last seen transaction ID (optional).
     * @returns TransactionsInfo[]
     */
    fetchAddressTransactions(address: string, last_seen_txid?: string): Promise<TransactionsInfo[]>;
    /**
     * Get the list of unspent transaction outputs associated with the address.
     * @param address - The address.
     * @returns UTxO[]
     */
    fetchAddressUTxOs(address: string): Promise<UTxO[]>;
    /**
     * Get information about a scripthash.
     * @param hash - The hash of the script.
     * @returns ScriptInfo
     */
    fetchScript(hash: string): Promise<ScriptInfo>;
    /**
     * Get transaction history for the specified scripthash, sorted with newest first.
     * Returns up to 50 mempool transactions plus the first 25 confirmed transactions. You can request more confirmed transactions using `last_seen_txid`.
     * @param hash - The hash of the script.
     * @param last_seen_txid - The last seen transaction ID (optional).
     * @returns TransactionsInfo[]
     */
    fetchScriptTransactions(hash: string, last_seen_txid?: string): Promise<TransactionsInfo[]>;
    /**
     * Get the list of unspent transaction outputs associated with the scripthash.
     * @param hash - The hash of the script.
     * @returns UTxO[]
     */
    fetchScriptUTxOs(hash: string): Promise<UTxO[]>;
    /**
     * Fetches the status of a transaction
     * @param txid - The transaction ID.
     * @returns TransactionsStatus
     */
    fetchTransactionStatus(txid: string): Promise<TransactionsStatus>;
    /**
     * Broadcast a raw transaction to the network.
     * The transaction should be provided as hex in the request body. The txid will be returned on success.
     * @param tx - The transaction in hex format.
     * @returns The transaction ID.
     */
    submitTx(tx: string): Promise<string>;
}

declare class BrowserWallet implements IBitcoinWallet {
    private readonly _purposes;
    constructor(purposes: string[]);
    /**
     * This is the entrypoint to start communication with the user's wallet. The wallet should request the user's permission to connect the web page to the user's wallet, and if permission has been granted, the wallet will be returned and exposing the full API for the dApp to use.
     * @param message - A message to display to the user when requesting permission to connect the wallet.
     * @param purposes - An array of purposes for which the wallet is being connected. Default is `["payment"]`. Options are `["payment", "ordinals", "stacks"]`.
     * @returns
     */
    static enable(message: string, purposes?: string[]): Promise<BrowserWallet>;
    getAddresses(): Promise<Address[] | undefined>;
    getChangeAddress(): Promise<string>;
    getCollateral(): Promise<never[]>;
    getNetworkId(): Promise<0 | 1>;
    request(method: string, params?: any): Promise<any>;
    signData(payload: string, address?: string, addressType?: "p2wpkh" | "p2tr" | "stacks"): Promise<{
        address: string;
        signature: string;
        messageHash: string;
    } | undefined>;
    signTx(signedTx: string): Promise<string>;
    submitTx(signedTx: string): Promise<string>;
}

type CreateWalletOptions = {
    testnet: boolean;
    key: {
        type: "mnemonic";
        words: string[];
    };
    path?: string;
    provider?: IBitcoinProvider;
};
/**
 * EmbeddedWallet is a class that provides a simple interface to interact with Bitcoin wallets.
 */
declare class EmbeddedWallet {
    private readonly _network;
    private readonly _wallet;
    private readonly _provider?;
    constructor(options: CreateWalletOptions);
    /**
     * Returns the wallet's SegWit (P2WPKH) address and associated public key.
     *
     * @returns {Address} The wallet address object including address, public key, and metadata.
     * @throws {Error} If internal address or public key is not properly initialized.
     */
    getAddress(): Address;
    /**
     * Returns the hex-encoded public key of the wallet.
     *
     * @returns {string} The public key in hexadecimal format.
     */
    getPublicKey(): string;
    /**
     * Returns the network identifier of the wallet.
     * 0': Indicates the Bitcoin mainnet.
     * 1': Indicates the Bitcoin testnet.
     *
     * @returns {0 | 1} The Bitcoin network ID.
     */
    getNetworkId(): 0 | 1;
    /**
     * Get UTXOs for the wallet address.
     * @returns An array of UTXOs.
     */
    getUTxOs(): Promise<UTxO[]>;
    /**
     * Signs a given message using the wallet's private key.
     *
     * @param message - The message to be signed.
     * @returns The signature of the message as a string.
     */
    signData(message: string): string;
    /**
     * Sign a transaction payload.
     * @param payload - The transaction payload to sign.
     * @returns The signed transaction in hex format.
     */
    signTx(payload: bitcoin.Transaction): string;
    /**
     * Generates a mnemonic phrase and returns it as an array of words.
     *
     * @param {number} [strength=128] - The strength of the mnemonic in bits (must be a multiple of 32 between 128 and 256).
     * @returns {string[]} An array of words representing the generated mnemonic.
     * @throws {Error} If the strength is not valid.
     */
    static brew(strength?: number): string[];
}

export { type Address, BlockstreamProvider, BrowserWallet, type CreateWalletOptions, ECPair, EmbeddedWallet, type IBitcoinWallet, type UTxO, bip32 };
