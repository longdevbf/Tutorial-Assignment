function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_with_holes(arr) {
    if (Array.isArray(arr)) return arr;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _async_generator(gen) {
    var front, back;
    function send(key, arg) {
        return new Promise(function(resolve, reject) {
            var request = {
                key: key,
                arg: arg,
                resolve: resolve,
                reject: reject,
                next: null
            };
            if (back) {
                back = back.next = request;
            } else {
                front = back = request;
                resume(key, arg);
            }
        });
    }
    function resume(key, arg) {
        try {
            var result = gen[key](arg);
            var value = result.value;
            var wrappedAwait = value instanceof _await_value;
            Promise.resolve(wrappedAwait ? value.wrapped : value).then(function(arg) {
                if (wrappedAwait) {
                    resume("next", arg);
                    return;
                }
                settle(result.done ? "return" : "normal", arg);
            }, function(err) {
                resume("throw", err);
            });
        } catch (err) {
            settle("throw", err);
        }
    }
    function settle(type, value) {
        switch(type){
            case "return":
                front.resolve({
                    value: value,
                    done: true
                });
                break;
            case "throw":
                front.reject(value);
                break;
            default:
                front.resolve({
                    value: value,
                    done: false
                });
                break;
        }
        front = front.next;
        if (front) {
            resume(front.key, front.arg);
        } else {
            back = null;
        }
    }
    this._invoke = send;
    if (typeof gen.return !== "function") {
        this.return = undefined;
    }
}
if (typeof Symbol === "function" && Symbol.asyncIterator) {
    _async_generator.prototype[Symbol.asyncIterator] = function() {
        return this;
    };
}
_async_generator.prototype.next = function(arg) {
    return this._invoke("next", arg);
};
_async_generator.prototype.throw = function(arg) {
    return this._invoke("throw", arg);
};
_async_generator.prototype.return = function(arg) {
    return this._invoke("return", arg);
};
function _async_generator_delegate(inner, awaitWrap) {
    var iter = {}, waiting = false;
    function pump(key, value) {
        waiting = true;
        value = new Promise(function(resolve) {
            resolve(inner[key](value));
        });
        return {
            done: false,
            value: awaitWrap(value)
        };
    }
    if (typeof Symbol === "function" && Symbol.iterator) {
        iter[Symbol.iterator] = function() {
            return this;
        };
    }
    iter.next = function(value) {
        if (waiting) {
            waiting = false;
            return value;
        }
        return pump("next", value);
    };
    if (typeof inner.throw === "function") {
        iter.throw = function(value) {
            if (waiting) {
                waiting = false;
                throw value;
            }
            return pump("throw", value);
        };
    }
    if (typeof inner.return === "function") {
        iter.return = function(value) {
            return pump("return", value);
        };
    }
    return iter;
}
function _async_iterator(iterable) {
    var method, async, sync, retry = 2;
    for("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;){
        if (async && null != (method = iterable[async])) return method.call(iterable);
        if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));
        async = "@@asyncIterator", sync = "@@iterator";
    }
    throw new TypeError("Object is not async iterable");
}
function AsyncFromSyncIterator(s) {
    function AsyncFromSyncIteratorContinuation(r) {
        if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object."));
        var done = r.done;
        return Promise.resolve(r.value).then(function(value) {
            return {
                value: value,
                done: done
            };
        });
    }
    return AsyncFromSyncIterator = function(s) {
        this.s = s, this.n = s.next;
    }, AsyncFromSyncIterator.prototype = {
        s: null,
        n: null,
        next: function() {
            return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
        },
        return: function(value) {
            var ret = this.s.return;
            return void 0 === ret ? Promise.resolve({
                value: value,
                done: !0
            }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));
        },
        throw: function(value) {
            var thr = this.s.return;
            return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));
        }
    }, new AsyncFromSyncIterator(s);
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self1 = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self1, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _await_async_generator(value) {
    return new _await_value(value);
}
function _await_value(value) {
    this.wrapped = value;
}
function _class_call_check(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _create_class(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _instanceof(left, right) {
    if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
        return !!right[Symbol.hasInstance](left);
    } else {
        return left instanceof right;
    }
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _iterable_to_array_limit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
        for(_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true){
            _arr.push(_s.value);
            if (i && _arr.length === i) break;
        }
    } catch (err) {
        _d = true;
        _e = err;
    } finally{
        try {
            if (!_n && _i["return"] != null) _i["return"]();
        } finally{
            if (_d) throw _e;
        }
    }
    return _arr;
}
function _non_iterable_rest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function _sliced_to_array(arr, i) {
    return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}
function _to_array(arr) {
    return _array_with_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_rest();
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _type_of(obj) {
    "@swc/helpers - typeof";
    return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
function _wrap_async_generator(fn) {
    return function() {
        return new _async_generator(fn.apply(this, arguments));
    };
}
function _ts_generator(thisArg, body) {
    var f, y, t, g, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    };
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
function _ts_values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function() {
            if (o && i >= o.length) o = void 0;
            return {
                value: o && o[i++],
                done: !o
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
var __defProp = Object.defineProperty;
var __export = function(target, all3) {
    for(var name in all3)__defProp(target, name, {
        get: all3[name],
        enumerable: true
    });
};
// <define:process>
var define_process_default = {
    env: {
        NODE_ENV: "production"
    }
};
// src/core.ts
import * as bitcoin from "bitcoinjs-lib";
import * as ecc from "@bitcoin-js/tiny-secp256k1-asmjs";
import * as bip39 from "bip39";
import { BIP32Factory } from "bip32";
import { ECPairFactory } from "ecpair";
var bip32 = BIP32Factory(ecc);
var ECPair = ECPairFactory(ecc);
bitcoin.initEccLib(ecc);
// ../../node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
    return function wrap() {
        return fn.apply(thisArg, arguments);
    };
}
// ../../node_modules/axios/lib/utils.js
var toString = Object.prototype.toString;
var getPrototypeOf = Object.getPrototypeOf;
var kindOf = /* @__PURE__ */ function(cache) {
    return function(thing) {
        var str = toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    };
}(/* @__PURE__ */ Object.create(null));
var kindOfTest = function(type) {
    type = type.toLowerCase();
    return function(thing) {
        return kindOf(thing) === type;
    };
};
var typeOfTest = function(type) {
    return function(thing) {
        return (typeof thing === "undefined" ? "undefined" : _type_of(thing)) === type;
    };
};
var isArray = Array.isArray;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
    var result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
    } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = function(thing) {
    return thing !== null && (typeof thing === "undefined" ? "undefined" : _type_of(thing)) === "object";
};
var isBoolean = function(thing) {
    return thing === true || thing === false;
};
var isPlainObject = function(val) {
    if (kindOf(val) !== "object") {
        return false;
    }
    var prototype3 = getPrototypeOf(val);
    return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = function(val) {
    return isObject(val) && isFunction(val.pipe);
};
var isFormData = function(thing) {
    var kind;
    return thing && (typeof FormData === "function" && _instanceof(thing, FormData) || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var _map = _sliced_to_array([
    "ReadableStream",
    "Request",
    "Response",
    "Headers"
].map(kindOfTest), 4), isReadableStream = _map[0], isRequest = _map[1], isResponse = _map[2], isHeaders = _map[3];
var trim = function(str) {
    return str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
};
function forEach(obj, fn) {
    var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref_allOwnKeys = _ref.allOwnKeys, allOwnKeys = _ref_allOwnKeys === void 0 ? false : _ref_allOwnKeys;
    if (obj === null || typeof obj === "undefined") {
        return;
    }
    var i;
    var l;
    if ((typeof obj === "undefined" ? "undefined" : _type_of(obj)) !== "object") {
        obj = [
            obj
        ];
    }
    if (isArray(obj)) {
        for(i = 0, l = obj.length; i < l; i++){
            fn.call(null, obj[i], i, obj);
        }
    } else {
        var keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        var len = keys.length;
        var key;
        for(i = 0; i < len; i++){
            key = keys[i];
            fn.call(null, obj[key], key, obj);
        }
    }
}
function findKey(obj, key) {
    key = key.toLowerCase();
    var keys = Object.keys(obj);
    var i = keys.length;
    var _key;
    while(i-- > 0){
        _key = keys[i];
        if (key === _key.toLowerCase()) {
            return _key;
        }
    }
    return null;
}
var _global = function() {
    if (typeof globalThis !== "undefined") return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : globalThis;
}();
var isContextDefined = function(context) {
    return !isUndefined(context) && context !== _global;
};
function merge() {
    var caseless = (isContextDefined(this) && this || {}).caseless;
    var result = {};
    var assignValue = function(val, key) {
        var targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
            result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
            result[targetKey] = merge({}, val);
        } else if (isArray(val)) {
            result[targetKey] = val.slice();
        } else {
            result[targetKey] = val;
        }
    };
    for(var i = 0, l = arguments.length; i < l; i++){
        arguments[i] && forEach(arguments[i], assignValue);
    }
    return result;
}
var extend = function(a, b, thisArg) {
    var allOwnKeys = (arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}).allOwnKeys;
    forEach(b, function(val, key) {
        if (thisArg && isFunction(val)) {
            a[key] = bind(val, thisArg);
        } else {
            a[key] = val;
        }
    }, {
        allOwnKeys: allOwnKeys
    });
    return a;
};
var stripBOM = function(content) {
    if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
    }
    return content;
};
var inherits = function(constructor, superConstructor, props, descriptors2) {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
};
var toFlatObject = function(sourceObj, destObj, filter2, propFilter) {
    var props;
    var i;
    var prop;
    var merged = {};
    destObj = destObj || {};
    if (sourceObj == null) return destObj;
    do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while(i-- > 0){
            prop = props[i];
            if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
                destObj[prop] = sourceObj[prop];
                merged[prop] = true;
            }
        }
        sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
    }while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
};
var endsWith = function(str, searchString, position) {
    str = String(str);
    if (position === void 0 || position > str.length) {
        position = str.length;
    }
    position -= searchString.length;
    var lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
};
var toArray = function(thing) {
    if (!thing) return null;
    if (isArray(thing)) return thing;
    var i = thing.length;
    if (!isNumber(i)) return null;
    var arr = new Array(i);
    while(i-- > 0){
        arr[i] = thing[i];
    }
    return arr;
};
var isTypedArray = /* @__PURE__ */ function(TypedArray) {
    return function(thing) {
        return TypedArray && _instanceof(thing, TypedArray);
    };
}(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = function(obj, fn) {
    var generator = obj && obj[Symbol.iterator];
    var iterator = generator.call(obj);
    var result;
    while((result = iterator.next()) && !result.done){
        var pair = result.value;
        fn.call(obj, pair[0], pair[1]);
    }
};
var matchAll = function(regExp, str) {
    var matches;
    var arr = [];
    while((matches = regExp.exec(str)) !== null){
        arr.push(matches);
    }
    return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = function(str) {
    return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function replacer(m, p1, p2) {
        return p1.toUpperCase() + p2;
    });
};
var hasOwnProperty = function(param) {
    var hasOwnProperty2 = param.hasOwnProperty;
    return function(obj, prop) {
        return hasOwnProperty2.call(obj, prop);
    };
}(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = function(obj, reducer) {
    var descriptors2 = Object.getOwnPropertyDescriptors(obj);
    var reducedDescriptors = {};
    forEach(descriptors2, function(descriptor, name) {
        var ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
            reducedDescriptors[name] = ret || descriptor;
        }
    });
    Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = function(obj) {
    reduceDescriptors(obj, function(descriptor, name) {
        if (isFunction(obj) && [
            "arguments",
            "caller",
            "callee"
        ].indexOf(name) !== -1) {
            return false;
        }
        var value = obj[name];
        if (!isFunction(value)) return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
            descriptor.writable = false;
            return;
        }
        if (!descriptor.set) {
            descriptor.set = function() {
                throw Error("Can not rewrite read-only method '" + name + "'");
            };
        }
    });
};
var toObjectSet = function(arrayOrString, delimiter) {
    var obj = {};
    var define = function(arr) {
        arr.forEach(function(value) {
            obj[value] = true;
        });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
    return obj;
};
var noop = function() {};
var toFiniteNumber = function(value, defaultValue) {
    return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
    return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = function(obj) {
    var stack = new Array(10);
    var visit = function(source, i) {
        if (isObject(source)) {
            if (stack.indexOf(source) >= 0) {
                return;
            }
            if (!("toJSON" in source)) {
                stack[i] = source;
                var target = isArray(source) ? [] : {};
                forEach(source, function(value, key) {
                    var reducedValue = visit(value, i + 1);
                    !isUndefined(reducedValue) && (target[key] = reducedValue);
                });
                stack[i] = void 0;
                return target;
            }
        }
        return source;
    };
    return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = function(thing) {
    return thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
};
var _setImmediate = function(setImmediateSupported, postMessageSupported) {
    if (setImmediateSupported) {
        return setImmediate;
    }
    return postMessageSupported ? function(token, callbacks) {
        _global.addEventListener("message", function(param) {
            var source = param.source, data = param.data;
            if (source === _global && data === token) {
                callbacks.length && callbacks.shift()();
            }
        }, false);
        return function(cb) {
            callbacks.push(cb);
            _global.postMessage(token, "*");
        };
    }("axios@".concat(Math.random()), []) : function(cb) {
        return setTimeout(cb);
    };
}(typeof setImmediate === "function", isFunction(_global.postMessage));
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof define_process_default !== "undefined" && define_process_default.nextTick || _setImmediate;
var utils_default = {
    isArray: isArray,
    isArrayBuffer: isArrayBuffer,
    isBuffer: isBuffer,
    isFormData: isFormData,
    isArrayBufferView: isArrayBufferView,
    isString: isString,
    isNumber: isNumber,
    isBoolean: isBoolean,
    isObject: isObject,
    isPlainObject: isPlainObject,
    isReadableStream: isReadableStream,
    isRequest: isRequest,
    isResponse: isResponse,
    isHeaders: isHeaders,
    isUndefined: isUndefined,
    isDate: isDate,
    isFile: isFile,
    isBlob: isBlob,
    isRegExp: isRegExp,
    isFunction: isFunction,
    isStream: isStream,
    isURLSearchParams: isURLSearchParams,
    isTypedArray: isTypedArray,
    isFileList: isFileList,
    forEach: forEach,
    merge: merge,
    extend: extend,
    trim: trim,
    stripBOM: stripBOM,
    inherits: inherits,
    toFlatObject: toFlatObject,
    kindOf: kindOf,
    kindOfTest: kindOfTest,
    endsWith: endsWith,
    toArray: toArray,
    forEachEntry: forEachEntry,
    matchAll: matchAll,
    isHTMLForm: isHTMLForm,
    hasOwnProperty: hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors: reduceDescriptors,
    freezeMethods: freezeMethods,
    toObjectSet: toObjectSet,
    toCamelCase: toCamelCase,
    noop: noop,
    toFiniteNumber: toFiniteNumber,
    findKey: findKey,
    global: _global,
    isContextDefined: isContextDefined,
    isSpecCompliantForm: isSpecCompliantForm,
    toJSONObject: toJSONObject,
    isAsyncFn: isAsyncFn,
    isThenable: isThenable,
    setImmediate: _setImmediate,
    asap: asap
};
// ../../node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    } else {
        this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    if (response) {
        this.response = response;
        this.status = response.status ? response.status : null;
    }
}
utils_default.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
        return {
            // Standard
            message: this.message,
            name: this.name,
            // Microsoft
            description: this.description,
            number: this.number,
            // Mozilla
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            // Axios
            config: utils_default.toJSONObject(this.config),
            code: this.code,
            status: this.status
        };
    }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
].forEach(function(code) {
    descriptors[code] = {
        value: code
    };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", {
    value: true
});
AxiosError.from = function(error, code, config, request, response, customProps) {
    var axiosError = Object.create(prototype);
    utils_default.toFlatObject(error, axiosError, function filter2(obj) {
        return obj !== Error.prototype;
    }, function(prop) {
        return prop !== "isAxiosError";
    });
    AxiosError.call(axiosError, error.message, code, config, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
};
var AxiosError_default = AxiosError;
// ../../node_modules/axios/lib/helpers/null.js
var null_default = null;
// ../../node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
    return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
    return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
    if (!path) return key;
    return path.concat(key).map(function each(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
}
function isFlatArray(arr) {
    return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
    if (!utils_default.isObject(obj)) {
        throw new TypeError("target must be an object");
    }
    formData = formData || new (null_default || FormData)();
    options = utils_default.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
    }, false, function defined(option, source) {
        return !utils_default.isUndefined(source[option]);
    });
    var metaTokens = options.metaTokens;
    var visitor = options.visitor || defaultVisitor;
    var dots = options.dots;
    var indexes = options.indexes;
    var _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    var useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
    if (!utils_default.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
        if (value === null) return "";
        if (utils_default.isDate(value)) {
            return value.toISOString();
        }
        if (!useBlob && utils_default.isBlob(value)) {
            throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
        }
        if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
            return useBlob && typeof Blob === "function" ? new Blob([
                value
            ]) : Buffer.from(value);
        }
        return value;
    }
    function defaultVisitor(value, key, path) {
        var arr = value;
        if (value && !path && (typeof value === "undefined" ? "undefined" : _type_of(value)) === "object") {
            if (utils_default.endsWith(key, "{}")) {
                key = metaTokens ? key : key.slice(0, -2);
                value = JSON.stringify(value);
            } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
                key = removeBrackets(key);
                arr.forEach(function each(el, index) {
                    !(utils_default.isUndefined(el) || el === null) && formData.append(// eslint-disable-next-line no-nested-ternary
                    indexes === true ? renderKey([
                        key
                    ], index, dots) : indexes === null ? key : key + "[]", convertValue(el));
                });
                return false;
            }
        }
        if (isVisitable(value)) {
            return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
    }
    var stack = [];
    var exposedHelpers = Object.assign(predicates, {
        defaultVisitor: defaultVisitor,
        convertValue: convertValue,
        isVisitable: isVisitable
    });
    function build(value, path) {
        if (utils_default.isUndefined(value)) return;
        if (stack.indexOf(value) !== -1) {
            throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils_default.forEach(value, function each(el, key) {
            var result = !(utils_default.isUndefined(el) || el === null) && visitor.call(formData, el, utils_default.isString(key) ? key.trim() : key, path, exposedHelpers);
            if (result === true) {
                build(el, path ? path.concat(key) : [
                    key
                ]);
            }
        });
        stack.pop();
    }
    if (!utils_default.isObject(obj)) {
        throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
}
var toFormData_default = toFormData;
// ../../node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
    var charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
    });
}
function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
    this._pairs.push([
        name,
        value
    ]);
};
prototype2.toString = function toString2(encoder) {
    var _encode = encoder ? function _encode(value) {
        return encoder.call(this, value, encode);
    } : encode;
    return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;
// ../../node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
    if (!params) {
        return url;
    }
    var _encode = options && options.encode || encode2;
    if (utils_default.isFunction(options)) {
        options = {
            serialize: options
        };
    }
    var serializeFn = options && options.serialize;
    var serializedParams;
    if (serializeFn) {
        serializedParams = serializeFn(params, options);
    } else {
        serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
    }
    if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
            url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
}
// ../../node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = /*#__PURE__*/ function() {
    "use strict";
    function InterceptorManager() {
        _class_call_check(this, InterceptorManager);
        this.handlers = [];
    }
    _create_class(InterceptorManager, [
        {
            /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */ key: "use",
            value: function use(fulfilled, rejected, options) {
                this.handlers.push({
                    fulfilled: fulfilled,
                    rejected: rejected,
                    synchronous: options ? options.synchronous : false,
                    runWhen: options ? options.runWhen : null
                });
                return this.handlers.length - 1;
            }
        },
        {
            /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */ key: "eject",
            value: function eject(id) {
                if (this.handlers[id]) {
                    this.handlers[id] = null;
                }
            }
        },
        {
            /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */ key: "clear",
            value: function clear() {
                if (this.handlers) {
                    this.handlers = [];
                }
            }
        },
        {
            /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */ key: "forEach",
            value: function forEach(fn) {
                utils_default.forEach(this.handlers, function forEachHandler(h) {
                    if (h !== null) {
                        fn(h);
                    }
                });
            }
        }
    ]);
    return InterceptorManager;
}();
var InterceptorManager_default = InterceptorManager;
// ../../node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
};
// ../../node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;
// ../../node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;
// ../../node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;
// ../../node_modules/axios/lib/platform/browser/index.js
var browser_default = {
    isBrowser: true,
    classes: {
        URLSearchParams: URLSearchParams_default,
        FormData: FormData_default,
        Blob: Blob_default
    },
    protocols: [
        "http",
        "https",
        "file",
        "blob",
        "url",
        "data"
    ]
};
// ../../node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
    hasBrowserEnv: function() {
        return hasBrowserEnv;
    },
    hasStandardBrowserEnv: function() {
        return hasStandardBrowserEnv;
    },
    hasStandardBrowserWebWorkerEnv: function() {
        return hasStandardBrowserWebWorkerEnv;
    },
    navigator: function() {
        return _navigator;
    },
    origin: function() {
        return origin;
    }
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = (typeof navigator === "undefined" ? "undefined" : _type_of(navigator)) === "object" && navigator || void 0;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || [
    "ReactNative",
    "NativeScript",
    "NS"
].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = function() {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    _instanceof(self, WorkerGlobalScope) && typeof self.importScripts === "function";
}();
var origin = hasBrowserEnv && window.location.href || "http://localhost";
// ../../node_modules/axios/lib/platform/index.js
var platform_default = _object_spread({}, utils_exports, browser_default);
// ../../node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
    return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
        visitor: function visitor(value, key, path, helpers) {
            if (platform_default.isNode && utils_default.isBuffer(value)) {
                this.append(key, value.toString("base64"));
                return false;
            }
            return helpers.defaultVisitor.apply(this, arguments);
        }
    }, options));
}
// ../../node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
    return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map(function(match) {
        return match[0] === "[]" ? "" : match[1] || match[0];
    });
}
function arrayToObject(arr) {
    var obj = {};
    var keys = Object.keys(arr);
    var i;
    var len = keys.length;
    var key;
    for(i = 0; i < len; i++){
        key = keys[i];
        obj[key] = arr[key];
    }
    return obj;
}
function formDataToJSON(formData) {
    function buildPath(path, value, target, index) {
        var name = path[index++];
        if (name === "__proto__") return true;
        var isNumericKey = Number.isFinite(+name);
        var isLast = index >= path.length;
        name = !name && utils_default.isArray(target) ? target.length : name;
        if (isLast) {
            if (utils_default.hasOwnProp(target, name)) {
                target[name] = [
                    target[name],
                    value
                ];
            } else {
                target[name] = value;
            }
            return !isNumericKey;
        }
        if (!target[name] || !utils_default.isObject(target[name])) {
            target[name] = [];
        }
        var result = buildPath(path, value, target[name], index);
        if (result && utils_default.isArray(target[name])) {
            target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
    }
    if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
        var obj = {};
        utils_default.forEachEntry(formData, function(name, value) {
            buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
    }
    return null;
}
var formDataToJSON_default = formDataToJSON;
// ../../node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
    if (utils_default.isString(rawValue)) {
        try {
            (parser || JSON.parse)(rawValue);
            return utils_default.trim(rawValue);
        } catch (e) {
            if (e.name !== "SyntaxError") {
                throw e;
            }
        }
    }
    return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
    transitional: transitional_default,
    adapter: [
        "xhr",
        "http",
        "fetch"
    ],
    transformRequest: [
        function transformRequest(data, headers) {
            var contentType = headers.getContentType() || "";
            var hasJSONContentType = contentType.indexOf("application/json") > -1;
            var isObjectPayload = utils_default.isObject(data);
            if (isObjectPayload && utils_default.isHTMLForm(data)) {
                data = new FormData(data);
            }
            var isFormData2 = utils_default.isFormData(data);
            if (isFormData2) {
                return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
            }
            if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
                return data;
            }
            if (utils_default.isArrayBufferView(data)) {
                return data.buffer;
            }
            if (utils_default.isURLSearchParams(data)) {
                headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
                return data.toString();
            }
            var isFileList2;
            if (isObjectPayload) {
                if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
                    return toURLEncodedForm(data, this.formSerializer).toString();
                }
                if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
                    var _FormData = this.env && this.env.FormData;
                    return toFormData_default(isFileList2 ? {
                        "files[]": data
                    } : data, _FormData && new _FormData(), this.formSerializer);
                }
            }
            if (isObjectPayload || hasJSONContentType) {
                headers.setContentType("application/json", false);
                return stringifySafely(data);
            }
            return data;
        }
    ],
    transformResponse: [
        function transformResponse(data) {
            var transitional2 = this.transitional || defaults.transitional;
            var forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
            var JSONRequested = this.responseType === "json";
            if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
                return data;
            }
            if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
                var silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
                var strictJSONParsing = !silentJSONParsing && JSONRequested;
                try {
                    return JSON.parse(data);
                } catch (e) {
                    if (strictJSONParsing) {
                        if (e.name === "SyntaxError") {
                            throw AxiosError_default.from(e, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
                        }
                        throw e;
                    }
                }
            }
            return data;
        }
    ],
    /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */ timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: platform_default.classes.FormData,
        Blob: platform_default.classes.Blob
    },
    validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
    },
    headers: {
        common: {
            "Accept": "application/json, text/plain, */*",
            "Content-Type": void 0
        }
    }
};
utils_default.forEach([
    "delete",
    "get",
    "head",
    "post",
    "put",
    "patch"
], function(method) {
    defaults.headers[method] = {};
});
var defaults_default = defaults;
// ../../node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
]);
var parseHeaders_default = function(rawHeaders) {
    var parsed = {};
    var key;
    var val;
    var i;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
            return;
        }
        if (key === "set-cookie") {
            if (parsed[key]) {
                parsed[key].push(val);
            } else {
                parsed[key] = [
                    val
                ];
            }
        } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
    });
    return parsed;
};
// ../../node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
    if (value === false || value == null) {
        return value;
    }
    return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
    var tokens = /* @__PURE__ */ Object.create(null);
    var tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    var match;
    while(match = tokensRE.exec(str)){
        tokens[match[1]] = match[2];
    }
    return tokens;
}
var isValidHeaderName = function(str) {
    return /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
};
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
    if (utils_default.isFunction(filter2)) {
        return filter2.call(this, value, header);
    }
    if (isHeaderNameFilter) {
        value = header;
    }
    if (!utils_default.isString(value)) return;
    if (utils_default.isString(filter2)) {
        return value.indexOf(filter2) !== -1;
    }
    if (utils_default.isRegExp(filter2)) {
        return filter2.test(value);
    }
}
function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, function(w, char, str) {
        return char.toUpperCase() + str;
    });
}
function buildAccessors(obj, header) {
    var accessorName = utils_default.toCamelCase(" " + header);
    [
        "get",
        "set",
        "has"
    ].forEach(function(methodName) {
        Object.defineProperty(obj, methodName + accessorName, {
            value: function value(arg1, arg2, arg3) {
                return this[methodName].call(this, header, arg1, arg2, arg3);
            },
            configurable: true
        });
    });
}
var AxiosHeaders = /*#__PURE__*/ function() {
    "use strict";
    function AxiosHeaders(headers) {
        _class_call_check(this, AxiosHeaders);
        headers && this.set(headers);
    }
    _create_class(AxiosHeaders, [
        {
            key: "set",
            value: function set(header, valueOrRewrite, rewrite) {
                var self2 = this;
                function setHeader(_value, _header, _rewrite) {
                    var lHeader = normalizeHeader(_header);
                    if (!lHeader) {
                        throw new Error("header name must be a non-empty string");
                    }
                    var key = utils_default.findKey(self2, lHeader);
                    if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
                        self2[key || _header] = normalizeValue(_value);
                    }
                }
                var setHeaders = function(headers, _rewrite) {
                    return utils_default.forEach(headers, function(_value, _header) {
                        return setHeader(_value, _header, _rewrite);
                    });
                };
                if (utils_default.isPlainObject(header) || _instanceof(header, this.constructor)) {
                    setHeaders(header, valueOrRewrite);
                } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
                    setHeaders(parseHeaders_default(header), valueOrRewrite);
                } else if (utils_default.isHeaders(header)) {
                    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(var _iterator = header.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var _step_value = _sliced_to_array(_step.value, 2), key = _step_value[0], value = _step_value[1];
                            setHeader(value, key, rewrite);
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                } else {
                    header != null && setHeader(valueOrRewrite, header, rewrite);
                }
                return this;
            }
        },
        {
            key: "get",
            value: function get(header, parser) {
                header = normalizeHeader(header);
                if (header) {
                    var key = utils_default.findKey(this, header);
                    if (key) {
                        var value = this[key];
                        if (!parser) {
                            return value;
                        }
                        if (parser === true) {
                            return parseTokens(value);
                        }
                        if (utils_default.isFunction(parser)) {
                            return parser.call(this, value, key);
                        }
                        if (utils_default.isRegExp(parser)) {
                            return parser.exec(value);
                        }
                        throw new TypeError("parser must be boolean|regexp|function");
                    }
                }
            }
        },
        {
            key: "has",
            value: function has(header, matcher) {
                header = normalizeHeader(header);
                if (header) {
                    var key = utils_default.findKey(this, header);
                    return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
                }
                return false;
            }
        },
        {
            key: "delete",
            value: function _delete(header, matcher) {
                var self2 = this;
                var deleted = false;
                function deleteHeader(_header) {
                    _header = normalizeHeader(_header);
                    if (_header) {
                        var key = utils_default.findKey(self2, _header);
                        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
                            delete self2[key];
                            deleted = true;
                        }
                    }
                }
                if (utils_default.isArray(header)) {
                    header.forEach(deleteHeader);
                } else {
                    deleteHeader(header);
                }
                return deleted;
            }
        },
        {
            key: "clear",
            value: function clear(matcher) {
                var keys = Object.keys(this);
                var i = keys.length;
                var deleted = false;
                while(i--){
                    var key = keys[i];
                    if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
                        delete this[key];
                        deleted = true;
                    }
                }
                return deleted;
            }
        },
        {
            key: "normalize",
            value: function normalize(format) {
                var self2 = this;
                var headers = {};
                utils_default.forEach(this, function(value, header) {
                    var key = utils_default.findKey(headers, header);
                    if (key) {
                        self2[key] = normalizeValue(value);
                        delete self2[header];
                        return;
                    }
                    var normalized = format ? formatHeader(header) : String(header).trim();
                    if (normalized !== header) {
                        delete self2[header];
                    }
                    self2[normalized] = normalizeValue(value);
                    headers[normalized] = true;
                });
                return this;
            }
        },
        {
            key: "concat",
            value: function concat() {
                for(var _len = arguments.length, targets = new Array(_len), _key = 0; _key < _len; _key++){
                    targets[_key] = arguments[_key];
                }
                var _this_constructor;
                return (_this_constructor = this.constructor).concat.apply(_this_constructor, [
                    this
                ].concat(_to_consumable_array(targets)));
            }
        },
        {
            key: "toJSON",
            value: function toJSON(asStrings) {
                var obj = /* @__PURE__ */ Object.create(null);
                utils_default.forEach(this, function(value, header) {
                    value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
                });
                return obj;
            }
        },
        {
            key: Symbol.iterator,
            value: function value() {
                return Object.entries(this.toJSON())[Symbol.iterator]();
            }
        },
        {
            key: "toString",
            value: function toString() {
                return Object.entries(this.toJSON()).map(function(param) {
                    var _param = _sliced_to_array(param, 2), header = _param[0], value = _param[1];
                    return header + ": " + value;
                }).join("\n");
            }
        },
        {
            key: Symbol.toStringTag,
            get: function get() {
                return "AxiosHeaders";
            }
        }
    ], [
        {
            key: "from",
            value: function from(thing) {
                return _instanceof(thing, this) ? thing : new this(thing);
            }
        },
        {
            key: "concat",
            value: function concat(first) {
                for(var _len = arguments.length, targets = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                    targets[_key - 1] = arguments[_key];
                }
                var computed = new this(first);
                targets.forEach(function(target) {
                    return computed.set(target);
                });
                return computed;
            }
        },
        {
            key: "accessor",
            value: function accessor(header) {
                var internals = this[$internals] = this[$internals] = {
                    accessors: {}
                };
                var accessors = internals.accessors;
                var prototype3 = this.prototype;
                function defineAccessor(_header) {
                    var lHeader = normalizeHeader(_header);
                    if (!accessors[lHeader]) {
                        buildAccessors(prototype3, _header);
                        accessors[lHeader] = true;
                    }
                }
                utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
                return this;
            }
        }
    ]);
    return AxiosHeaders;
}();
AxiosHeaders.accessor([
    "Content-Type",
    "Content-Length",
    "Accept",
    "Accept-Encoding",
    "User-Agent",
    "Authorization"
]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, function(param, key) {
    var value = param.value;
    var mapped = key[0].toUpperCase() + key.slice(1);
    return {
        get: function() {
            return value;
        },
        set: function set(headerValue) {
            this[mapped] = headerValue;
        }
    };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;
// ../../node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
    var config = this || defaults_default;
    var context = response || config;
    var headers = AxiosHeaders_default.from(context.headers);
    var data = context.data;
    utils_default.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
}
// ../../node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
    return !!(value && value.__CANCEL__);
}
// ../../node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
    AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
    this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
    __CANCEL__: true
});
var CanceledError_default = CanceledError;
// ../../node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
    var validateStatus2 = response.config.validateStatus;
    if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
        resolve(response);
    } else {
        reject(new AxiosError_default("Request failed with status code " + response.status, [
            AxiosError_default.ERR_BAD_REQUEST,
            AxiosError_default.ERR_BAD_RESPONSE
        ][Math.floor(response.status / 100) - 4], response.config, response.request, response));
    }
}
// ../../node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
    var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
}
// ../../node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    var bytes = new Array(samplesCount);
    var timestamps = new Array(samplesCount);
    var head = 0;
    var tail = 0;
    var firstSampleTS;
    min = min !== void 0 ? min : 1e3;
    return function push(chunkLength) {
        var now = Date.now();
        var startedAt = timestamps[tail];
        if (!firstSampleTS) {
            firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        var i = tail;
        var bytesCount = 0;
        while(i !== head){
            bytesCount += bytes[i++];
            i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
            tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min) {
            return;
        }
        var passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
}
var speedometer_default = speedometer;
// ../../node_modules/axios/lib/helpers/throttle.js
function throttle(fn, freq) {
    var timestamp = 0;
    var threshold = 1e3 / freq;
    var lastArgs;
    var timer;
    var invoke = function(args) {
        var now = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Date.now();
        timestamp = now;
        lastArgs = null;
        if (timer) {
            clearTimeout(timer);
            timer = null;
        }
        fn.apply(null, args);
    };
    var throttled = function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        var now = Date.now();
        var passed = now - timestamp;
        if (passed >= threshold) {
            invoke(args, now);
        } else {
            lastArgs = args;
            if (!timer) {
                timer = setTimeout(function() {
                    timer = null;
                    invoke(lastArgs);
                }, threshold - passed);
            }
        }
    };
    var flush = function() {
        return lastArgs && invoke(lastArgs);
    };
    return [
        throttled,
        flush
    ];
}
var throttle_default = throttle;
// ../../node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = function(listener, isDownloadStream) {
    var freq = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3;
    var bytesNotified = 0;
    var _speedometer = speedometer_default(50, 250);
    return throttle_default(function(e) {
        var loaded = e.loaded;
        var total = e.lengthComputable ? e.total : void 0;
        var progressBytes = loaded - bytesNotified;
        var rate = _speedometer(progressBytes);
        var inRange = loaded <= total;
        bytesNotified = loaded;
        var data = _define_property({
            loaded: loaded,
            total: total,
            progress: total ? loaded / total : void 0,
            bytes: progressBytes,
            rate: rate ? rate : void 0,
            estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
            event: e,
            lengthComputable: total != null
        }, isDownloadStream ? "download" : "upload", true);
        listener(data);
    }, freq);
};
var progressEventDecorator = function(total, throttled) {
    var lengthComputable = total != null;
    return [
        function(loaded) {
            return throttled[0]({
                lengthComputable: lengthComputable,
                total: total,
                loaded: loaded
            });
        },
        throttled[1]
    ];
};
var asyncDecorator = function(fn) {
    return function() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        return utils_default.asap(function() {
            return fn.apply(void 0, _to_consumable_array(args));
        });
    };
};
// ../../node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ function(origin2, isMSIE) {
    return function(url) {
        url = new URL(url, platform_default.origin);
        return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
    };
}(new URL(platform_default.origin), platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)) : function() {
    return true;
};
// ../../node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? // Standard browser envs support document.cookie
{
    write: function write(name, value, expires, path, domain, secure) {
        var cookie = [
            name + "=" + encodeURIComponent(value)
        ];
        utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
        utils_default.isString(path) && cookie.push("path=" + path);
        utils_default.isString(domain) && cookie.push("domain=" + domain);
        secure === true && cookie.push("secure");
        document.cookie = cookie.join("; ");
    },
    read: function read(name) {
        var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove(name) {
        this.write(name, "", Date.now() - 864e5);
    }
} : // Non-standard browser env (web workers, react-native) lack needed support.
{
    write: function write() {},
    read: function read() {
        return null;
    },
    remove: function remove() {}
};
// ../../node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
// ../../node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
// ../../node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
    var isRelativeUrl = !isAbsoluteURL(requestedURL);
    if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
        return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
}
// ../../node_modules/axios/lib/core/mergeConfig.js
var headersToObject = function(thing) {
    return _instanceof(thing, AxiosHeaders_default) ? _object_spread({}, thing) : thing;
};
function mergeConfig(config1, config2) {
    config2 = config2 || {};
    var config = {};
    function getMergedValue(target, source, prop, caseless) {
        if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
            return utils_default.merge.call({
                caseless: caseless
            }, target, source);
        } else if (utils_default.isPlainObject(source)) {
            return utils_default.merge({}, source);
        } else if (utils_default.isArray(source)) {
            return source.slice();
        }
        return source;
    }
    function mergeDeepProperties(a, b, prop, caseless) {
        if (!utils_default.isUndefined(b)) {
            return getMergedValue(a, b, prop, caseless);
        } else if (!utils_default.isUndefined(a)) {
            return getMergedValue(void 0, a, prop, caseless);
        }
    }
    function valueFromConfig2(a, b) {
        if (!utils_default.isUndefined(b)) {
            return getMergedValue(void 0, b);
        }
    }
    function defaultToConfig2(a, b) {
        if (!utils_default.isUndefined(b)) {
            return getMergedValue(void 0, b);
        } else if (!utils_default.isUndefined(a)) {
            return getMergedValue(void 0, a);
        }
    }
    function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
            return getMergedValue(a, b);
        } else if (prop in config1) {
            return getMergedValue(void 0, a);
        }
    }
    var mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: function(a, b, prop) {
            return mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true);
        }
    };
    utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
        var merge2 = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge2(config1[prop], config2[prop], prop);
        utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
}
// ../../node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = function(config) {
    var newConfig = mergeConfig({}, config);
    var data = newConfig.data, withXSRFToken = newConfig.withXSRFToken, xsrfHeaderName = newConfig.xsrfHeaderName, xsrfCookieName = newConfig.xsrfCookieName, headers = newConfig.headers, auth = newConfig.auth;
    newConfig.headers = headers = AxiosHeaders_default.from(headers);
    newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
    if (auth) {
        headers.set("Authorization", "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : "")));
    }
    var contentType;
    if (utils_default.isFormData(data)) {
        if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
            headers.setContentType(void 0);
        } else if ((contentType = headers.getContentType()) !== false) {
            var _ref = _to_array(contentType ? contentType.split(";").map(function(token) {
                return token.trim();
            }).filter(Boolean) : []), type = _ref[0], tokens = _ref.slice(1);
            headers.setContentType([
                type || "multipart/form-data"
            ].concat(_to_consumable_array(tokens)).join("; "));
        }
    }
    if (platform_default.hasStandardBrowserEnv) {
        withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
        if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
            var xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
            if (xsrfValue) {
                headers.set(xsrfHeaderName, xsrfValue);
            }
        }
    }
    return newConfig;
};
// ../../node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
        var _config = resolveConfig_default(config);
        var requestData = _config.data;
        var requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
        var responseType = _config.responseType, onUploadProgress = _config.onUploadProgress, onDownloadProgress = _config.onDownloadProgress;
        var onCanceled;
        var uploadThrottled, downloadThrottled;
        var flushUpload, flushDownload;
        function done() {
            flushUpload && flushUpload();
            flushDownload && flushDownload();
            _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
            _config.signal && _config.signal.removeEventListener("abort", onCanceled);
        }
        var request = new XMLHttpRequest();
        request.open(_config.method.toUpperCase(), _config.url, true);
        request.timeout = _config.timeout;
        function onloadend() {
            if (!request) {
                return;
            }
            var responseHeaders = AxiosHeaders_default.from("getAllResponseHeaders" in request && request.getAllResponseHeaders());
            var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            var response = {
                data: responseData,
                status: request.status,
                statusText: request.statusText,
                headers: responseHeaders,
                config: config,
                request: request
            };
            settle(function _resolve(value) {
                resolve(value);
                done();
            }, function _reject(err) {
                reject(err);
                done();
            }, response);
            request = null;
        }
        if ("onloadend" in request) {
            request.onloadend = onloadend;
        } else {
            request.onreadystatechange = function handleLoad() {
                if (!request || request.readyState !== 4) {
                    return;
                }
                if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                    return;
                }
                setTimeout(onloadend);
            };
        }
        request.onabort = function handleAbort() {
            if (!request) {
                return;
            }
            reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
            request = null;
        };
        request.onerror = function handleError() {
            reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
            request = null;
        };
        request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
            var transitional2 = _config.transitional || transitional_default;
            if (_config.timeoutErrorMessage) {
                timeoutErrorMessage = _config.timeoutErrorMessage;
            }
            reject(new AxiosError_default(timeoutErrorMessage, transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED, config, request));
            request = null;
        };
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
            utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
                request.setRequestHeader(key, val);
            });
        }
        if (!utils_default.isUndefined(_config.withCredentials)) {
            request.withCredentials = !!_config.withCredentials;
        }
        if (responseType && responseType !== "json") {
            request.responseType = _config.responseType;
        }
        if (onDownloadProgress) {
            var ref;
            ref = _sliced_to_array(progressEventReducer(onDownloadProgress, true), 2), downloadThrottled = ref[0], flushDownload = ref[1], ref;
            request.addEventListener("progress", downloadThrottled);
        }
        if (onUploadProgress && request.upload) {
            var ref1;
            ref1 = _sliced_to_array(progressEventReducer(onUploadProgress), 2), uploadThrottled = ref1[0], flushUpload = ref1[1], ref1;
            request.upload.addEventListener("progress", uploadThrottled);
            request.upload.addEventListener("loadend", flushUpload);
        }
        if (_config.cancelToken || _config.signal) {
            onCanceled = function(cancel) {
                if (!request) {
                    return;
                }
                reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
                request.abort();
                request = null;
            };
            _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
            if (_config.signal) {
                _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
            }
        }
        var protocol = parseProtocol(_config.url);
        if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
            reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
            return;
        }
        request.send(requestData || null);
    });
};
// ../../node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = function(signals, timeout) {
    var length = (signals = signals ? signals.filter(Boolean) : []).length;
    if (timeout || length) {
        var controller = new AbortController();
        var aborted;
        var onabort = function onabort(reason) {
            if (!aborted) {
                aborted = true;
                unsubscribe();
                var err = _instanceof(reason, Error) ? reason : this.reason;
                controller.abort(_instanceof(err, AxiosError_default) ? err : new CanceledError_default(_instanceof(err, Error) ? err.message : err));
            }
        };
        var timer = timeout && setTimeout(function() {
            timer = null;
            onabort(new AxiosError_default("timeout ".concat(timeout, " of ms exceeded"), AxiosError_default.ETIMEDOUT));
        }, timeout);
        var unsubscribe = function() {
            if (signals) {
                timer && clearTimeout(timer);
                timer = null;
                signals.forEach(function(signal2) {
                    signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
                });
                signals = null;
            }
        };
        signals.forEach(function(signal2) {
            return signal2.addEventListener("abort", onabort);
        });
        var signal = controller.signal;
        signal.unsubscribe = function() {
            return utils_default.asap(unsubscribe);
        };
        return signal;
    }
};
var composeSignals_default = composeSignals;
// ../../node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function streamChunk(chunk, chunkSize) {
    var len, pos, end;
    return _ts_generator(this, function(_state) {
        switch(_state.label){
            case 0:
                len = chunk.byteLength;
                if (!(!chunkSize || len < chunkSize)) return [
                    3,
                    2
                ];
                return [
                    4,
                    chunk
                ];
            case 1:
                _state.sent();
                return [
                    2
                ];
            case 2:
                pos = 0;
                _state.label = 3;
            case 3:
                if (!(pos < len)) return [
                    3,
                    5
                ];
                end = pos + chunkSize;
                return [
                    4,
                    chunk.slice(pos, end)
                ];
            case 4:
                _state.sent();
                pos = end;
                return [
                    3,
                    3
                ];
            case 5:
                return [
                    2
                ];
        }
    });
};
var readBytes = /*#__PURE__*/ function() {
    var _ref = _wrap_async_generator(function(iterable, chunkSize) {
        var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk, err;
        return _ts_generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    _iteratorAbruptCompletion = false, _didIteratorError = false;
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        7,
                        8,
                        13
                    ]);
                    _iterator = _async_iterator(readStream(iterable));
                    _state.label = 2;
                case 2:
                    return [
                        4,
                        _await_async_generator(_iterator.next())
                    ];
                case 3:
                    if (!(_iteratorAbruptCompletion = !(_step = _state.sent()).done)) return [
                        3,
                        6
                    ];
                    _value = _step.value;
                    chunk = _value;
                    return [
                        5,
                        _ts_values(_async_generator_delegate(_async_iterator(streamChunk(chunk, chunkSize)), _await_async_generator))
                    ];
                case 4:
                    _state.sent();
                    _state.label = 5;
                case 5:
                    _iteratorAbruptCompletion = false;
                    return [
                        3,
                        2
                    ];
                case 6:
                    return [
                        3,
                        13
                    ];
                case 7:
                    err = _state.sent();
                    _didIteratorError = true;
                    _iteratorError = err;
                    return [
                        3,
                        13
                    ];
                case 8:
                    _state.trys.push([
                        8,
                        ,
                        11,
                        12
                    ]);
                    if (!(_iteratorAbruptCompletion && _iterator.return != null)) return [
                        3,
                        10
                    ];
                    return [
                        4,
                        _await_async_generator(_iterator.return())
                    ];
                case 9:
                    _state.sent();
                    _state.label = 10;
                case 10:
                    return [
                        3,
                        12
                    ];
                case 11:
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                    return [
                        7
                    ];
                case 12:
                    return [
                        7
                    ];
                case 13:
                    return [
                        2
                    ];
            }
        });
    });
    return function readBytes(iterable, chunkSize) {
        return _ref.apply(this, arguments);
    };
}();
var readStream = /*#__PURE__*/ function() {
    var _ref = _wrap_async_generator(function(stream) {
        var reader, _ref, done, value;
        return _ts_generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    if (!stream[Symbol.asyncIterator]) return [
                        3,
                        2
                    ];
                    return [
                        5,
                        _ts_values(_async_generator_delegate(_async_iterator(stream), _await_async_generator))
                    ];
                case 1:
                    _state.sent();
                    return [
                        2
                    ];
                case 2:
                    reader = stream.getReader();
                    _state.label = 3;
                case 3:
                    _state.trys.push([
                        3,
                        ,
                        9,
                        11
                    ]);
                    _state.label = 4;
                case 4:
                    return [
                        4,
                        _await_async_generator(reader.read())
                    ];
                case 5:
                    _ref = _state.sent(), done = _ref.done, value = _ref.value;
                    if (done) {
                        return [
                            3,
                            8
                        ];
                    }
                    return [
                        4,
                        value
                    ];
                case 6:
                    _state.sent();
                    _state.label = 7;
                case 7:
                    return [
                        3,
                        4
                    ];
                case 8:
                    return [
                        3,
                        11
                    ];
                case 9:
                    return [
                        4,
                        _await_async_generator(reader.cancel())
                    ];
                case 10:
                    _state.sent();
                    return [
                        7
                    ];
                case 11:
                    return [
                        2
                    ];
            }
        });
    });
    return function readStream(stream) {
        return _ref.apply(this, arguments);
    };
}();
var trackStream = function(stream, chunkSize, onProgress, onFinish) {
    var iterator = readBytes(stream, chunkSize);
    var bytes = 0;
    var done;
    var _onFinish = function(e) {
        if (!done) {
            done = true;
            onFinish && onFinish(e);
        }
    };
    return new ReadableStream({
        pull: function pull(controller) {
            return _async_to_generator(function() {
                var _ref, done2, value, len, loadedBytes, err;
                return _ts_generator(this, function(_state) {
                    switch(_state.label){
                        case 0:
                            _state.trys.push([
                                0,
                                2,
                                ,
                                3
                            ]);
                            return [
                                4,
                                iterator.next()
                            ];
                        case 1:
                            _ref = _state.sent(), done2 = _ref.done, value = _ref.value;
                            if (done2) {
                                _onFinish();
                                controller.close();
                                return [
                                    2
                                ];
                            }
                            len = value.byteLength;
                            if (onProgress) {
                                loadedBytes = bytes += len;
                                onProgress(loadedBytes);
                            }
                            controller.enqueue(new Uint8Array(value));
                            return [
                                3,
                                3
                            ];
                        case 2:
                            err = _state.sent();
                            _onFinish(err);
                            throw err;
                        case 3:
                            return [
                                2
                            ];
                    }
                });
            })();
        },
        cancel: function cancel(reason) {
            _onFinish(reason);
            return iterator.return();
        }
    }, {
        highWaterMark: 2
    });
};
// ../../node_modules/axios/lib/adapters/fetch.js
var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ function(encoder) {
    return function(str) {
        return encoder.encode(str);
    };
}(new TextEncoder()) : /*#__PURE__*/ function() {
    var _ref = _async_to_generator(function(str) {
        var _;
        return _ts_generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    _ = Uint8Array.bind;
                    return [
                        4,
                        new Response(str).arrayBuffer()
                    ];
                case 1:
                    return [
                        2,
                        new (_.apply(Uint8Array, [
                            void 0,
                            _state.sent()
                        ]))
                    ];
            }
        });
    });
    return function(str) {
        return _ref.apply(this, arguments);
    };
}());
var test = function(fn) {
    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
        args[_key - 1] = arguments[_key];
    }
    try {
        return !!fn.apply(void 0, _to_consumable_array(args));
    } catch (e) {
        return false;
    }
};
var supportsRequestStream = isReadableStreamSupported && test(function() {
    var duplexAccessed = false;
    var hasContentType = new Request(platform_default.origin, {
        body: new ReadableStream(),
        method: "POST",
        get duplex () {
            duplexAccessed = true;
            return "half";
        }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
});
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && test(function() {
    return utils_default.isReadableStream(new Response("").body);
});
var resolvers = {
    stream: supportsResponseStream && function(res) {
        return res.body;
    }
};
isFetchSupported && function(res) {
    [
        "text",
        "arrayBuffer",
        "blob",
        "formData",
        "stream"
    ].forEach(function(type) {
        !resolvers[type] && (resolvers[type] = utils_default.isFunction(res[type]) ? function(res2) {
            return res2[type]();
        } : function(_, config) {
            throw new AxiosError_default("Response type '".concat(type, "' is not supported"), AxiosError_default.ERR_NOT_SUPPORT, config);
        });
    });
}(new Response());
var getBodyLength = /*#__PURE__*/ function() {
    var _ref = _async_to_generator(function(body) {
        var _request;
        return _ts_generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    if (body == null) {
                        return [
                            2,
                            0
                        ];
                    }
                    if (utils_default.isBlob(body)) {
                        return [
                            2,
                            body.size
                        ];
                    }
                    if (!utils_default.isSpecCompliantForm(body)) return [
                        3,
                        2
                    ];
                    _request = new Request(platform_default.origin, {
                        method: "POST",
                        body: body
                    });
                    return [
                        4,
                        _request.arrayBuffer()
                    ];
                case 1:
                    return [
                        2,
                        _state.sent().byteLength
                    ];
                case 2:
                    if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
                        return [
                            2,
                            body.byteLength
                        ];
                    }
                    if (utils_default.isURLSearchParams(body)) {
                        body = body + "";
                    }
                    if (!utils_default.isString(body)) return [
                        3,
                        4
                    ];
                    return [
                        4,
                        encodeText(body)
                    ];
                case 3:
                    return [
                        2,
                        _state.sent().byteLength
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    });
    return function getBodyLength(body) {
        return _ref.apply(this, arguments);
    };
}();
var resolveBodyLength = /*#__PURE__*/ function() {
    var _ref = _async_to_generator(function(headers, body) {
        var length;
        return _ts_generator(this, function(_state) {
            length = utils_default.toFiniteNumber(headers.getContentLength());
            return [
                2,
                length == null ? getBodyLength(body) : length
            ];
        });
    });
    return function resolveBodyLength(headers, body) {
        return _ref.apply(this, arguments);
    };
}();
var fetch_default = isFetchSupported && /*#__PURE__*/ function() {
    var _ref = _async_to_generator(function(config) {
        var _resolveConfig_default, url, method, data, signal, cancelToken, timeout, onDownloadProgress, onUploadProgress, responseType, headers, _resolveConfig_default_withCredentials, withCredentials, fetchOptions, composedSignal, request, unsubscribe, requestContentLength, _tmp, _request, contentTypeHeader, _progressEventDecorator, onProgress, flush, isCredentialsSupported, response, isStreamResponse, options, responseContentLength, _ref, onProgress1, flush1, responseData, err;
        return _ts_generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    _resolveConfig_default = resolveConfig_default(config), url = _resolveConfig_default.url, method = _resolveConfig_default.method, data = _resolveConfig_default.data, signal = _resolveConfig_default.signal, cancelToken = _resolveConfig_default.cancelToken, timeout = _resolveConfig_default.timeout, onDownloadProgress = _resolveConfig_default.onDownloadProgress, onUploadProgress = _resolveConfig_default.onUploadProgress, responseType = _resolveConfig_default.responseType, headers = _resolveConfig_default.headers, _resolveConfig_default_withCredentials = _resolveConfig_default.withCredentials, withCredentials = _resolveConfig_default_withCredentials === void 0 ? "same-origin" : _resolveConfig_default_withCredentials, fetchOptions = _resolveConfig_default.fetchOptions;
                    responseType = responseType ? (responseType + "").toLowerCase() : "text";
                    composedSignal = composeSignals_default([
                        signal,
                        cancelToken && cancelToken.toAbortSignal()
                    ], timeout);
                    unsubscribe = composedSignal && composedSignal.unsubscribe && function() {
                        composedSignal.unsubscribe();
                    };
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        7,
                        ,
                        8
                    ]);
                    _tmp = onUploadProgress && supportsRequestStream && method !== "get" && method !== "head";
                    if (!_tmp) return [
                        3,
                        3
                    ];
                    return [
                        4,
                        resolveBodyLength(headers, data)
                    ];
                case 2:
                    _tmp = (requestContentLength = _state.sent()) !== 0;
                    _state.label = 3;
                case 3:
                    if (_tmp) {
                        _request = new Request(url, {
                            method: "POST",
                            body: data,
                            duplex: "half"
                        });
                        ;
                        if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
                            headers.setContentType(contentTypeHeader);
                        }
                        if (_request.body) {
                            _progressEventDecorator = _sliced_to_array(progressEventDecorator(requestContentLength, progressEventReducer(asyncDecorator(onUploadProgress))), 2), onProgress = _progressEventDecorator[0], flush = _progressEventDecorator[1];
                            data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
                        }
                    }
                    if (!utils_default.isString(withCredentials)) {
                        withCredentials = withCredentials ? "include" : "omit";
                    }
                    isCredentialsSupported = "credentials" in Request.prototype;
                    request = new Request(url, _object_spread_props(_object_spread({}, fetchOptions), {
                        signal: composedSignal,
                        method: method.toUpperCase(),
                        headers: headers.normalize().toJSON(),
                        body: data,
                        duplex: "half",
                        credentials: isCredentialsSupported ? withCredentials : void 0
                    }));
                    return [
                        4,
                        fetch(request)
                    ];
                case 4:
                    response = _state.sent();
                    isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
                    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
                        options = {};
                        [
                            "status",
                            "statusText",
                            "headers"
                        ].forEach(function(prop) {
                            options[prop] = response[prop];
                        });
                        responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
                        _ref = _sliced_to_array(onDownloadProgress && progressEventDecorator(responseContentLength, progressEventReducer(asyncDecorator(onDownloadProgress), true)) || [], 2), onProgress1 = _ref[0], flush1 = _ref[1];
                        response = new Response(trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress1, function() {
                            flush1 && flush1();
                            unsubscribe && unsubscribe();
                        }), options);
                    }
                    responseType = responseType || "text";
                    return [
                        4,
                        resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config)
                    ];
                case 5:
                    responseData = _state.sent();
                    !isStreamResponse && unsubscribe && unsubscribe();
                    return [
                        4,
                        new Promise(function(resolve, reject) {
                            settle(resolve, reject, {
                                data: responseData,
                                headers: AxiosHeaders_default.from(response.headers),
                                status: response.status,
                                statusText: response.statusText,
                                config: config,
                                request: request
                            });
                        })
                    ];
                case 6:
                    return [
                        2,
                        _state.sent()
                    ];
                case 7:
                    err = _state.sent();
                    unsubscribe && unsubscribe();
                    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
                        throw Object.assign(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request), {
                            cause: err.cause || err
                        });
                    }
                    throw AxiosError_default.from(err, err && err.code, config, request);
                case 8:
                    return [
                        2
                    ];
            }
        });
    });
    return function(config) {
        return _ref.apply(this, arguments);
    };
}();
// ../../node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
    http: null_default,
    xhr: xhr_default,
    fetch: fetch_default
};
utils_default.forEach(knownAdapters, function(fn, value) {
    if (fn) {
        try {
            Object.defineProperty(fn, "name", {
                value: value
            });
        } catch (e) {}
        Object.defineProperty(fn, "adapterName", {
            value: value
        });
    }
});
var renderReason = function(reason) {
    return "- ".concat(reason);
};
var isResolvedHandle = function(adapter) {
    return utils_default.isFunction(adapter) || adapter === null || adapter === false;
};
var adapters_default = {
    getAdapter: function(adapters) {
        adapters = utils_default.isArray(adapters) ? adapters : [
            adapters
        ];
        var length = adapters.length;
        var nameOrAdapter;
        var adapter;
        var rejectedReasons = {};
        for(var i = 0; i < length; i++){
            nameOrAdapter = adapters[i];
            var id = void 0;
            adapter = nameOrAdapter;
            if (!isResolvedHandle(nameOrAdapter)) {
                adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
                if (adapter === void 0) {
                    throw new AxiosError_default("Unknown adapter '".concat(id, "'"));
                }
            }
            if (adapter) {
                break;
            }
            rejectedReasons[id || "#" + i] = adapter;
        }
        if (!adapter) {
            var reasons = Object.entries(rejectedReasons).map(function(param) {
                var _param = _sliced_to_array(param, 2), id = _param[0], state = _param[1];
                return "adapter ".concat(id, " ") + (state === false ? "is not supported by the environment" : "is not available in the build");
            });
            var s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
            throw new AxiosError_default("There is no suitable adapter to dispatch the request " + s, "ERR_NOT_SUPPORT");
        }
        return adapter;
    },
    adapters: knownAdapters
};
// ../../node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
        throw new CanceledError_default(null, config);
    }
}
function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = AxiosHeaders_default.from(config.headers);
    config.data = transformData.call(config, config.transformRequest);
    if ([
        "post",
        "put",
        "patch"
    ].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    var adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
    return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(config, config.transformResponse, response);
        response.headers = AxiosHeaders_default.from(response.headers);
        return response;
    }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
            throwIfCancellationRequested(config);
            if (reason && reason.response) {
                reason.response.data = transformData.call(config, config.transformResponse, reason.response);
                reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
            }
        }
        return Promise.reject(reason);
    });
}
// ../../node_modules/axios/lib/env/data.js
var VERSION = "1.8.4";
// ../../node_modules/axios/lib/helpers/validator.js
var validators = {};
[
    "object",
    "boolean",
    "number",
    "function",
    "string",
    "symbol"
].forEach(function(type, i) {
    validators[type] = function validator(thing) {
        return (typeof thing === "undefined" ? "undefined" : _type_of(thing)) === type || "a" + (i < 1 ? "n " : " ") + type;
    };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
    function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return function(value, opt, opts) {
        if (validator === false) {
            throw new AxiosError_default(formatMessage(opt, " has been removed" + (version ? " in " + version : "")), AxiosError_default.ERR_DEPRECATED);
        }
        if (version && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
        }
        return validator ? validator(value, opt, opts) : true;
    };
};
validators.spelling = function spelling(correctSpelling) {
    return function(value, opt) {
        console.warn("".concat(opt, " is likely a misspelling of ").concat(correctSpelling));
        return true;
    };
};
function assertOptions(options, schema, allowUnknown) {
    if ((typeof options === "undefined" ? "undefined" : _type_of(options)) !== "object") {
        throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
    }
    var keys = Object.keys(options);
    var i = keys.length;
    while(i-- > 0){
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
            var value = options[opt];
            var result = value === void 0 || validator(value, opt, options);
            if (result !== true) {
                throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
            }
            continue;
        }
        if (allowUnknown !== true) {
            throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
        }
    }
}
var validator_default = {
    assertOptions: assertOptions,
    validators: validators
};
// ../../node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = /*#__PURE__*/ function() {
    "use strict";
    function Axios(instanceConfig) {
        _class_call_check(this, Axios);
        this.defaults = instanceConfig;
        this.interceptors = {
            request: new InterceptorManager_default(),
            response: new InterceptorManager_default()
        };
    }
    _create_class(Axios, [
        {
            key: "request",
            value: /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */ function request(configOrUrl, config) {
                var _this = this;
                return _async_to_generator(function() {
                    var err, dummy, stack;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    2,
                                    ,
                                    3
                                ]);
                                return [
                                    4,
                                    _this._request(configOrUrl, config)
                                ];
                            case 1:
                                return [
                                    2,
                                    _state.sent()
                                ];
                            case 2:
                                err = _state.sent();
                                if (_instanceof(err, Error)) {
                                    dummy = {};
                                    Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
                                    stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
                                    try {
                                        if (!err.stack) {
                                            err.stack = stack;
                                        } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
                                            err.stack += "\n" + stack;
                                        }
                                    } catch (e) {}
                                }
                                throw err;
                            case 3:
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        },
        {
            key: "_request",
            value: function _request(configOrUrl, config) {
                if (typeof configOrUrl === "string") {
                    config = config || {};
                    config.url = configOrUrl;
                } else {
                    config = configOrUrl || {};
                }
                config = mergeConfig(this.defaults, config);
                var transitional2 = config.transitional, paramsSerializer = config.paramsSerializer, headers = config.headers;
                if (transitional2 !== void 0) {
                    validator_default.assertOptions(transitional2, {
                        silentJSONParsing: validators2.transitional(validators2.boolean),
                        forcedJSONParsing: validators2.transitional(validators2.boolean),
                        clarifyTimeoutError: validators2.transitional(validators2.boolean)
                    }, false);
                }
                if (paramsSerializer != null) {
                    if (utils_default.isFunction(paramsSerializer)) {
                        config.paramsSerializer = {
                            serialize: paramsSerializer
                        };
                    } else {
                        validator_default.assertOptions(paramsSerializer, {
                            encode: validators2.function,
                            serialize: validators2.function
                        }, true);
                    }
                }
                if (config.allowAbsoluteUrls !== void 0) {} else if (this.defaults.allowAbsoluteUrls !== void 0) {
                    config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
                } else {
                    config.allowAbsoluteUrls = true;
                }
                validator_default.assertOptions(config, {
                    baseUrl: validators2.spelling("baseURL"),
                    withXsrfToken: validators2.spelling("withXSRFToken")
                }, true);
                config.method = (config.method || this.defaults.method || "get").toLowerCase();
                var contextHeaders = headers && utils_default.merge(headers.common, headers[config.method]);
                headers && utils_default.forEach([
                    "delete",
                    "get",
                    "head",
                    "post",
                    "put",
                    "patch",
                    "common"
                ], function(method) {
                    delete headers[method];
                });
                config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
                var requestInterceptorChain = [];
                var synchronousRequestInterceptors = true;
                this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
                    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
                        return;
                    }
                    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
                    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
                });
                var responseInterceptorChain = [];
                this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
                    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
                });
                var promise;
                var i = 0;
                var len;
                if (!synchronousRequestInterceptors) {
                    var chain = [
                        dispatchRequest.bind(this),
                        void 0
                    ];
                    chain.unshift.apply(chain, requestInterceptorChain);
                    chain.push.apply(chain, responseInterceptorChain);
                    len = chain.length;
                    promise = Promise.resolve(config);
                    while(i < len){
                        promise = promise.then(chain[i++], chain[i++]);
                    }
                    return promise;
                }
                len = requestInterceptorChain.length;
                var newConfig = config;
                i = 0;
                while(i < len){
                    var onFulfilled = requestInterceptorChain[i++];
                    var onRejected = requestInterceptorChain[i++];
                    try {
                        newConfig = onFulfilled(newConfig);
                    } catch (error) {
                        onRejected.call(this, error);
                        break;
                    }
                }
                try {
                    promise = dispatchRequest.call(this, newConfig);
                } catch (error) {
                    return Promise.reject(error);
                }
                i = 0;
                len = responseInterceptorChain.length;
                while(i < len){
                    promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
                }
                return promise;
            }
        },
        {
            key: "getUri",
            value: function getUri(config) {
                config = mergeConfig(this.defaults, config);
                var fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
                return buildURL(fullPath, config.params, config.paramsSerializer);
            }
        }
    ]);
    return Axios;
}();
utils_default.forEach([
    "delete",
    "get",
    "head",
    "options"
], function forEachMethodNoData(method) {
    Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
            method: method,
            url: url,
            data: (config || {}).data
        }));
    };
});
utils_default.forEach([
    "post",
    "put",
    "patch"
], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
            return this.request(mergeConfig(config || {}, {
                method: method,
                headers: isForm ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: url,
                data: data
            }));
        };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;
// ../../node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = /*#__PURE__*/ function() {
    "use strict";
    function _CancelToken(executor) {
        _class_call_check(this, _CancelToken);
        if (typeof executor !== "function") {
            throw new TypeError("executor must be a function.");
        }
        var resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
            resolvePromise = resolve;
        });
        var token = this;
        this.promise.then(function(cancel) {
            if (!token._listeners) return;
            var i = token._listeners.length;
            while(i-- > 0){
                token._listeners[i](cancel);
            }
            token._listeners = null;
        });
        this.promise.then = function(onfulfilled) {
            var _resolve;
            var promise = new Promise(function(resolve) {
                token.subscribe(resolve);
                _resolve = resolve;
            }).then(onfulfilled);
            promise.cancel = function reject() {
                token.unsubscribe(_resolve);
            };
            return promise;
        };
        executor(function cancel(message, config, request) {
            if (token.reason) {
                return;
            }
            token.reason = new CanceledError_default(message, config, request);
            resolvePromise(token.reason);
        });
    }
    _create_class(_CancelToken, [
        {
            /**
   * Throws a `CanceledError` if cancellation has been requested.
   */ key: "throwIfRequested",
            value: function throwIfRequested() {
                if (this.reason) {
                    throw this.reason;
                }
            }
        },
        {
            /**
   * Subscribe to the cancel signal
   */ key: "subscribe",
            value: function subscribe(listener) {
                if (this.reason) {
                    listener(this.reason);
                    return;
                }
                if (this._listeners) {
                    this._listeners.push(listener);
                } else {
                    this._listeners = [
                        listener
                    ];
                }
            }
        },
        {
            /**
   * Unsubscribe from the cancel signal
   */ key: "unsubscribe",
            value: function unsubscribe(listener) {
                if (!this._listeners) {
                    return;
                }
                var index = this._listeners.indexOf(listener);
                if (index !== -1) {
                    this._listeners.splice(index, 1);
                }
            }
        },
        {
            key: "toAbortSignal",
            value: function toAbortSignal() {
                var _this = this;
                var controller = new AbortController();
                var abort = function(err) {
                    controller.abort(err);
                };
                this.subscribe(abort);
                controller.signal.unsubscribe = function() {
                    return _this.unsubscribe(abort);
                };
                return controller.signal;
            }
        }
    ], [
        {
            key: "source",
            value: /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */ function source() {
                var cancel;
                var token = new _CancelToken(function executor(c) {
                    cancel = c;
                });
                return {
                    token: token,
                    cancel: cancel
                };
            }
        }
    ]);
    return _CancelToken;
}();
var CancelToken_default = CancelToken;
// ../../node_modules/axios/lib/helpers/spread.js
function spread(callback) {
    return function wrap(arr) {
        return callback.apply(null, arr);
    };
}
// ../../node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
    return utils_default.isObject(payload) && payload.isAxiosError === true;
}
// ../../node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(function(param) {
    var _param = _sliced_to_array(param, 2), key = _param[0], value = _param[1];
    HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;
// ../../node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
    var context = new Axios_default(defaultConfig);
    var instance = bind(Axios_default.prototype.request, context);
    utils_default.extend(instance, Axios_default.prototype, context, {
        allOwnKeys: true
    });
    utils_default.extend(instance, context, null, {
        allOwnKeys: true
    });
    instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };
    return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
    return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = function(thing) {
    return formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
};
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;
// ../../node_modules/axios/index.js
var Axios2 = axios_default.Axios, AxiosError2 = axios_default.AxiosError, CanceledError2 = axios_default.CanceledError, isCancel2 = axios_default.isCancel, CancelToken2 = axios_default.CancelToken, VERSION2 = axios_default.VERSION, all2 = axios_default.all, Cancel = axios_default.Cancel, isAxiosError2 = axios_default.isAxiosError, spread2 = axios_default.spread, toFormData2 = axios_default.toFormData, AxiosHeaders2 = axios_default.AxiosHeaders, HttpStatusCode2 = axios_default.HttpStatusCode, formToJSON = axios_default.formToJSON, getAdapter = axios_default.getAdapter, mergeConfig2 = axios_default.mergeConfig;
// src/providers/common.ts
var parseHttpError = function(error) {
    if (!axios_default.isAxiosError(error)) {
        return JSON.stringify(error);
    }
    if (error.response) {
        return JSON.stringify({
            data: error.response.data,
            headers: error.response.headers,
            status: error.response.status
        });
    }
    if (error.request && !_instanceof(error.request, XMLHttpRequest)) {
        return JSON.stringify(error.request);
    }
    return JSON.stringify({
        code: error.code,
        message: error.message
    });
};
// src/providers/blockstream.ts
var BlockstreamProvider = /*#__PURE__*/ function() {
    "use strict";
    function BlockstreamProvider() {
        var network = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "mainnet";
        _class_call_check(this, BlockstreamProvider);
        var baseURL = network === "testnet" ? "https://blockstream.info/testnet/api" : "https://blockstream.info/api";
        this._axiosInstance = axios_default.create({
            baseURL: baseURL
        });
    }
    _create_class(BlockstreamProvider, [
        {
            key: "fetchAddress",
            value: /**
   * Get information about an address.
   * @param address - The address.
   * @returns AddressInfo
   */ function fetchAddress(address) {
                var _this = this;
                return _async_to_generator(function() {
                    var _ref, data, status, error;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    2,
                                    ,
                                    3
                                ]);
                                return [
                                    4,
                                    _this._axiosInstance.get("/address/".concat(address))
                                ];
                            case 1:
                                _ref = _state.sent(), data = _ref.data, status = _ref.status;
                                if (status === 200) return [
                                    2,
                                    data
                                ];
                                throw parseHttpError(data);
                            case 2:
                                error = _state.sent();
                                throw parseHttpError(error);
                            case 3:
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        },
        {
            key: "fetchAddressTransactions",
            value: /**
   * Get transaction history for the specified address, sorted with newest first.
   * Returns up to 50 mempool transactions plus the first 25 confirmed transactions. You can request more confirmed transactions using `last_seen_txid`.
   * @param address - The address.
   * @param last_seen_txid - The last seen transaction ID (optional).
   * @returns TransactionsInfo[]
   */ function fetchAddressTransactions(address, last_seen_txid) {
                var _this = this;
                return _async_to_generator(function() {
                    var url, _ref, data, status, error;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    2,
                                    ,
                                    3
                                ]);
                                url = last_seen_txid ? "/address/".concat(address, "/txs/chain/").concat(last_seen_txid) : "/address/".concat(address, "/txs");
                                return [
                                    4,
                                    _this._axiosInstance.get(url)
                                ];
                            case 1:
                                _ref = _state.sent(), data = _ref.data, status = _ref.status;
                                if (status === 200) return [
                                    2,
                                    data
                                ];
                                throw parseHttpError(data);
                            case 2:
                                error = _state.sent();
                                throw parseHttpError(error);
                            case 3:
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        },
        {
            key: "fetchAddressUTxOs",
            value: /**
   * Get the list of unspent transaction outputs associated with the address.
   * @param address - The address.
   * @returns UTxO[]
   */ function fetchAddressUTxOs(address) {
                var _this = this;
                return _async_to_generator(function() {
                    var _ref, data, status, error;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    2,
                                    ,
                                    3
                                ]);
                                return [
                                    4,
                                    _this._axiosInstance.get("/address/".concat(address, "/utxo"))
                                ];
                            case 1:
                                _ref = _state.sent(), data = _ref.data, status = _ref.status;
                                if (status === 200) return [
                                    2,
                                    data
                                ];
                                throw parseHttpError(data);
                            case 2:
                                error = _state.sent();
                                throw parseHttpError(error);
                            case 3:
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        },
        {
            key: "fetchScript",
            value: /**
   * Get information about a scripthash.
   * @param hash - The hash of the script.
   * @returns ScriptInfo
   */ function fetchScript(hash) {
                var _this = this;
                return _async_to_generator(function() {
                    var _ref, data, status, error;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    2,
                                    ,
                                    3
                                ]);
                                return [
                                    4,
                                    _this._axiosInstance.get("/scripthash/".concat(hash))
                                ];
                            case 1:
                                _ref = _state.sent(), data = _ref.data, status = _ref.status;
                                if (status === 200) return [
                                    2,
                                    data
                                ];
                                throw parseHttpError(data);
                            case 2:
                                error = _state.sent();
                                throw parseHttpError(error);
                            case 3:
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        },
        {
            key: "fetchScriptTransactions",
            value: /**
   * Get transaction history for the specified scripthash, sorted with newest first.
   * Returns up to 50 mempool transactions plus the first 25 confirmed transactions. You can request more confirmed transactions using `last_seen_txid`.
   * @param hash - The hash of the script.
   * @param last_seen_txid - The last seen transaction ID (optional).
   * @returns TransactionsInfo[]
   */ function fetchScriptTransactions(hash, last_seen_txid) {
                var _this = this;
                return _async_to_generator(function() {
                    var url, _ref, data, status, error;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    2,
                                    ,
                                    3
                                ]);
                                url = last_seen_txid ? "/scripthash/".concat(hash, "/txs/chain/").concat(last_seen_txid) : "/scripthash/".concat(hash, "/txs");
                                return [
                                    4,
                                    _this._axiosInstance.get(url)
                                ];
                            case 1:
                                _ref = _state.sent(), data = _ref.data, status = _ref.status;
                                if (status === 200) return [
                                    2,
                                    data
                                ];
                                throw parseHttpError(data);
                            case 2:
                                error = _state.sent();
                                throw parseHttpError(error);
                            case 3:
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        },
        {
            key: "fetchScriptUTxOs",
            value: /**
   * Get the list of unspent transaction outputs associated with the scripthash.
   * @param hash - The hash of the script.
   * @returns UTxO[]
   */ function fetchScriptUTxOs(hash) {
                var _this = this;
                return _async_to_generator(function() {
                    var _ref, data, status, error;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    2,
                                    ,
                                    3
                                ]);
                                return [
                                    4,
                                    _this._axiosInstance.get("/scripthash/".concat(hash, "/utxo"))
                                ];
                            case 1:
                                _ref = _state.sent(), data = _ref.data, status = _ref.status;
                                if (status === 200) return [
                                    2,
                                    data
                                ];
                                throw parseHttpError(data);
                            case 2:
                                error = _state.sent();
                                throw parseHttpError(error);
                            case 3:
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        },
        {
            key: "fetchTransactionStatus",
            value: /**
   * Fetches the status of a transaction
   * @param txid - The transaction ID.
   * @returns TransactionsStatus
   */ function fetchTransactionStatus(txid) {
                var _this = this;
                return _async_to_generator(function() {
                    var _ref, data, status, error;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    2,
                                    ,
                                    3
                                ]);
                                return [
                                    4,
                                    _this._axiosInstance.get("/tx/".concat(txid, "/status"))
                                ];
                            case 1:
                                _ref = _state.sent(), data = _ref.data, status = _ref.status;
                                if (status === 200) return [
                                    2,
                                    data
                                ];
                                throw parseHttpError(data);
                            case 2:
                                error = _state.sent();
                                throw parseHttpError(error);
                            case 3:
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        },
        {
            key: "submitTx",
            value: /**
   * Broadcast a raw transaction to the network.
   * The transaction should be provided as hex in the request body. The txid will be returned on success.
   * @param tx - The transaction in hex format.
   * @returns The transaction ID.
   */ function submitTx(tx) {
                var _this = this;
                return _async_to_generator(function() {
                    var _ref, data, status, error;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    2,
                                    ,
                                    3
                                ]);
                                return [
                                    4,
                                    _this._axiosInstance.post("/tx", tx, {
                                        headers: {
                                            "Content-Type": "text/plain"
                                        }
                                    })
                                ];
                            case 1:
                                _ref = _state.sent(), data = _ref.data, status = _ref.status;
                                if (status === 200) return [
                                    2,
                                    data
                                ];
                                throw parseHttpError(data);
                            case 2:
                                error = _state.sent();
                                throw parseHttpError(error);
                            case 3:
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        }
    ]);
    return BlockstreamProvider;
}();
// src/wallets/browser/index.ts
var BrowserWallet = /*#__PURE__*/ function() {
    "use strict";
    function _BrowserWallet(purposes) {
        _class_call_check(this, _BrowserWallet);
        this._purposes = purposes;
    }
    _create_class(_BrowserWallet, [
        {
            key: "getAddresses",
            value: function getAddresses() {
                var _this = this;
                return _async_to_generator(function() {
                    var response, err;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    2,
                                    ,
                                    3
                                ]);
                                return [
                                    4,
                                    _this.request("getAddresses", {
                                        purposes: _this._purposes
                                    })
                                ];
                            case 1:
                                response = _state.sent();
                                if (response.status === "success") {
                                    return [
                                        2,
                                        response.result.addresses
                                    ];
                                }
                                return [
                                    3,
                                    3
                                ];
                            case 2:
                                err = _state.sent();
                                console.error("getAccounts ~ error:", err);
                                return [
                                    3,
                                    3
                                ];
                            case 3:
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        },
        {
            key: "getChangeAddress",
            value: function getChangeAddress() {
                var _this = this;
                return _async_to_generator(function() {
                    var addresses, address;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                return [
                                    4,
                                    _this.getAddresses()
                                ];
                            case 1:
                                addresses = _state.sent();
                                address = addresses === null || addresses === void 0 ? void 0 : addresses.find(function(address2) {
                                    return address2.purpose === "payment";
                                });
                                if (address) return [
                                    2,
                                    address.address
                                ];
                                throw new Error("No change address found");
                        }
                    });
                })();
            }
        },
        {
            key: "getCollateral",
            value: function getCollateral() {
                return _async_to_generator(function() {
                    return _ts_generator(this, function(_state) {
                        console.log("Method getCollateral not implemented.");
                        return [
                            2,
                            []
                        ];
                    });
                })();
            }
        },
        {
            key: "getNetworkId",
            value: function getNetworkId() {
                return _async_to_generator(function() {
                    return _ts_generator(this, function(_state) {
                        return [
                            2,
                            1
                        ];
                    });
                })();
            }
        },
        {
            key: "request",
            value: function request(method, params) {
                return _async_to_generator(function() {
                    return _ts_generator(this, function(_state) {
                        return [
                            2,
                            WalletStaticMethods.request(method, params)
                        ];
                    });
                })();
            }
        },
        {
            key: "signData",
            value: function signData(payload, address) {
                var addressType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "p2wpkh";
                var _this = this;
                return _async_to_generator(function() {
                    var _address, response, err;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                _state.trys.push([
                                    0,
                                    5,
                                    ,
                                    6
                                ]);
                                _address = address;
                                if (!!_address) return [
                                    3,
                                    2
                                ];
                                return [
                                    4,
                                    _this.getAddresses().then(function(addresses) {
                                        var address2 = addresses === null || addresses === void 0 ? void 0 : addresses.find(function(address3) {
                                            return address3.addressType === addressType;
                                        });
                                        return address2 === null || address2 === void 0 ? void 0 : address2.address;
                                    })
                                ];
                            case 1:
                                _address = _state.sent();
                                _state.label = 2;
                            case 2:
                                if (!_address) return [
                                    3,
                                    4
                                ];
                                return [
                                    4,
                                    _this.request("signMessage", {
                                        message: payload,
                                        address: _address
                                    })
                                ];
                            case 3:
                                response = _state.sent();
                                if (response.status === "success") {
                                    return [
                                        2,
                                        response.result
                                    ];
                                }
                                _state.label = 4;
                            case 4:
                                return [
                                    3,
                                    6
                                ];
                            case 5:
                                err = _state.sent();
                                console.error("signMessage ~ error:", err);
                                return [
                                    3,
                                    6
                                ];
                            case 6:
                                return [
                                    2
                                ];
                        }
                    });
                })();
            }
        },
        {
            key: "signTx",
            value: function signTx(signedTx) {
                return _async_to_generator(function() {
                    return _ts_generator(this, function(_state) {
                        console.log("Method signTx not implemented.");
                        return [
                            2,
                            ""
                        ];
                    });
                })();
            }
        },
        {
            key: "submitTx",
            value: function submitTx(signedTx) {
                return _async_to_generator(function() {
                    return _ts_generator(this, function(_state) {
                        console.log("Method submitTx not implemented.");
                        return [
                            2,
                            ""
                        ];
                    });
                })();
            }
        }
    ], [
        {
            key: "enable",
            value: /**
   * This is the entrypoint to start communication with the user's wallet. The wallet should request the user's permission to connect the web page to the user's wallet, and if permission has been granted, the wallet will be returned and exposing the full API for the dApp to use.
   * @param message - A message to display to the user when requesting permission to connect the wallet.
   * @param purposes - An array of purposes for which the wallet is being connected. Default is `["payment"]`. Options are `["payment", "ordinals", "stacks"]`.
   * @returns
   */ function enable(message) {
                var purposes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [
                    "payment"
                ];
                return _async_to_generator(function() {
                    var response;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                return [
                                    4,
                                    WalletStaticMethods.request("getAccounts", {
                                        purposes: purposes,
                                        message: message
                                    })
                                ];
                            case 1:
                                response = _state.sent();
                                if (response.status === "success") {
                                    return [
                                        2,
                                        new _BrowserWallet(purposes)
                                    ];
                                }
                                throw new Error("Failed to enable wallet");
                        }
                    });
                })();
            }
        }
    ]);
    return _BrowserWallet;
}();
var WalletStaticMethods = /*#__PURE__*/ function() {
    "use strict";
    function WalletStaticMethods() {
        _class_call_check(this, WalletStaticMethods);
    }
    _create_class(WalletStaticMethods, null, [
        {
            key: "request",
            value: function request(method, params, providerId) {
                return _async_to_generator(function() {
                    var provider, response;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                provider = window.BitcoinProvider;
                                if (!provider) {
                                    throw new Error("No wallet provider was found");
                                }
                                if (!method) {
                                    throw new Error("A wallet method is required");
                                }
                                return [
                                    4,
                                    provider.request(method, params)
                                ];
                            case 1:
                                response = _state.sent();
                                if (response.result) {
                                    return [
                                        2,
                                        {
                                            status: "success",
                                            result: response.result
                                        }
                                    ];
                                }
                                return [
                                    2,
                                    {
                                        status: "error",
                                        error: response.error
                                    }
                                ];
                        }
                    });
                })();
            }
        }
    ]);
    return WalletStaticMethods;
}();
// src/wallets/embedded/index.ts
import { mnemonicToSeedSync, validateMnemonic } from "bip39";
var EmbeddedWallet = /*#__PURE__*/ function() {
    "use strict";
    function EmbeddedWallet(options) {
        _class_call_check(this, EmbeddedWallet);
        this._network = options.testnet ? bitcoin.networks.testnet : bitcoin.networks.bitcoin;
        var _options_path;
        this._wallet = _derive(options.key.words, (_options_path = options.path) !== null && _options_path !== void 0 ? _options_path : "m/84'/0'/0'/0/0", this._network);
        this._provider = options.provider;
    }
    _create_class(EmbeddedWallet, [
        {
            /**
   * Returns the wallet's SegWit (P2WPKH) address and associated public key.
   *
   * @returns {Address} The wallet address object including address, public key, and metadata.
   * @throws {Error} If internal address or public key is not properly initialized.
   */ key: "getAddress",
            value: function getAddress() {
                var p2wpkh = bitcoin.payments.p2wpkh({
                    pubkey: this._wallet.publicKey,
                    network: this._network
                });
                if (!(p2wpkh === null || p2wpkh === void 0 ? void 0 : p2wpkh.address)) {
                    throw new Error("Address is not initialized.");
                }
                return {
                    address: p2wpkh.address,
                    publicKey: this._wallet.publicKey.toString("hex"),
                    purpose: "payment",
                    addressType: "p2wpkh"
                };
            }
        },
        {
            /**
   * Returns the hex-encoded public key of the wallet.
   *
   * @returns {string} The public key in hexadecimal format.
   */ key: "getPublicKey",
            value: function getPublicKey() {
                return this._wallet.publicKey.toString("hex");
            }
        },
        {
            /**
   * Returns the network identifier of the wallet.
   * 0': Indicates the Bitcoin mainnet.
   * 1': Indicates the Bitcoin testnet.
   *
   * @returns {0 | 1} The Bitcoin network ID.
   */ key: "getNetworkId",
            value: function getNetworkId() {
                return this._network === bitcoin.networks.testnet ? 1 : 0;
            }
        },
        {
            key: "getUTxOs",
            value: /**
   * Get UTXOs for the wallet address.
   * @returns An array of UTXOs.
   */ function getUTxOs() {
                var _this = this;
                return _async_to_generator(function() {
                    var _this__provider, address;
                    return _ts_generator(this, function(_state) {
                        switch(_state.label){
                            case 0:
                                console.log("getUtxos");
                                address = _this.getAddress();
                                if (_this._provider === void 0) {
                                    throw new Error("`provider` is not defined. Provide a BitcoinProvider.");
                                }
                                return [
                                    4,
                                    (_this__provider = _this._provider) === null || _this__provider === void 0 ? void 0 : _this__provider.fetchAddressUTxOs(address.address)
                                ];
                            case 1:
                                return [
                                    2,
                                    _state.sent()
                                ];
                        }
                    });
                })();
            }
        },
        {
            /**
   * Signs a given message using the wallet's private key.
   *
   * @param message - The message to be signed.
   * @returns The signature of the message as a string.
   */ key: "signData",
            value: function signData(message) {
                return "";
            }
        },
        {
            /**
   * Sign a transaction payload.
   * @param payload - The transaction payload to sign.
   * @returns The signed transaction in hex format.
   */ key: "signTx",
            value: function signTx(payload) {
                return "";
            }
        }
    ], [
        {
            key: "brew",
            value: /**
   * Generates a mnemonic phrase and returns it as an array of words.
   *
   * @param {number} [strength=128] - The strength of the mnemonic in bits (must be a multiple of 32 between 128 and 256).
   * @returns {string[]} An array of words representing the generated mnemonic.
   * @throws {Error} If the strength is not valid.
   */ function brew() {
                var strength = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 128;
                if (![
                    128,
                    160,
                    192,
                    224,
                    256
                ].includes(strength)) {
                    throw new Error("Invalid strength. Must be one of: 128, 160, 192, 224, 256.");
                }
                var mnemonic = bip39.generateMnemonic(strength);
                return mnemonic.split(" ");
            }
        }
    ]);
    return EmbeddedWallet;
}();
function _derive(words) {
    var path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "m/84'/0'/0'/0/0", network = arguments.length > 2 ? arguments[2] : void 0;
    var mnemonic = words.join(" ");
    if (!validateMnemonic(mnemonic)) {
        throw new Error("Invalid mnemonic provided.");
    }
    var seed = mnemonicToSeedSync(mnemonic);
    var root = bip32.fromSeed(seed, network);
    var child = root.derivePath(path);
    return child;
}
export { BlockstreamProvider, BrowserWallet, ECPair, EmbeddedWallet, bip32, bip39, bitcoin };
//# sourceMappingURL=index.js.map