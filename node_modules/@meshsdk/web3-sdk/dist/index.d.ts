import * as _meshsdk_wallet from '@meshsdk/wallet';
import { MeshWallet, CreateMeshWalletOptions } from '@meshsdk/wallet';
import * as _meshsdk_bitcoin from '@meshsdk/bitcoin';
import { EmbeddedWallet } from '@meshsdk/bitcoin';
import { AxiosInstance } from 'axios';
import { IFetcher, ISubmitter, DataSignature } from '@meshsdk/common';

declare function clientDeriveWallet(encryptedKeyShard: string, spendingPassword: string, custodialShard: string, networkId: 0 | 1): Promise<{
    bitcoinWallet: _meshsdk_bitcoin.EmbeddedWallet;
    cardanoWallet: _meshsdk_wallet.MeshWallet;
    key: string;
}>;

declare function clientGenerateWallet(spendingPassword: string, recoveryAnswer: string): Promise<{
    pubKeyHash: string;
    stakeCredentialHash: string;
    encryptedDeviceShard: string;
    authShard: string;
    encryptedRecoveryShard: string;
    bitcoinPubKeyHash: string;
}>;

declare function clientRecovery(authShard: string, recoveryShard: string, recoveryAnswer: string, spendingPassword: string): Promise<{
    deviceShard: string;
    authShard: string;
}>;

declare function stringToBytes(data: string): Uint8Array<ArrayBufferLike>;
declare function bytesToString(data: Uint8Array): string;
declare function bytesToHex(bytes: Uint8Array): string;
declare function hexToBytes(hex: string): Uint8Array;

declare function encryptWithCipher({ data, key, algorithm, initializationVectorSize, }: {
    data: string;
    key: string;
    algorithm?: string;
    initializationVectorSize?: number;
}): Promise<string>;
declare function decryptWithCipher({ encryptedDataJSON, key, algorithm, }: {
    encryptedDataJSON: string;
    key: string;
    algorithm?: string;
}): Promise<string>;
declare function generateKeyPair(): Promise<{
    publicKey: string;
    privateKey: string;
}>;
declare function encryptWithPublicKey({ publicKey, data, }: {
    publicKey: string;
    data: string;
}): Promise<string>;
declare function decryptWithPrivateKey({ privateKey, encryptedDataJSON, }: {
    privateKey: string;
    encryptedDataJSON: string;
}): Promise<string>;

declare function generateHash({ size, }: {
    size?: number;
}): Promise<string>;
declare function hashData({ data, privateKey, algorithm, }: {
    data: any;
    privateKey?: string;
    algorithm?: string;
}): Promise<string>;

declare let crypto: Crypto;

declare function combineShardsBuildWallet(networkId: 0 | 1, keyShard1: string, keyShard2: string): Promise<{
    key: string;
    bitcoinWallet: EmbeddedWallet;
    cardanoWallet: MeshWallet;
}>;

declare function getAddressFromHashes(pubKeyHash: string, stakeCredentialHash: string, networkId: 0 | 1): string;

/**
 * Splits a `secret` into `shares` number of shares, requiring `threshold` of them to reconstruct `secret`.
 *
 * @param secret The secret value to split into shares.
 * @param shares The total number of shares to split `secret` into. Must be at least 2 and at most 255.
 * @param threshold The minimum number of shares required to reconstruct `secret`. Must be at least 2 and at most 255.
 * @returns A list of `shares` shares.
 */
declare function shamirSplit(secret: Uint8Array, shares: number, threshold: number): Promise<Uint8Array[]>;
/**
 * Combines `shares` to reconstruct the secret.
 *
 * @param shares A list of shares to reconstruct the secret from. Must be at least 2 and at most 255.
 * @returns The reconstructed secret.
 */
declare function shamirCombine(shares: Uint8Array[]): Promise<Uint8Array>;

declare function spiltKeyIntoShards(key: string): Promise<string[]>;

type WindowSignDataReq = {
    method: "sign-data";
    payload: string;
    networkId: 0 | 1;
    projectId?: string;
};
type WindowSignDataRes = {
    success: boolean;
    signature: {
        signature: string;
        key: string;
    };
};

type WindowSignTxReq = {
    method: "sign-tx";
    unsignedTx: string;
    networkId: 0 | 1;
    projectId?: string;
};
type WindowSignTxRes = {
    success: boolean;
    tx: string;
};

type UserSocialData = {
    avatar_url: string | null;
    created_at: string;
    email: string | null;
    id: string;
    username: string | null;
};

type WindowWalletReq = {
    networkId: 0 | 1;
    projectId?: string;
    appUrl?: string;
    directTo?: UserControlledWalletDirectTo;
};
type WindowWalletRes = {
    success: boolean;
    pubKeyHash: string;
    stakeCredentialHash: string;
    user: UserSocialData | undefined;
};
type UserControlledWalletDirectTo = "google" | "twitter" | "discord" | "apple";

type Web3Project = {
    id: string;
    name: string;
    whitelistedUrls: string[];
    isActive: boolean;
    credits: number;
    discordOauthClient: string | null;
    discordOauthSecret: string | null;
    twitterOauthClient: string | null;
    twitterOauthSecret: string | null;
    googleOauthClient: string | null;
    googleOauthSecret: string | null;
    branding: Web3ProjectBranding;
    publicKey: string | null;
    apiKey: string;
};
type Web3ProjectBranding = {
    name?: string;
    color?: string;
    logoUrl?: string;
    twitterEnabled?: boolean;
    discordEnabled?: boolean;
    googleEnabled?: boolean;
    appleEnabled?: boolean;
};
type Web3ProjectWallet = {
    id: string;
    key: string;
    tags: string[];
    projectId: string;
    pubKeyHash: string;
    stakeCredentialHash: string;
};
type Web3JWTBody = {
    /** User's ID */
    sub: string;
    /** Can contain: 'projectId' or 'dashboard'. */
    scopes: string[];
    /** Issued at */
    iat: number;
    /** Expires at */
    exp: number;
    /** OAuth2 Provider */
    provider: string;
    /** User ID on OAuth2 Provider */
    providerId: string;
    /** Profile picture from OAuth2 Provider */
    avatarUrl: string | null;
    /** Email from OAuth2 Provider */
    email: string | null;
    /** Username from OAuth2 Provider */
    username: string | null;
};
type Web3AuthProvider = "google" | "discord" | "twitter" | "apple";

type UserWalletSettings = {
    wallet: UserWalletSettingsWallet;
};
type UserWalletSettingsWallet = {
    network: "mainnet" | "preprod";
    authorizedApps?: {
        url: string;
    }[] | undefined;
};
type Web3WalletObject = {
    id: string;
    createdAt: string;
    userId: string;
    authShard: string;
    recovery: Web3WalletRecovery;
    cardanoPubKeyHash: string;
    cardanoStakeCredentialHash: string;
    bitcoinPubKeyHash: string;
    projectId: string;
};
type Web3WalletRecovery = {
    recoveryShard: string;
    recoveryShardQuestion: string;
};

type OpenWindowParams = {
    method: "enable";
    projectId: string;
    directTo?: Web3AuthProvider;
} | {
    method: "sign-tx";
    projectId: string;
    directTo?: Web3AuthProvider;
    unsignedTx: string;
    partialSign: "true" | "false";
} | {
    method: "sign-data";
    projectId: string;
    directTo?: Web3AuthProvider;
    payload: string;
    address?: string;
};
type OpenWindowResult = {
    success: true;
    data: {
        method: "enable";
        pubKeyHash: string;
        stakeCredentialHash: string;
        user: UserSocialData;
    } | {
        method: "sign-data";
        signature: {
            signature: string;
            key: string;
        };
    } | {
        method: "sign-tx";
        tx: string;
    };
} | {
    success: false;
    message: string;
};

declare function openWindow(params: OpenWindowParams, appUrl?: string): Promise<any>;

/**
 * The `WalletDeveloperControlled` class provides functionality for managing developer-controlled wallets
 * within a Web3 project. It allows for creating wallets, retrieving wallet information, and accessing
 * specific wallets using their identifiers.
 */
declare class WalletDeveloperControlled {
    readonly sdk: Web3Sdk;
    constructor({ sdk }: {
        sdk: Web3Sdk;
    });
    /**
     * Creates a new wallet associated with the current project.
     * This method generates a new wallet encrypts it with the project's public key, and registers the wallet with the backend service.
     *
     * @param {Object} [options] - Optional parameters for wallet creation.
     * @param {string} [options.tag] - An optional tag to associate with the wallet.
     *
     * @returns {Promise<Web3ProjectWallet>} A promise that resolves to the created wallet instance.
     *
     * @throws {Error} If the project's public key is not found.
     * @throws {Error} If the wallet creation request to the backend fails.
     */
    createWallet({ tags, }?: {
        tags?: string[];
    }): Promise<Web3ProjectWallet>;
    /**
     * Retrieves a list of wallets associated with the current project.
     *
     * @returns {Promise<Web3ProjectWallet[]>} A promise that resolves to an array of wallets,
     * each containing the wallet's `id`, `address`, `networkId`, and `tag`.
     *
     * @throws {Error} Throws an error if the request to fetch wallets fails.
     */
    getWallets(): Promise<Web3ProjectWallet[]>;
    /**
     * Retrieves a wallet by its ID and decrypts the key with the project's private key.
     *
     * @param walletId - The unique identifier of the wallet to retrieve.
     * @param networkId - The network ID associated with the wallet (0 or 1).
     * @param decryptKey - A boolean indicating whether to decrypt the wallet key (default: false).
     *
     * @returns A promise that resolves to an initialized `MeshWallet` instance.
     * @throws Will throw an error if the private key is not found or if the wallet retrieval fails.
     */
    getWallet(walletId: string, networkId: 0 | 1, decryptKey?: boolean): Promise<{
        info: Web3ProjectWallet;
        wallet: MeshWallet;
    }>;
    getWalletsByTag(tag: string): Promise<Web3ProjectWallet[]>;
}

declare class Web3Sdk {
    readonly axiosInstance: AxiosInstance;
    readonly appUrl: string;
    readonly projectId: string;
    readonly apiKey: string;
    readonly privateKey: string | undefined;
    project: Web3Project | undefined;
    readonly providerFetcher: IFetcher | undefined;
    readonly providerSubmitter: ISubmitter | undefined;
    readonly wallet: WalletDeveloperControlled;
    constructor({ appUrl, projectId, apiKey, privateKey, fetcher, submitter, }: {
        appUrl?: string;
        projectId: string;
        apiKey: string;
        privateKey?: string;
        fetcher?: IFetcher;
        submitter?: ISubmitter;
    });
    getProject(): Promise<Web3Project>;
}

type EnableWeb3WalletOptions = {
    networkId: 0 | 1;
    fetcher?: IFetcher;
    submitter?: ISubmitter;
    projectId?: string;
    appUrl?: string;
    directTo?: Web3AuthProvider;
};
type InitWeb3WalletOptions = CreateMeshWalletOptions & {
    projectId?: string;
    appUrl?: string;
    user?: UserSocialData;
};
/**
 * Mesh wallet-as-a-service are designed to be strictly non-custodial,
 * meaning neither the developer nor Mesh can access the user's private key.
 */
declare class Web3Wallet extends MeshWallet {
    projectId?: string;
    appUrl?: string;
    user?: UserSocialData;
    constructor(options: InitWeb3WalletOptions);
    /**
     * Initializes a new instance of the Web3Wallet class.
     *
     * @param options - The options to initialize the wallet.
     * @param options.networkId - The network ID (0 for testnet, 1 for mainnet).
     * @param options.fetcher - An optional fetcher for network requests.
     * @param options.submitter - An optional submitter for transaction submissions.
     * @param options.projectId - An optional project ID for analytics or tracking.
     * @param options.appUrl - An optional application URL for the wallet.
     * @param options.directTo - An optional parameter to specify the user-controlled wallet direct-to option.
     *
     * @returns A promise that resolves to an instance of Web3Wallet.
     */
    static enable(options: EnableWeb3WalletOptions): Promise<Web3Wallet>;
    getUser(): UserSocialData | undefined;
    /**
     * Requests user to sign the provided transaction (tx). The wallet should ask the user for permission, and if given, try to sign the supplied body and return a signed transaction. partialSign should be true if the transaction provided requires multiple signatures.
     *
     * @param unsignedTx - a transaction in CBOR
     * @param partialSign - if the transaction is partially signed (default: false)
     * @returns a signed transaction in CBOR
     */
    signTx(unsignedTx: string, partialSign?: boolean): Promise<string>;
    /**
     * This endpoint utilizes the [CIP-8 - Message Signing](https://cips.cardano.org/cips/cip8/) to sign arbitrary data, to verify the data was signed by the owner of the private key.
     *
     * @param payload - the payload to sign
     * @param address - the address to use for signing (optional)
     * @returns a signature
     */
    signData(payload: string, address?: string): Promise<DataSignature>;
    /**
     * Initializes a new instance of a Web3 wallet with the specified options.
     *
     * @param params - The parameters required to initialize the wallet.
     * @param params.networkId - The network ID to connect to. Must be either `0` (testnet) or `1` (mainnet).
     * @param params.address - The wallet address to associate with the wallet instance.
     * @param params.fetcher - (Optional) An implementation of the `IFetcher` interface for fetching data.
     * @param params.submitter - (Optional) An implementation of the `ISubmitter` interface for submitting transactions.
     * @param params.projectId - (Optional) The project ID for analytics or tracking purposes.
     * @param params.appUrl - (Optional) The application URL for associating the wallet with a specific app.
     *
     * @returns A promise that resolves to an initialized instance of `Web3Wallet`.
     */
    static initWallet({ networkId, address, fetcher, submitter, projectId, appUrl, user, }: {
        networkId: 0 | 1;
        address: string;
        fetcher?: IFetcher;
        submitter?: ISubmitter;
        projectId?: string;
        appUrl?: string;
        user?: UserSocialData;
    }): Promise<Web3Wallet>;
}
declare class ApiError extends Error {
    json: Record<string, any>;
    constructor(json: Record<string, any>);
}

type StorageLocation = "local_storage" | "chrome_local" | "chrome_sync";
type CreateWalletBody = {
    userAgent: string;
    recoveryShard: string;
    authShard: string;
    recoveryShardQuestion: string;
    cardanoPubKeyHash: string;
    cardanoStakeCredentialHash: string;
    bitcoinPubKeyHash: string;
    projectId: string;
};
type CreateDeviceBody = {
    walletId: string;
    authShard: string;
    userAgent: string;
};
type CreateDeviceResponse = {
    deviceId: string;
};
type GetWalletBody = {
    id: string;
    userId: string;
    recoveryShard: string;
    createdAt: string;
    recoveryShardQuestion: string;
    cardanoPubKeyHash: string;
    cardanoStakeCredentialHash: string;
    bitcoinPubKeyHash: string;
    projectId: string;
    authShard: string;
};
type CreateWalletResponseBody = {
    walletId: string;
    deviceId: string;
};
type WalletDevice = {
    id: string;
    walletId: string;
    cardanoPubKeyHash: string;
    cardanoStakeCredentialHash: string;
    bitcoinPubKeyHash: string;
    lastConnected: string;
    authShard: string;
    userAgent: string | null;
};
type GetDevicesResponse = {
    deviceId: string;
    walletId: string;
    authShard: string;
    userAgent: string | null;
}[];
type Web3NonCustodialProviderParams = {
    projectId: string;
    appOrigin?: string;
    storageLocation?: StorageLocation;
    googleOauth2ClientId: string;
    twitterOauth2ClientId: string;
    discordOauth2ClientId: string;
    appleOauth2ClientId: string;
};
type Web3NonCustodialProviderUser = {
    id: string;
    scopes: string[];
    provider: string;
    providerId: string;
    avatarUrl: string | null;
    email: string | null;
    username: string | null;
    token: string;
};
type Web3NonCustodialWallet = {
    deviceId: string;
    walletId: string;
    authShard: string;
    localShard: string;
    userAgent: string | null;
};
declare class NotAuthenticatedError extends Error {
    constructor(message?: string);
}
declare class WalletServerRetrievalError extends Error {
    constructor(message?: string);
}
declare class WalletServerCreationError extends Error {
    constructor(message?: string);
}
declare class SessionExpiredError extends Error {
    constructor(message?: string);
}
declare class AuthRouteError extends Error {
    constructor(message?: string);
}
declare class StorageRetrievalError extends Error {
    constructor(message?: string);
}
declare class StorageInsertError extends Error {
    constructor(message?: string);
}
declare class Web3NonCustodialProvider {
    projectId: string;
    appOrigin: string;
    storageLocation: StorageLocation;
    googleOauth2ClientId: string;
    twitterOauth2ClientId: string;
    discordOauth2ClientId: string;
    appleOauth2ClientId: string;
    constructor(params: Web3NonCustodialProviderParams);
    checkNonCustodialWalletsOnServer(): Promise<{
        data: Web3WalletObject[];
        error: null;
    } | {
        data: null;
        error: NotAuthenticatedError | StorageRetrievalError | SessionExpiredError;
    }>;
    getWallets(): Promise<{
        data: Web3NonCustodialWallet[];
        error: null;
    } | {
        data: null;
        error: NotAuthenticatedError | StorageRetrievalError | SessionExpiredError;
    }>;
    createWallet(spendingPassword: string, recoveryQuestion: string, recoveryAnswer: string): Promise<{
        data: null;
        error: NotAuthenticatedError | SessionExpiredError | WalletServerCreationError;
    } | {
        error: null;
        data: {
            deviceId: string;
            walletId: string;
        };
    }>;
    getUser(): Promise<{
        data: Web3NonCustodialProviderUser;
        error: null;
    } | {
        data: null;
        error: NotAuthenticatedError | SessionExpiredError;
    }>;
    performRecovery(recoveryAnswer: string, walletId: string, spendingPassword: string): Promise<{
        error: NotAuthenticatedError | SessionExpiredError;
    } | {
        error: null;
    }>;
    signInWithProvider(provider: Web3AuthProvider, redirectUrl: string, callback: (authorizationUrl: string) => void): void;
    /** Always place under /auth/mesh */
    handleAuthenticationRoute(): {
        error: AuthRouteError;
    } | void;
    private putInStorage;
    private pushDevice;
    private getFromStorage;
}

export { ApiError, AuthRouteError, type CreateDeviceBody, type CreateDeviceResponse, type CreateWalletBody, type CreateWalletResponseBody, type EnableWeb3WalletOptions, type GetDevicesResponse, type GetWalletBody, NotAuthenticatedError, type OpenWindowParams, type OpenWindowResult, SessionExpiredError, StorageInsertError, type StorageLocation, StorageRetrievalError, type UserControlledWalletDirectTo, type UserSocialData, type UserWalletSettings, type UserWalletSettingsWallet, type WalletDevice, WalletServerCreationError, WalletServerRetrievalError, type Web3AuthProvider, type Web3JWTBody, Web3NonCustodialProvider, type Web3NonCustodialProviderParams, type Web3NonCustodialProviderUser, type Web3NonCustodialWallet, type Web3Project, type Web3ProjectBranding, type Web3ProjectWallet, Web3Sdk, Web3Wallet, type Web3WalletObject, type Web3WalletRecovery, type WindowSignDataReq, type WindowSignDataRes, type WindowSignTxReq, type WindowSignTxRes, type WindowWalletReq, type WindowWalletRes, bytesToHex, bytesToString, clientDeriveWallet, clientGenerateWallet, clientRecovery, combineShardsBuildWallet, crypto, decryptWithCipher, decryptWithPrivateKey, encryptWithCipher, encryptWithPublicKey, generateHash, generateKeyPair, getAddressFromHashes, hashData, hexToBytes, openWindow, shamirCombine, shamirSplit, spiltKeyIntoShards, stringToBytes };
