// src/utils/address.ts
import {
  pubKeyAddress,
  scriptAddress
} from "@meshsdk/common";

// src/deser/csl.ts
import * as csl from "@sidan-lab/whisky-js-nodejs";

// src/deser/constants.ts
var LANGUAGE_VERSIONS = {
  V1: csl.Language.new_plutus_v1(),
  V2: csl.Language.new_plutus_v2(),
  V3: csl.Language.new_plutus_v3()
};
var REDEEMER_TAGS = {
  CERT: csl.RedeemerTag.new_cert(),
  MINT: csl.RedeemerTag.new_mint(),
  REWARD: csl.RedeemerTag.new_reward(),
  SPEND: csl.RedeemerTag.new_spend()
};
var POLICY_ID_LENGTH = 56;

// src/deser/converter.ts
import JSONbig from "json-bigint";
var toAddress = (bech32) => csl.Address.from_bech32(bech32);
var toBaseAddress = (bech32) => csl.BaseAddress.from_address(toAddress(bech32));
var toEnterpriseAddress = (bech32) => csl.EnterpriseAddress.from_address(toAddress(bech32));
var toRewardAddress = (bech32) => csl.RewardAddress.from_address(toAddress(bech32));
var fromBytes = (bytes) => Buffer.from(bytes).toString("hex");
var toBytes = (hex) => {
  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))
    return Buffer.from(hex, "hex");
  return Buffer.from(hex, "utf-8");
};
var fromUTF8 = (utf8) => {
  if (utf8.length % 2 === 0 && /^[0-9A-F]*$/i.test(utf8)) return utf8;
  return fromBytes(Buffer.from(utf8, "utf-8"));
};
var toUTF8 = (hex) => Buffer.from(hex, "hex").toString("utf-8");
var fromLovelace = (lovelace) => lovelace / 1e6;
var toLovelace = (ada) => ada * 1e6;
var toScriptRef = (script) => {
  if ("code" in script) {
    const plutusScript = deserializePlutusScript(script.code, script.version);
    return csl.ScriptRef.new_plutus_script(plutusScript);
  }
  return csl.ScriptRef.new_native_script(toNativeScript(script));
};
var toPlutusData = (data) => {
  const toPlutusList = (dataArray) => {
    const plutusList = csl.PlutusList.new();
    dataArray.forEach((element) => {
      plutusList.add(toPlutusData(element));
    });
    return plutusList;
  };
  switch (typeof data) {
    case "string":
      return csl.PlutusData.new_bytes(toBytes(data));
    case "number":
      return csl.PlutusData.new_integer(csl.BigInt.from_str(data.toString()));
    case "bigint":
      return csl.PlutusData.new_integer(csl.BigInt.from_str(data.toString()));
    case "object":
      if (data instanceof Array) {
        const plutusList = toPlutusList(data);
        return csl.PlutusData.new_list(plutusList);
      }
      if (data instanceof Map) {
        const plutusMap = csl.PlutusMap.new();
        data.forEach((value, key) => {
          const plutusMapValue = csl.PlutusMapValues.new();
          plutusMapValue.add(toPlutusData(value));
          plutusMap.insert(toPlutusData(key), plutusMapValue);
        });
        return csl.PlutusData.new_map(plutusMap);
      }
      return csl.PlutusData.new_constr_plutus_data(
        csl.ConstrPlutusData.new(
          csl.BigNum.from_str(data.alternative.toString()),
          toPlutusList(data.fields)
        )
      );
  }
};
var castRawDataToJsonString = (rawData) => {
  if (typeof rawData === "object") {
    return JSONbig.stringify(rawData);
  }
  return rawData;
};
var castDataToPlutusData = ({
  type,
  content
}) => {
  if (type === "Mesh") {
    return toPlutusData(content);
  }
  if (type === "CBOR") {
    return csl.PlutusData.from_hex(content);
  }
  return csl.PlutusData.from_json(
    castRawDataToJsonString(content),
    csl.PlutusDatumSchema.DetailedSchema
  );
};
var toNativeScript = (script) => {
  const toNativeScripts = (scripts) => {
    const nativeScripts = csl.NativeScripts.new();
    scripts.forEach((script2) => {
      nativeScripts.add(toNativeScript(script2));
    });
    return nativeScripts;
  };
  switch (script.type) {
    case "all":
      return csl.NativeScript.new_script_all(
        csl.ScriptAll.new(toNativeScripts(script.scripts))
      );
    case "any":
      return csl.NativeScript.new_script_any(
        csl.ScriptAny.new(toNativeScripts(script.scripts))
      );
    case "atLeast":
      return csl.NativeScript.new_script_n_of_k(
        csl.ScriptNOfK.new(script.required, toNativeScripts(script.scripts))
      );
    case "after":
      return csl.NativeScript.new_timelock_start(
        csl.TimelockStart.new_timelockstart(csl.BigNum.from_str(script.slot))
      );
    case "before":
      return csl.NativeScript.new_timelock_expiry(
        csl.TimelockExpiry.new_timelockexpiry(csl.BigNum.from_str(script.slot))
      );
    case "sig":
      return csl.NativeScript.new_script_pubkey(
        csl.ScriptPubkey.new(deserializeEd25519KeyHash(script.keyHash))
      );
  }
};
var toCslValue = (assets) => {
  let cslValue = void 0;
  let multiAsset = csl.MultiAsset.new();
  for (const asset of assets) {
    if (asset.unit === "lovelace" || asset.unit === "") {
      cslValue = csl.Value.new(csl.BigNum.from_str(asset.quantity));
    } else {
      const policyId = csl.ScriptHash.from_hex(asset.unit.slice(0, 56));
      const assetName = csl.AssetName.new(
        Buffer.from(asset.unit.slice(56), "hex")
      );
      const quantity = csl.BigNum.from_str(asset.quantity);
      multiAsset.set_asset(policyId, assetName, quantity);
    }
  }
  if (cslValue !== void 0) {
    cslValue.set_multiasset(multiAsset);
  } else {
    cslValue = csl.Value.new(csl.BigNum.from_str("0"));
    cslValue.set_multiasset(multiAsset);
  }
  return cslValue;
};

// src/deser/deserializer.ts
var deserializeAddress = (address) => csl.Address.from_bytes(toBytes(address));
var deserializeBip32PrivateKey = (bip32PrivateKey) => csl.Bip32PrivateKey.from_bytes(toBytes(bip32PrivateKey));
var deserializeDataHash = (dataHash) => csl.DataHash.from_bytes(toBytes(dataHash));
var deserializeEd25519KeyHash = (ed25519KeyHash) => csl.Ed25519KeyHash.from_bytes(toBytes(ed25519KeyHash));
var deserializeEd25519Signature = (ed25519Signature) => csl.Ed25519Signature.from_bytes(toBytes(ed25519Signature));
var deserializeNativeScript = (nativeScript) => csl.NativeScript.from_bytes(toBytes(nativeScript));
var deserializePublicKey = (publicKey) => csl.PublicKey.from_bytes(toBytes(publicKey));
var deserializePlutusData = (plutusData) => csl.PlutusData.from_bytes(toBytes(plutusData));
var deserializePlutusScript = (plutusScript, version) => csl.PlutusScript.from_hex_with_version(
  plutusScript,
  LANGUAGE_VERSIONS[version]
);
var deserializeScriptRef = (scriptRef) => csl.ScriptRef.from_bytes(toBytes(scriptRef));
var deserializeScriptHash = (scriptHash) => csl.ScriptHash.from_bytes(toBytes(scriptHash));
var deserializeTx = (tx) => csl.Transaction.from_bytes(toBytes(tx));
var deserializeTxBody = (txBody) => csl.TransactionBody.from_bytes(toBytes(txBody));
var deserializeTxHash = (txHash) => csl.TransactionHash.from_bytes(toBytes(txHash));
var deserializeTxUnspentOutput = (txUnspentOutput) => csl.TransactionUnspentOutput.from_bytes(toBytes(txUnspentOutput));
var deserializeTxWitnessSet = (txWitnessSet) => csl.TransactionWitnessSet.from_bytes(toBytes(txWitnessSet));
var deserializeValue = (value) => csl.Value.from_bytes(toBytes(value));

// src/deser/resolver.ts
import {
  mnemonicToEntropy
} from "@meshsdk/common";
var resolveStakeKeyHash = (bech32) => {
  try {
    const stakeKeyHash = [
      toBaseAddress(bech32)?.stake_cred().to_keyhash(),
      toRewardAddress(bech32)?.payment_cred().to_keyhash()
    ].find((kh) => kh !== void 0);
    if (stakeKeyHash !== void 0) return stakeKeyHash.to_hex();
    throw new Error(`Couldn't resolve stake key hash from address: ${bech32}`);
  } catch (error) {
    throw new Error(`An error occurred during resolveStakeKeyHash: ${error}.`);
  }
};
var resolvePrivateKey = (words) => {
  const buildBip32PrivateKey = (entropy2, password = "") => {
    return csl.Bip32PrivateKey.from_bip39_entropy(
      toBytes(entropy2),
      toBytes(fromUTF8(password))
    );
  };
  const entropy = mnemonicToEntropy(words.join(" "));
  const bip32PrivateKey = buildBip32PrivateKey(entropy);
  const bech32PrivateKey = bip32PrivateKey.to_bech32();
  bip32PrivateKey.free();
  return bech32PrivateKey;
};
var resolveNativeScriptAddress = (script, networkId = 0) => {
  const nativeScript = toNativeScript(script);
  const enterpriseAddress = csl.EnterpriseAddress.new(
    networkId,
    csl.Credential.from_scripthash(nativeScript.hash())
  );
  return enterpriseAddress.to_address().to_bech32();
};
var resolvePlutusScriptAddress = (script, networkId = 0) => {
  const plutusScript = deserializePlutusScript(script.code, script.version);
  const enterpriseAddress = csl.EnterpriseAddress.new(
    networkId,
    csl.Credential.from_scripthash(plutusScript.hash())
  );
  return enterpriseAddress.to_address().to_bech32();
};
var resolveNativeScriptHash = (script) => {
  return toNativeScript(script).hash().to_hex();
};
var resolveScriptHashDRepId = (scriptHash) => {
  return csl.DRep.new_script_hash(
    csl.ScriptHash.from_hex(scriptHash)
  ).to_bech32(true);
};
var resolveRewardAddress = (bech32) => {
  const buildRewardAddress = (networkId, stakeKeyHash) => {
    return csl.RewardAddress.new(
      networkId,
      csl.Credential.from_keyhash(stakeKeyHash)
    );
  };
  try {
    const address = toAddress(bech32);
    const baseAddress = toBaseAddress(bech32);
    const stakeKeyHash = baseAddress?.stake_cred().to_keyhash();
    if (stakeKeyHash !== void 0)
      return buildRewardAddress(address.network_id(), stakeKeyHash).to_address().to_bech32();
    throw new Error(`Couldn't resolve reward address from address: ${bech32}`);
  } catch (error) {
    throw new Error(`An error occurred during resolveRewardAddress: ${error}.`);
  }
};
var resolveDataHash = (rawData, type = "Mesh") => {
  const plutusData = castDataToPlutusData({
    content: rawData,
    type
  });
  const dataHash = csl.hash_plutus_data(plutusData);
  return dataHash.to_hex();
};
var resolveNativeScriptHex = (script) => {
  return toNativeScript(script).to_hex();
};
var serializePoolId = (hash) => {
  return csl.Ed25519KeyHash.from_hex(hash).to_bech32("pool1");
};
var resolveScriptRef = (script) => {
  return toScriptRef(script).to_hex();
};
var resolveEd25519KeyHash = (bech32) => {
  return csl.Ed25519KeyHash.from_bech32(bech32).to_hex();
};

// src/utils/scripts.ts
var getV2ScriptHash = (script) => csl.get_v2_script_hash(script);

// src/utils/address.ts
var serialzeAddress = (deserializedAddress, networkId = 0) => {
  const {
    pubKeyHash,
    scriptHash,
    stakeCredentialHash,
    stakeScriptCredentialHash
  } = deserializedAddress;
  const isPaymentScript = !pubKeyHash;
  const isStakeScript = !stakeCredentialHash;
  const paymentHash = isPaymentScript ? scriptHash : pubKeyHash;
  const stakeHash = isStakeScript ? stakeScriptCredentialHash : stakeCredentialHash;
  if (!paymentHash)
    throw new Error(
      "Error: serializeAddress: Address must contain a payment part"
    );
  const addressObj = isPaymentScript ? scriptAddress(paymentHash, stakeHash, isStakeScript) : pubKeyAddress(paymentHash, stakeHash, isStakeScript);
  return serializeAddressObj(addressObj, networkId);
};
var addrBech32ToPlutusDataHex = (bech32) => {
  const hexAddress = csl.Address.from_bech32(bech32).to_hex();
  const cslAddress = csl.Address.from_hex(hexAddress);
  const hex = csl.PlutusData.from_address(cslAddress).to_hex();
  return hex;
};
var addrBech32ToPlutusDataObj = (bech32) => {
  const hexAddress = csl.Address.from_bech32(bech32).to_hex();
  const cslAddress = csl.Address.from_hex(hexAddress);
  const json = JSON.parse(csl.PlutusData.from_address(cslAddress).to_json(1));
  return json;
};
var serializeAddressObj = (plutusDataAddressObject, networkId = 0) => {
  const bech32Addr = csl.parse_plutus_address_obj_to_bech32(
    JSON.stringify(plutusDataAddressObject),
    networkId
  );
  return bech32Addr;
};
var serializePlutusAddressToBech32 = (plutusHex, networkId = 0) => {
  const cslPlutusDataAddress = csl.PlutusData.from_hex(plutusHex);
  const plutusDataAddressObject = JSON.parse(
    cslPlutusDataAddress.to_json(csl.PlutusDatumSchema.DetailedSchema)
  );
  return serializeAddressObj(plutusDataAddressObject, networkId);
};
var deserializeBech32Address = (bech32Addr) => {
  const deserializedAddress = csl.deserialize_bech32_address(bech32Addr);
  return {
    pubKeyHash: deserializedAddress.get_pub_key_hash(),
    scriptHash: deserializedAddress.get_script_hash(),
    stakeCredentialHash: deserializedAddress.get_stake_key_hash(),
    stakeScriptCredentialHash: deserializedAddress.get_stake_key_script_hash()
  };
};
var scriptHashToBech32 = (scriptHash, stakeCredentialHash, networkId = 0, isScriptStakeCredentialHash = false) => csl.wasm_script_to_address(
  networkId,
  scriptHash,
  stakeCredentialHash,
  isScriptStakeCredentialHash
);
var v2ScriptToBech32 = (scriptCbor, stakeCredential, networkId = 0, isScriptStakeCredential = false) => scriptHashToBech32(
  getV2ScriptHash(scriptCbor),
  stakeCredential,
  networkId,
  isScriptStakeCredential
);

// src/utils/datum.ts
var parseInlineDatum = (utxo) => {
  const datumCbor = utxo.inline_datum || "";
  const parsedDatum = csl.PlutusData.from_hex(datumCbor);
  const datum = JSON.parse(parsedDatum.to_json(1));
  return datum;
};
var parseDatumCbor = (datumCbor) => {
  const parsedDatum = csl.PlutusData.from_hex(datumCbor);
  const datum = JSON.parse(parsedDatum.to_json(1));
  return datum;
};

// src/utils/credentials.ts
var skeyToPubKeyHash = (skeyHex) => {
  const isHexUnclean = skeyHex.slice(0, 4) === "5820" && skeyHex.length === 68;
  const cleanHex = isHexUnclean ? skeyHex.slice(4) : skeyHex;
  return csl.PrivateKey.from_hex(cleanHex).to_public().hash().to_hex();
};

// src/utils/staking.ts
var poolIdHexToBech32 = (poolIdHash) => {
  const cslPoolIdHash = csl.Ed25519KeyHash.from_hex(poolIdHash);
  return cslPoolIdHash.to_bech32("pool");
};
var poolIdBech32ToHex = (poolIdBech32) => {
  const cslPoolIdHash = csl.Ed25519KeyHash.from_bech32(poolIdBech32);
  return Buffer.from(cslPoolIdHash.to_bytes()).toString("hex");
};
var baseAddressToStakeAddress = (baseAddressBech32, network = 1) => {
  const networkId = network === 1 ? csl.NetworkId.mainnet().kind() : csl.NetworkId.testnet().kind();
  const stakeCred = csl.BaseAddress.from_address(
    csl.Address.from_bech32(baseAddressBech32)
  )?.stake_cred();
  if (stakeCred) {
    const stakeAddress = csl.RewardAddress.new(networkId, stakeCred).to_address().to_bech32();
    return stakeAddress;
  }
  return "";
};
var rewardAddressToKeyHash = (rewardBech32) => {
  return toRewardAddress(rewardBech32)?.payment_cred().to_keyhash()?.to_hex();
};
var scriptHashToRewardAddress = (scriptHashHex, network = 1) => {
  const networkId = network === 1 ? csl.NetworkId.mainnet().kind() : csl.NetworkId.testnet().kind();
  const scriptHash = csl.ScriptHash.from_hex(scriptHashHex);
  const credential = csl.Credential.from_scripthash(scriptHash);
  const rewardAddress = csl.RewardAddress.new(networkId, credential).to_address().to_bech32();
  return rewardAddress;
};
var keyHashToRewardAddress = (keyHashHex, network = 1) => {
  const networkId = network === 1 ? csl.NetworkId.mainnet().kind() : csl.NetworkId.testnet().kind();
  const keyHash = csl.Ed25519KeyHash.from_hex(keyHashHex);
  const credential = csl.Credential.from_scripthash(keyHash);
  const rewardAddress = csl.RewardAddress.new(networkId, credential).to_address().to_bech32();
  return rewardAddress;
};

// src/utils/transaction.ts
import { js_get_tx_outs_utxo } from "@sidan-lab/whisky-js-nodejs";

// src/wasm.ts
var parseWasmResult = (result) => {
  if (result.get_status() !== "success") {
    throw new Error(result.get_error());
  }
  return result.get_data();
};

// src/utils/transaction.ts
function isSuccessAction(action) {
  return action.success !== void 0;
}
function isErrorAction(action) {
  return action.error !== void 0;
}
var calculateTxHash = (txHex) => {
  const result = csl.js_calculate_tx_hash(txHex);
  return parseWasmResult(result);
};
var signTransaction = (txHex, signingKeys) => {
  const cslSigningKeys = csl.JsVecString.new();
  signingKeys.forEach((key) => {
    cslSigningKeys.add(key);
  });
  const result = csl.js_sign_transaction(txHex, cslSigningKeys);
  return parseWasmResult(result);
};
var evaluateTransaction = (txHex, resolvedUtxos, chainedTxs, network, slotConfig) => {
  const additionalTxs = csl.JsVecString.new();
  for (const tx of chainedTxs) {
    additionalTxs.add(tx);
  }
  const mappedUtxos = csl.JsVecString.new();
  for (const utxo of resolvedUtxos) {
    mappedUtxos.add(JSON.stringify(utxo));
  }
  const result = csl.js_evaluate_tx_scripts(
    txHex,
    mappedUtxos,
    additionalTxs,
    network,
    JSON.stringify(slotConfig)
  );
  const unwrappedResult = parseWasmResult(result);
  const actions = JSON.parse(unwrappedResult);
  let parsedSuccessActions = [];
  let parsedErrorActions = [];
  actions.map((action) => {
    if (isSuccessAction(action)) {
      parsedSuccessActions.push(action.success);
    } else if (isErrorAction(action)) {
      parsedErrorActions.push(action.error);
    } else {
      throw new Error("Invalid action type found");
    }
  });
  if (parsedErrorActions.length > 0) {
    throw new Error(JSON.stringify(parsedErrorActions));
  }
  return parsedSuccessActions.map(mapAction);
};
var mapAction = (action) => {
  return {
    index: action.index,
    budget: mapBudget(action.budget),
    tag: mapRedeemerTag(action.tag)
  };
};
var mapBudget = (budget) => {
  return {
    mem: budget.mem,
    steps: budget.steps
  };
};
var mapRedeemerTag = (tag) => {
  switch (tag) {
    case "cert":
      return "CERT";
    case "mint":
      return "MINT";
    case "reward":
      return "REWARD";
    case "spend":
      return "SPEND";
    case "vote":
      return "VOTE";
    case "propose":
      return "PROPOSE";
    default:
      throw new Error(`Unknown RedeemerTag: ${tag}`);
  }
};
var getTransactionInputs = (txHex) => {
  const inputs = [];
  const deserializedTx = deserializeTx(txHex);
  const body = deserializedTx.body();
  const cslInputs = body.inputs();
  for (let i = 0; i < cslInputs.len(); i++) {
    const input = cslInputs.get(i);
    inputs.push({
      txHash: input.transaction_id().to_hex(),
      outputIndex: input.index()
    });
  }
  const cslCollaterals = body.collateral();
  if (cslCollaterals) {
    for (let i = 0; i < cslCollaterals.len(); i++) {
      const collateral = cslCollaterals.get(i);
      inputs.push({
        txHash: collateral.transaction_id().to_hex(),
        outputIndex: collateral.index()
      });
    }
  }
  const cslRefInputs = body.reference_inputs();
  if (cslRefInputs) {
    for (let i = 0; i < cslRefInputs.len(); i++) {
      const refInput = cslRefInputs.get(i);
      inputs.push({
        txHash: refInput.transaction_id().to_hex(),
        outputIndex: refInput.index()
      });
    }
  }
  return inputs;
};
var getTransactionOutputs = (txHex) => {
  const outputs = js_get_tx_outs_utxo(txHex).get_data();
  const utxos = JSON.parse(outputs);
  return utxos;
};

// src/utils/aiken.ts
var applyParamsToScript = (rawScript, params, type = "Mesh") => {
  const cslParams = csl.JsVecString.new();
  let paramType = "cbor";
  switch (type) {
    case "JSON":
      paramType = "json";
      params.forEach((param) => {
        if (typeof param === "object") {
          cslParams.add(JSON.stringify(param));
        } else if (typeof param === "string") {
          cslParams.add(param);
        }
      });
      break;
    case "Mesh":
      params.forEach((param) => {
        const paramCbor = toPlutusData(param);
        cslParams.add(paramCbor.to_hex());
      });
      break;
    default:
      params.forEach((param) => {
        cslParams.add(param);
      });
      break;
  }
  return csl.js_apply_params_to_script(rawScript, cslParams, paramType);
};
var applyCborEncoding = (rawScript) => {
  return csl.js_apply_params_to_script(
    rawScript,
    csl.JsVecString.new(),
    "cbor"
  );
};

// src/utils/drep.ts
var getDRepIds = (dRepId) => {
  const cslDrep = csl.DRep.from_bech32(dRepId);
  let result = {
    cip105: cslDrep.to_bech32(false),
    cip129: cslDrep.to_bech32(true)
  };
  return result;
};

// src/utils/transaction-parser.ts
import { js_get_required_inputs_to_resolve } from "@sidan-lab/whisky-js-nodejs";
var getRequiredInputs = (transactionHex) => {
  const result = js_get_required_inputs_to_resolve(transactionHex);
  if (result.get_status() !== "success") {
    throw new Error(`Failed to get required inputs: ${result.get_error()}`);
  }
  const utxosStr = JSON.parse(result.get_data());
  return utxosStr.map((utxoStr) => {
    const parts = utxoStr.split("#");
    if (parts.length !== 2) {
      throw new Error(`Invalid UTxO format: ${utxoStr}`);
    }
    const [txHash, outputIndex] = parts;
    if (!txHash || !outputIndex) {
      throw new Error(
        `Invalid UTxO format: ${utxoStr}. Expected format is txHash#outputIndex`
      );
    }
    return {
      txHash,
      outputIndex: parseInt(outputIndex)
    };
  });
};

// src/core/serializer.ts
import JSONbig4 from "json-bigint";
import {
  DEFAULT_PROTOCOL_PARAMETERS,
  emptyTxBuilderBody as emptyTxBuilderBody3,
  TxTester
} from "@meshsdk/common";

// src/parser/index.ts
import { js_parse_tx_body, JsVecString } from "@sidan-lab/whisky-js-nodejs";
import { emptyTxBuilderBody } from "@meshsdk/common";
var CSLParser = class {
  resolvedUtxos;
  txBuilderBody = emptyTxBuilderBody();
  txHex = "";
  txHash = "";
  constructor(txHex, resolvedUtxos = []) {
    this.txHex = txHex;
    this.txHash = calculateTxHash(txHex);
    this.resolvedUtxos = resolvedUtxos;
    const jsUtxos = JsVecString.new();
    for (const utxo of resolvedUtxos) {
      jsUtxos.add(JSON.stringify(utxo));
    }
    const wasmResult = js_parse_tx_body(txHex, jsUtxos);
    if (wasmResult.get_status() !== "success") {
      throw new Error(`CSLParser parse error: ${wasmResult.get_error()}`);
    }
    const txBodyJson = wasmResult.get_data();
    console.log("txBodyJson", txBodyJson);
    const txBodyObj = txBuilderBodyFromObj(txBodyJson);
    console.log("txBodyObj", txBodyObj);
    this.txBuilderBody = txBuilderBodyFromObj(txBodyJson);
  }
};

// src/core/adaptor/toObj/index.ts
import {
  validityRangeToObj
} from "@meshsdk/common";

// src/core/adaptor/toObj/data.ts
var builderDataToCbor = ({ type, content }) => {
  if (type === "Mesh") {
    return toPlutusData(content).to_hex();
  }
  if (type === "CBOR") {
    return csl.PlutusData.from_hex(content).to_hex();
  }
  return csl.PlutusData.from_json(
    content,
    csl.PlutusDatumSchema.DetailedSchema
  ).to_hex();
};
var redeemerToObj = (redeemer) => {
  return {
    data: builderDataToCbor(redeemer.data),
    exUnits: redeemer.exUnits
  };
};

// src/core/adaptor/toObj/script.ts
var scriptSourceToObj = (scriptSource) => {
  if (scriptSource.type === "Provided") {
    return {
      providedScriptSource: {
        scriptCbor: scriptSource.script.code,
        languageVersion: scriptSource.script.version.toLocaleLowerCase()
      }
    };
  }
  return {
    inlineScriptSource: {
      refTxIn: {
        txHash: scriptSource.txHash,
        txIndex: scriptSource.txIndex
      },
      scriptHash: scriptSource.scriptHash ?? "",
      languageVersion: scriptSource.version.toLocaleLowerCase(),
      scriptSize: BigInt(scriptSource.scriptSize ?? "0")
    }
  };
};
var simpleScriptSourceToObj = (scriptSource) => {
  if (scriptSource.type === "Provided") {
    return {
      providedSimpleScriptSource: {
        scriptCbor: scriptSource.scriptCode
      }
    };
  }
  return {
    inlineSimpleScriptSource: {
      refTxIn: {
        txHash: scriptSource.txHash,
        txIndex: scriptSource.txIndex
      },
      simpleScriptHash: scriptSource.simpleScriptHash ?? ""
    }
  };
};

// src/core/adaptor/toObj/certificate.ts
var certificateToObj = (certificate) => {
  const baseCert = certificate.certType;
  switch (certificate.type) {
    case "BasicCertificate":
      return {
        basicCertificate: baseCertToObj(baseCert)
      };
    case "ScriptCertificate":
      return {
        scriptCertificate: {
          cert: baseCertToObj(baseCert),
          redeemer: certificate.redeemer ? redeemerToObj(certificate.redeemer) : null,
          scriptSource: certificate.scriptSource ? scriptSourceToObj(certificate.scriptSource) : null
        }
      };
    case "SimpleScriptCertificate":
      return {
        simpleScriptCertificate: {
          cert: baseCertToObj(baseCert),
          simpleScriptSource: certificate.simpleScriptSource ? simpleScriptSourceToObj(certificate.simpleScriptSource) : null
        }
      };
  }
};
var baseCertToObj = (baseCert) => {
  switch (baseCert.type) {
    case "RegisterPool":
      return {
        registerPool: {
          poolParams: poolParamsToObj(baseCert.poolParams)
        }
      };
    case "RegisterStake":
      return {
        registerStake: {
          stakeKeyAddress: baseCert.stakeKeyAddress,
          coin: 2e6
          // TODO: change in conway era (this should become an argument)
        }
      };
    case "DelegateStake":
      return {
        delegateStake: {
          stakeKeyAddress: baseCert.stakeKeyAddress,
          poolId: baseCert.poolId
        }
      };
    case "DeregisterStake":
      return {
        deregisterStake: {
          stakeKeyAddress: baseCert.stakeKeyAddress
        }
      };
    case "RetirePool":
      return {
        retirePool: {
          poolId: baseCert.poolId,
          epoch: baseCert.epoch
        }
      };
    case "VoteDelegation":
      return {
        voteDelegation: {
          stakeKeyAddress: baseCert.stakeKeyAddress,
          drep: baseCert.drep
        }
      };
    case "StakeAndVoteDelegation":
      return {
        stakeAndVoteDelegation: {
          stakeKeyAddress: baseCert.stakeKeyAddress,
          poolKeyHash: baseCert.poolKeyHash,
          drep: baseCert.drep
        }
      };
    case "StakeRegistrationAndDelegation":
      return {
        stakeRegistrationAndDelegation: {
          stakeKeyAddress: baseCert.stakeKeyAddress,
          poolKeyHash: baseCert.poolKeyHash,
          coin: baseCert.coin
        }
      };
    case "VoteRegistrationAndDelegation":
      return {
        voteRegistrationAndDelegation: {
          stakeKeyAddress: baseCert.stakeKeyAddress,
          drep: baseCert.drep,
          coin: baseCert.coin
        }
      };
    case "StakeVoteRegistrationAndDelegation":
      return {
        stakeVoteRegistrationAndDelegation: {
          stakeKeyAddress: baseCert.stakeKeyAddress,
          poolKeyHash: baseCert.poolKeyHash,
          drep: baseCert.drep,
          coin: baseCert.coin
        }
      };
    case "CommitteeHotAuth":
      return {
        committeeHotAuth: {
          committeeColdKeyAddress: baseCert.committeeColdKeyAddress,
          committeeHotKeyAddress: baseCert.committeeHotKeyAddress
        }
      };
    case "CommitteeColdResign":
      return {
        committeeColdResign: {
          committeeColdKeyAddress: baseCert.committeeColdKeyAddress,
          anchor: baseCert.anchor ?? null
        }
      };
    case "DRepRegistration":
      return {
        dRepRegistration: {
          drepId: baseCert.drepId,
          coin: baseCert.coin,
          anchor: baseCert.anchor ?? null
        }
      };
    case "DRepDeregistration":
      return {
        dRepDeregistration: {
          drepId: baseCert.drepId,
          coin: baseCert.coin
        }
      };
    case "DRepUpdate":
      return {
        dRepUpdate: {
          drepId: baseCert.drepId,
          anchor: baseCert.anchor
        }
      };
  }
};
var poolParamsToObj = (poolParams) => {
  return {
    vrfKeyHash: poolParams.vrfKeyHash,
    operator: poolParams.operator,
    pledge: poolParams.pledge,
    cost: poolParams.cost,
    margin: poolParams.margin,
    relays: poolParams.relays.map((relay) => relayToObj(relay)),
    owners: poolParams.owners,
    rewardAddress: poolParams.rewardAddress,
    metadata: poolParams.metadata ? poolMetadataToObj(poolParams.metadata) : void 0
  };
};
var poolMetadataToObj = (poolMetadata) => {
  return {
    url: poolMetadata.URL,
    metadata: poolMetadata.hash
  };
};
var relayToObj = (relay) => {
  switch (relay.type) {
    case "SingleHostAddr":
      return {
        singleHostAddr: {
          ipv4: relay.IPV4,
          ipv6: relay.IPV6,
          port: relay.port
        }
      };
    case "SingleHostName":
      return {
        singleHostName: {
          hostname: relay.domainName,
          port: relay.port
        }
      };
    case "MultiHostName":
      return {
        multiHostName: {
          dnsName: relay.domainName
        }
      };
  }
};

// src/core/adaptor/toObj/metadata.ts
import JSONbig2 from "json-bigint";
var txMetadataToObj = (metadata) => {
  const result = [];
  metadata.forEach((value, key) => {
    result.push({
      tag: key.toString(),
      metadata: JSONbig2.stringify(metadatumToObj(value))
    });
  });
  return result;
};
var metadatumToObj = (metadatum) => {
  if (typeof metadatum === "number" || typeof metadatum === "string") {
    return metadatum;
  } else if (typeof metadatum === "bigint") {
    return metadatum.toString();
  } else if (metadatum instanceof Uint8Array) {
    return uint8ArrayToHex(metadatum);
  } else if (metadatum instanceof Map) {
    const result = {};
    metadatum.forEach((value, key) => {
      result[metadatumToObj(key)] = metadatumToObj(value);
    });
    return result;
  } else if (Array.isArray(metadatum)) {
    return metadatum.map(metadatumToObj);
  } else {
    throw new Error("metadatumToObj: Unsupported Metadatum type");
  }
};
var uint8ArrayToHex = (bytes) => {
  return Array.from(bytes).map((byte) => byte.toString(16).padStart(2, "0")).join("");
};

// src/core/adaptor/toObj/mint.ts
var mintItemToObj = (mintItem) => {
  switch (mintItem.type) {
    case "Plutus":
      return {
        scriptMint: plutusMintItemToObj(mintItem)
      };
    case "Native":
      return {
        simpleScriptMint: nativeMintItemToObj(
          mintItem
        )
      };
  }
};
var plutusMintItemToObj = (mintItem) => {
  let scriptSource = scriptSourceToObj(
    mintItem.scriptSource
  );
  return {
    mint: mintParametersObj(mintItem),
    redeemer: mintItem.redeemer ? redeemerToObj(mintItem.redeemer) : null,
    scriptSource
  };
};
var nativeMintItemToObj = (mintItem) => {
  return {
    mint: mintParametersObj(mintItem),
    scriptSource: simpleScriptSourceToObj(
      mintItem.scriptSource
    )
  };
};
var mintParametersObj = (mintItem) => {
  return {
    policyId: mintItem.policyId,
    assetName: mintItem.assetName,
    amount: BigInt(mintItem.amount)
  };
};

// src/core/adaptor/toObj/network.ts
var networkToObj = (network) => {
  if (typeof network === "string") {
    return network;
  } else {
    return {
      custom: network
    };
  }
};

// src/core/adaptor/toObj/output.ts
var outputToObj = (output) => {
  let datum = null;
  if (output.datum) {
    switch (output.datum.type) {
      case "Inline":
        datum = { inline: builderDataToCbor(output.datum.data) };
        break;
      case "Hash":
        datum = { hash: builderDataToCbor(output.datum.data) };
        break;
      case "Embedded":
        datum = { embedded: builderDataToCbor(output.datum.data) };
        break;
    }
  }
  const refScript = output.referenceScript;
  return {
    address: output.address,
    amount: output.amount,
    datum,
    referenceScript: output.referenceScript ? {
      providedScriptSource: {
        scriptCbor: refScript.code,
        languageVersion: refScript.version.toLocaleLowerCase()
      }
    } : null
  };
};

// src/core/adaptor/toObj/txIn.ts
var txInToObj = (txIn) => {
  switch (txIn.type) {
    case "PubKey":
      return {
        pubKeyTxIn: {
          txIn: txInParameterToObj(txIn.txIn)
        }
      };
    case "Script":
      return {
        scriptTxIn: {
          txIn: txInParameterToObj(txIn.txIn),
          scriptTxIn: scriptTxInParameterToObj(txIn.scriptTxIn)
        }
      };
    case "SimpleScript":
      return {
        simpleScriptTxIn: {
          txIn: txInParameterToObj(txIn.txIn),
          simpleScriptTxIn: simpleScriptTxInParameterToObj(
            txIn.simpleScriptTxIn
          )
        }
      };
  }
};
var collateralTxInToObj = (txIn) => {
  return {
    txIn: txInParameterToObj(txIn.txIn)
  };
};
var txInParameterToObj = (txInParameter) => {
  return {
    txHash: txInParameter.txHash,
    txIndex: txInParameter.txIndex,
    amount: txInParameter.amount ?? null,
    address: txInParameter.address ?? null
  };
};
var scriptTxInParameterToObj = (scriptTxInParameter) => {
  let scriptSource = null;
  let datumSource = null;
  if (scriptTxInParameter.scriptSource) {
    scriptSource = scriptSourceToObj(scriptTxInParameter.scriptSource);
  }
  if (scriptTxInParameter.datumSource) {
    switch (scriptTxInParameter.datumSource.type) {
      case "Provided":
        datumSource = {
          providedDatumSource: {
            data: builderDataToCbor(scriptTxInParameter.datumSource.data)
          }
        };
        break;
      case "Inline":
        datumSource = {
          inlineDatumSource: {
            txHash: scriptTxInParameter.datumSource.txHash,
            txIndex: scriptTxInParameter.datumSource.txIndex
          }
        };
        break;
    }
  }
  return {
    scriptSource,
    datumSource,
    redeemer: scriptTxInParameter.redeemer ? redeemerToObj(scriptTxInParameter.redeemer) : null
  };
};
var simpleScriptTxInParameterToObj = (simpleScriptTxInParameter) => {
  if (simpleScriptTxInParameter.scriptSource) {
    let scriptSource = null;
    switch (simpleScriptTxInParameter.scriptSource.type) {
      case "Inline":
        scriptSource = {
          inlineSimpleScriptSource: {
            refTxIn: {
              txHash: simpleScriptTxInParameter.scriptSource.txHash,
              txIndex: simpleScriptTxInParameter.scriptSource.txIndex
            },
            simpleScriptHash: simpleScriptTxInParameter.scriptSource.simpleScriptHash ?? "",
            scriptSize: BigInt(
              simpleScriptTxInParameter.scriptSource.scriptSize ?? "0"
            )
          }
        };
        break;
      case "Provided":
        scriptSource = {
          providedSimpleScriptSource: {
            scriptCbor: simpleScriptTxInParameter.scriptSource.scriptCode
          }
        };
        break;
    }
    return scriptSource;
  }
};

// src/core/adaptor/toObj/vote.ts
var voteToObj = (vote) => {
  if (vote.type === "BasicVote") {
    return {
      basicVote: voteTypeToObj(vote.vote)
    };
  } else if (vote.type === "ScriptVote") {
    if (!vote.scriptSource) {
      throw new Error("voteToObj: missing scriptSource in plutusScriptVote.");
    }
    if (!vote.redeemer) {
      throw new Error("voteToObj: missing redeemer in plutusScriptVote.");
    }
    return {
      scriptVote: {
        vote: voteTypeToObj(vote.vote),
        redeemer: redeemerToObj(vote.redeemer),
        scriptSource: scriptSourceToObj(vote.scriptSource)
      }
    };
  } else {
    if (!vote.simpleScriptSource) {
      throw new Error("voteToObj: missing script source in simpleScriptVote");
    }
    return {
      simpleScriptVote: {
        vote: voteTypeToObj(vote.vote),
        simpleScriptSource: simpleScriptSourceToObj(vote.simpleScriptSource)
      }
    };
  }
};
var voteTypeToObj = (voteType) => {
  let voter = {};
  switch (voteType.voter.type) {
    case "ConstitutionalCommittee": {
      let ccCred = {};
      switch (voteType.voter.hotCred.type) {
        case "ScriptHash": {
          ccCred = {
            scriptHash: voteType.voter.hotCred.scriptHash
          };
          break;
        }
        case "KeyHash": {
          ccCred = {
            keyHash: voteType.voter.hotCred.keyHash
          };
          break;
        }
      }
      voter = {
        constitutionalCommitteeHotCred: ccCred
      };
      break;
    }
    case "DRep": {
      voter = {
        dRepId: voteType.voter.drepId
      };
      break;
    }
    case "StakingPool": {
      voter = {
        stakingPoolKeyHash: voteType.voter.keyHash
      };
      break;
    }
  }
  let votingProcedure = {};
  switch (voteType.votingProcedure.voteKind) {
    case "Yes": {
      votingProcedure = {
        voteKind: "yes",
        anchor: voteType.votingProcedure.anchor ?? null
      };
      break;
    }
    case "No": {
      votingProcedure = {
        voteKind: "no",
        anchor: voteType.votingProcedure.anchor ?? null
      };
      break;
    }
    case "Abstain": {
      votingProcedure = {
        voteKind: "abstain",
        anchor: voteType.votingProcedure.anchor ?? null
      };
      break;
    }
  }
  return {
    voter,
    votingProcedure,
    govActionId: voteType.govActionId
  };
};

// src/core/adaptor/toObj/withdrawal.ts
var withdrawalToObj = (withdrawal) => {
  if (withdrawal.type === "PubKeyWithdrawal") {
    return {
      pubKeyWithdrawal: {
        address: withdrawal.address,
        coin: BigInt(withdrawal.coin)
      }
    };
  } else if (withdrawal.type === "ScriptWithdrawal") {
    if (!withdrawal.scriptSource) {
      throw new Error(
        "withdrawalToObj: missing scriptSource in plutusScriptWithdrawal."
      );
    }
    if (!withdrawal.redeemer) {
      throw new Error(
        "withdrawalToObj: missing redeemer in plutusScriptWithdrawal."
      );
    }
    return {
      plutusScriptWithdrawal: {
        address: withdrawal.address,
        coin: BigInt(withdrawal.coin),
        scriptSource: scriptSourceToObj(withdrawal.scriptSource),
        redeemer: redeemerToObj(withdrawal.redeemer)
      }
    };
  } else {
    if (!withdrawal.scriptSource) {
      throw new Error(
        "withdrawalToObj: missing script source in simpleScriptWithdrawal"
      );
    }
    return {
      simpleScriptWithdrawal: {
        address: withdrawal.address,
        coin: BigInt(withdrawal.coin),
        scriptSource: simpleScriptSourceToObj(withdrawal.scriptSource)
      }
    };
  }
};

// src/core/adaptor/toObj/utxo.ts
var utxoToObj = ({
  input: { outputIndex, txHash },
  output: { address, amount, dataHash, plutusData, scriptRef, scriptHash }
}) => {
  return {
    input: {
      outputIndex,
      txHash
    },
    output: {
      address,
      amount,
      dataHash: dataHash ?? null,
      plutusData: plutusData ?? null,
      scriptRef: scriptRef ?? null,
      scriptHash: scriptHash ?? null
    }
  };
};

// src/core/adaptor/toObj/index.ts
var meshTxBuilderBodyToObj = ({
  inputs,
  outputs,
  collaterals,
  requiredSignatures,
  referenceInputs,
  mints,
  changeAddress,
  metadata,
  validityRange,
  certificates,
  signingKey,
  withdrawals,
  votes,
  fee,
  network
}) => {
  let mintsObj = [];
  mints.forEach((mint) => {
    mint.mintValue.forEach((mintValue) => {
      mintsObj.push(
        mintItemToObj({
          type: mint.type,
          policyId: mint.policyId,
          assetName: mintValue.assetName,
          amount: mintValue.amount,
          scriptSource: mint.scriptSource,
          redeemer: mint.redeemer
        })
      );
    });
  });
  return {
    inputs: inputs.map(txInToObj),
    outputs: outputs.map(outputToObj),
    collaterals: collaterals.map(collateralTxInToObj),
    requiredSignatures,
    referenceInputs,
    mints: mintsObj,
    changeAddress,
    metadata: txMetadataToObj(metadata),
    validityRange: validityRangeToObj(validityRange),
    certificates: certificates.map(certificateToObj),
    signingKey,
    withdrawals: withdrawals.map(withdrawalToObj),
    votes: votes.map(voteToObj),
    fee,
    network: networkToObj(network)
  };
};

// src/core/adaptor/fromObj/index.ts
import {
  emptyTxBuilderBody as emptyTxBuilderBody2,
  validityRangeFromObj
} from "@meshsdk/common";

// src/core/adaptor/fromObj/data.ts
var cborToBuilderData = (cborHex) => {
  return {
    type: "CBOR",
    content: cborHex
  };
};
var redeemerFromObj = (obj) => {
  return {
    data: cborToBuilderData(obj.data),
    exUnits: obj.exUnits
  };
};
var dataFromObj = (obj) => {
  if (obj === null) {
    return null;
  }
  if (typeof obj === "object") {
    if (Array.isArray(obj)) {
      return obj.map((item) => dataFromObj(item));
    } else if ("map" in obj) {
      return Object.fromEntries(
        obj.map.map((entry) => [
          dataFromObj(entry.k),
          dataFromObj(entry.v)
        ])
      );
    } else if ("list" in obj) {
      return obj.list.map((item) => dataFromObj(item));
    } else if ("int" in obj) {
      return BigInt(obj.int);
    } else if ("bytes" in obj) {
      return obj.bytes;
    } else if ("constructor" in obj) {
      return {
        constructor: obj.constructor,
        fields: obj.fields.map((field) => dataFromObj(field))
      };
    }
  }
  return obj;
};

// src/core/adaptor/fromObj/script.ts
var scriptSourceFromObj = (obj) => {
  if ("providedScriptSource" in obj) {
    return {
      type: "Provided",
      script: {
        code: obj.providedScriptSource.scriptCbor,
        version: obj.providedScriptSource.languageVersion.toUpperCase()
      }
    };
  }
  if ("inlineScriptSource" in obj) {
    return {
      type: "Inline",
      txHash: obj.inlineScriptSource.refTxIn.txHash,
      txIndex: obj.inlineScriptSource.refTxIn.txIndex,
      scriptHash: obj.inlineScriptSource.scriptHash || void 0,
      version: obj.inlineScriptSource.languageVersion.toUpperCase(),
      scriptSize: obj.inlineScriptSource.scriptSize.toString()
    };
  }
  throw new Error(
    `scriptSourceFromObj: Unknown script source format: ${JSON.stringify(obj)}`
  );
};
var simpleScriptSourceFromObj = (obj) => {
  if ("providedSimpleScriptSource" in obj) {
    return {
      type: "Provided",
      scriptCode: obj.providedSimpleScriptSource.scriptCbor
    };
  }
  if ("inlineSimpleScriptSource" in obj) {
    return {
      type: "Inline",
      txHash: obj.inlineSimpleScriptSource.refTxIn.txHash,
      txIndex: obj.inlineSimpleScriptSource.refTxIn.txIndex,
      simpleScriptHash: obj.inlineSimpleScriptSource.simpleScriptHash || void 0
    };
  }
  throw new Error(
    `simpleScriptSourceFromObj: Unknown simple script source format: ${JSON.stringify(obj)}`
  );
};

// src/core/adaptor/fromObj/certificate.ts
var certificateFromObj = (obj) => {
  if ("basicCertificate" in obj) {
    return {
      type: "BasicCertificate",
      certType: baseCertFromObj(obj.basicCertificate)
    };
  } else if ("scriptCertificate" in obj) {
    const certificate = {
      type: "ScriptCertificate",
      certType: baseCertFromObj(obj.scriptCertificate.cert)
    };
    if (obj.scriptCertificate.redeemer) {
      certificate.redeemer = redeemerFromObj(obj.scriptCertificate.redeemer);
    }
    if (obj.scriptCertificate.scriptSource) {
      certificate.scriptSource = scriptSourceFromObj(
        obj.scriptCertificate.scriptSource
      );
    }
    return certificate;
  } else if ("simpleScriptCertificate" in obj) {
    const certificate = {
      type: "SimpleScriptCertificate",
      certType: baseCertFromObj(obj.simpleScriptCertificate.cert)
    };
    if (obj.simpleScriptCertificate.simpleScriptSource) {
      certificate.simpleScriptSource = simpleScriptSourceFromObj(
        obj.simpleScriptCertificate.simpleScriptSource
      );
    }
    return certificate;
  }
  throw new Error(
    `certificateFromObj: Unknown certificate type in object: ${JSON.stringify(obj)}`
  );
};
var baseCertFromObj = (obj) => {
  if ("registerPool" in obj) {
    return {
      type: "RegisterPool",
      poolParams: poolParamsFromObj(obj.registerPool.poolParams)
    };
  } else if ("registerStake" in obj) {
    return {
      type: "RegisterStake",
      stakeKeyAddress: obj.registerStake.stakeKeyAddress
    };
  } else if ("delegateStake" in obj) {
    return {
      type: "DelegateStake",
      stakeKeyAddress: obj.delegateStake.stakeKeyAddress,
      poolId: obj.delegateStake.poolId
    };
  } else if ("deregisterStake" in obj) {
    return {
      type: "DeregisterStake",
      stakeKeyAddress: obj.deregisterStake.stakeKeyAddress
    };
  } else if ("retirePool" in obj) {
    return {
      type: "RetirePool",
      poolId: obj.retirePool.poolId,
      epoch: obj.retirePool.epoch
    };
  } else if ("voteDelegation" in obj) {
    return {
      type: "VoteDelegation",
      stakeKeyAddress: obj.voteDelegation.stakeKeyAddress,
      drep: obj.voteDelegation.drep
    };
  } else if ("stakeAndVoteDelegation" in obj) {
    return {
      type: "StakeAndVoteDelegation",
      stakeKeyAddress: obj.stakeAndVoteDelegation.stakeKeyAddress,
      poolKeyHash: obj.stakeAndVoteDelegation.poolKeyHash,
      drep: obj.stakeAndVoteDelegation.drep
    };
  } else if ("stakeRegistrationAndDelegation" in obj) {
    return {
      type: "StakeRegistrationAndDelegation",
      stakeKeyAddress: obj.stakeRegistrationAndDelegation.stakeKeyAddress,
      poolKeyHash: obj.stakeRegistrationAndDelegation.poolKeyHash,
      coin: obj.stakeRegistrationAndDelegation.coin
    };
  } else if ("voteRegistrationAndDelegation" in obj) {
    return {
      type: "VoteRegistrationAndDelegation",
      stakeKeyAddress: obj.voteRegistrationAndDelegation.stakeKeyAddress,
      drep: obj.voteRegistrationAndDelegation.drep,
      coin: obj.voteRegistrationAndDelegation.coin
    };
  } else if ("stakeVoteRegistrationAndDelegation" in obj) {
    return {
      type: "StakeVoteRegistrationAndDelegation",
      stakeKeyAddress: obj.stakeVoteRegistrationAndDelegation.stakeKeyAddress,
      poolKeyHash: obj.stakeVoteRegistrationAndDelegation.poolKeyHash,
      drep: obj.stakeVoteRegistrationAndDelegation.drep,
      coin: obj.stakeVoteRegistrationAndDelegation.coin
    };
  } else if ("committeeHotAuth" in obj) {
    return {
      type: "CommitteeHotAuth",
      committeeColdKeyAddress: obj.committeeHotAuth.committeeColdKeyAddress,
      committeeHotKeyAddress: obj.committeeHotAuth.committeeHotKeyAddress
    };
  } else if ("committeeColdResign" in obj) {
    return {
      type: "CommitteeColdResign",
      committeeColdKeyAddress: obj.committeeColdResign.committeeColdKeyAddress,
      anchor: obj.committeeColdResign.anchor || void 0
    };
  } else if ("dRepRegistration" in obj) {
    return {
      type: "DRepRegistration",
      drepId: obj.dRepRegistration.drepId,
      coin: obj.dRepRegistration.coin,
      anchor: obj.dRepRegistration.anchor || void 0
    };
  } else if ("dRepDeregistration" in obj) {
    return {
      type: "DRepDeregistration",
      drepId: obj.dRepDeregistration.drepId,
      coin: obj.dRepDeregistration.coin
    };
  } else if ("dRepUpdate" in obj) {
    return {
      type: "DRepUpdate",
      drepId: obj.dRepUpdate.drepId,
      anchor: obj.dRepUpdate.anchor
    };
  }
  throw new Error(
    `baseCertFromObj: Unknown certificate type in object: ${JSON.stringify(obj)}`
  );
};
var poolParamsFromObj = (obj) => {
  return {
    vrfKeyHash: obj.vrfKeyHash,
    operator: obj.operator,
    pledge: obj.pledge,
    cost: obj.cost,
    margin: obj.margin,
    relays: obj.relays.map((relay) => relayFromObj(relay)),
    owners: obj.owners,
    rewardAddress: obj.rewardAddress,
    metadata: obj.metadata ? poolMetadataFromObj(obj.metadata) : void 0
  };
};
var poolMetadataFromObj = (obj) => {
  return {
    URL: obj.url,
    hash: obj.metadata
  };
};
var relayFromObj = (obj) => {
  if ("singleHostAddr" in obj) {
    return {
      type: "SingleHostAddr",
      IPV4: obj.singleHostAddr.ipv4,
      IPV6: obj.singleHostAddr.ipv6,
      port: obj.singleHostAddr.port
    };
  } else if ("singleHostName" in obj) {
    return {
      type: "SingleHostName",
      domainName: obj.singleHostName.hostname,
      port: obj.singleHostName.port
    };
  } else if ("multiHostName" in obj) {
    return {
      type: "MultiHostName",
      domainName: obj.multiHostName.dnsName
    };
  }
  throw new Error(
    `relayFromObj: Unknown relay type in object: ${JSON.stringify(obj)}`
  );
};

// src/core/adaptor/fromObj/metadata.ts
import JSONbig3 from "json-bigint";
var JSONBigParser = JSONbig3({
  storeAsString: false,
  useNativeBigInt: true,
  alwaysParseAsBig: false
});
var metadataFromObj = (metadataArray) => {
  const result = /* @__PURE__ */ new Map();
  metadataArray.forEach((metadata) => {
    const key = BigInt(metadata.tag);
    const value = objToMetadatum(JSONBigParser.parse(metadata.metadata));
    result.set(key, value);
  });
  return result;
};
var objToMetadatum = (obj) => {
  if (typeof obj === "number") {
    return obj;
  } else if (typeof obj === "string") {
    if (/^\d+$/.test(obj)) {
      return BigInt(obj);
    }
    if (/^-?\d+$/.test(obj)) {
      return BigInt(obj);
    }
    return obj;
  } else if (typeof obj === "bigint") {
    return obj;
  } else if (typeof obj === "object" && obj !== null) {
    if (Array.isArray(obj)) {
      return obj.map(objToMetadatum);
    } else {
      const result = /* @__PURE__ */ new Map();
      Object.entries(obj).forEach(([key, value]) => {
        let convertedKey = objToMetadatum(key);
        result.set(convertedKey, objToMetadatum(value));
      });
      return result;
    }
  } else {
    throw new Error("objToMetadatum: Unsupported object type");
  }
};

// src/core/adaptor/fromObj/mint.ts
var mintItemFromObj = (obj) => {
  if ("scriptMint" in obj) {
    return plutusMintItemFromObj(obj.scriptMint);
  }
  if ("simpleScriptMint" in obj) {
    return nativeMintItemFromObj(obj.simpleScriptMint);
  }
  throw new Error(
    `mintItemFromObj: Unknown mint item format: ${JSON.stringify(obj)}`
  );
};
var plutusMintItemFromObj = (obj) => {
  const mintParams = mintParametersFromObj(obj.mint);
  return {
    ...mintParams,
    type: "Plutus",
    scriptSource: scriptSourceFromObj(obj.scriptSource),
    redeemer: obj.redeemer ? redeemerFromObj(obj.redeemer) : void 0
  };
};
var nativeMintItemFromObj = (obj) => {
  const mintParams = mintParametersFromObj(obj.mint);
  return {
    ...mintParams,
    type: "Native",
    scriptSource: simpleScriptSourceFromObj(obj.scriptSource)
  };
};
var mintParametersFromObj = (obj) => {
  return {
    policyId: obj.policyId,
    assetName: obj.assetName,
    amount: obj.amount.toString()
  };
};

// src/core/adaptor/fromObj/network.ts
var networkFromObj = (obj) => {
  if (typeof obj === "string") {
    return obj;
  } else if (obj && typeof obj === "object" && "custom" in obj) {
    return obj.custom;
  }
  throw new Error(
    `networkFromObj: Unknown network type in object: ${JSON.stringify(obj)}`
  );
};

// src/core/adaptor/fromObj/output.ts
var outputFromObj = (obj) => {
  const output = {
    address: obj.address,
    amount: obj.amount
  };
  if (obj.datum) {
    if ("inline" in obj.datum) {
      output.datum = {
        type: "Inline",
        data: cborToBuilderData(obj.datum.inline)
      };
    } else if ("hash" in obj.datum) {
      output.datum = {
        type: "Hash",
        data: cborToBuilderData(obj.datum.hash)
      };
    } else if ("embedded" in obj.datum) {
      output.datum = {
        type: "Embedded",
        data: cborToBuilderData(obj.datum.embedded)
      };
    }
  }
  if (obj.referenceScript) {
    const scriptSource = obj.referenceScript.providedScriptSource;
    output.referenceScript = {
      code: scriptSource.scriptCbor,
      version: scriptSource.languageVersion.toUpperCase()
    };
  }
  return output;
};

// src/core/adaptor/fromObj/txIn.ts
var txInFromObj = (obj) => {
  if ("pubKeyTxIn" in obj) {
    return {
      type: "PubKey",
      txIn: txInParameterFromObj(obj.pubKeyTxIn.txIn)
    };
  }
  if ("scriptTxIn" in obj) {
    return {
      type: "Script",
      txIn: txInParameterFromObj(obj.scriptTxIn.txIn),
      scriptTxIn: scriptTxInParameterFromObj(obj.scriptTxIn.scriptTxIn)
    };
  }
  if ("simpleScriptTxIn" in obj) {
    return {
      type: "SimpleScript",
      txIn: txInParameterFromObj(obj.simpleScriptTxIn.txIn),
      simpleScriptTxIn: simpleScriptTxInParameterFromObj(
        obj.simpleScriptTxIn.simpleScriptTxIn
      )
    };
  }
  throw new Error("Invalid transaction input object format");
};
var txInParameterFromObj = (obj) => {
  return {
    txHash: obj.txHash,
    txIndex: obj.txIndex,
    amount: obj.amount ?? void 0,
    address: obj.address ?? void 0
  };
};
var scriptTxInParameterFromObj = (obj) => {
  const result = {};
  if (obj.scriptSource) {
    result.scriptSource = scriptSourceFromObj(obj.scriptSource);
  }
  if (obj.datumSource) {
    if ("providedDatumSource" in obj.datumSource) {
      result.datumSource = {
        type: "Provided",
        data: cborToBuilderData(obj.datumSource.providedDatumSource.data)
      };
    } else if ("inlineDatumSource" in obj.datumSource) {
      result.datumSource = {
        type: "Inline",
        txHash: obj.datumSource.inlineDatumSource.txHash,
        txIndex: obj.datumSource.inlineDatumSource.txIndex
      };
    }
  }
  if (obj.redeemer) {
    result.redeemer = redeemerFromObj(obj.redeemer);
  }
  return result;
};
var simpleScriptTxInParameterFromObj = (obj) => {
  const result = {};
  if ("inlineSimpleScriptSource" in obj) {
    result.scriptSource = {
      type: "Inline",
      txHash: obj.inlineSimpleScriptSource.refTxIn.txHash,
      txIndex: obj.inlineSimpleScriptSource.refTxIn.txIndex,
      simpleScriptHash: obj.inlineSimpleScriptSource.simpleScriptHash,
      scriptSize: obj.inlineSimpleScriptSource.scriptSize.toString()
    };
  } else if ("providedSimpleScriptSource" in obj) {
    result.scriptSource = {
      type: "Provided",
      scriptCode: obj.providedSimpleScriptSource.scriptCbor
    };
  }
  return result;
};
var collateralTxInFromObj = (obj) => {
  return {
    type: "PubKey",
    txIn: txInParameterFromObj(obj.txIn)
  };
};

// src/core/adaptor/fromObj/vote.ts
var voteFromObj = (obj) => {
  if ("basicVote" in obj) {
    return {
      type: "BasicVote",
      vote: voteTypeFromObj(obj.basicVote)
    };
  } else if ("scriptVote" in obj) {
    return {
      type: "ScriptVote",
      vote: voteTypeFromObj(obj.scriptVote.vote),
      redeemer: redeemerFromObj(obj.scriptVote.redeemer),
      scriptSource: scriptSourceFromObj(obj.scriptVote.scriptSource)
    };
  } else if ("simpleScriptVote" in obj) {
    return {
      type: "SimpleScriptVote",
      vote: voteTypeFromObj(obj.simpleScriptVote.vote),
      simpleScriptSource: simpleScriptSourceFromObj(
        obj.simpleScriptVote.simpleScriptSource
      )
    };
  }
  throw new Error("Invalid vote object structure");
};
var voteTypeFromObj = (obj) => {
  const voter = voterFromObj(obj);
  const votingProcedure = {
    voteKind: voteKindFromObj(obj.votingProcedure.voteKind),
    anchor: obj.votingProcedure.anchor === null ? void 0 : obj.votingProcedure.anchor
  };
  return {
    voter,
    votingProcedure,
    govActionId: obj.govActionId
  };
};
var voterFromObj = (obj) => {
  if ("constitutionalCommitteeHotCred" in obj.voter) {
    const cred = obj.voter.constitutionalCommitteeHotCred;
    return {
      type: "ConstitutionalCommittee",
      hotCred: "keyHash" in cred ? { type: "KeyHash", keyHash: cred.keyHash } : { type: "ScriptHash", scriptHash: cred.scriptHash }
    };
  } else if ("dRepId" in obj.voter) {
    return {
      type: "DRep",
      drepId: obj.voter.dRepId
    };
  } else if ("stakingPoolKeyHash" in obj.voter) {
    return {
      type: "StakingPool",
      keyHash: obj.voter.stakingPoolKeyHash
    };
  }
  throw new Error("Invalid voter object structure");
};
var voteKindFromObj = (voteKind) => {
  switch (voteKind.toLowerCase()) {
    case "yes":
      return "Yes";
    case "no":
      return "No";
    case "abstain":
      return "Abstain";
    default:
      throw new Error("Invalid vote kind");
  }
};

// src/core/adaptor/fromObj/withdrawal.ts
var withdrawalFromObj = (obj) => {
  if ("pubKeyWithdrawal" in obj) {
    return {
      type: "PubKeyWithdrawal",
      address: obj.pubKeyWithdrawal.address,
      coin: obj.pubKeyWithdrawal.coin.toString()
    };
  } else if ("plutusScriptWithdrawal" in obj) {
    return {
      type: "ScriptWithdrawal",
      address: obj.plutusScriptWithdrawal.address,
      coin: obj.plutusScriptWithdrawal.coin.toString(),
      scriptSource: obj.plutusScriptWithdrawal.scriptSource ? scriptSourceFromObj(obj.plutusScriptWithdrawal.scriptSource) : void 0,
      redeemer: obj.plutusScriptWithdrawal.redeemer ? redeemerFromObj(obj.plutusScriptWithdrawal.redeemer) : void 0
    };
  } else if ("simpleScriptWithdrawal" in obj) {
    return {
      type: "SimpleScriptWithdrawal",
      address: obj.simpleScriptWithdrawal.address,
      coin: obj.simpleScriptWithdrawal.coin.toString(),
      scriptSource: obj.simpleScriptWithdrawal.scriptSource ? simpleScriptSourceFromObj(obj.simpleScriptWithdrawal.scriptSource) : void 0
    };
  }
  throw new Error("withdrawalFromObj: Invalid withdrawal object format");
};

// src/core/adaptor/fromObj/utxo.ts
var utxoFromObj = (obj) => {
  return {
    input: {
      outputIndex: obj.input.outputIndex,
      txHash: obj.input.txHash
    },
    output: {
      address: obj.output.address,
      amount: obj.output.amount,
      dataHash: obj.output.dataHash ?? void 0,
      plutusData: obj.output.plutusData ?? void 0,
      scriptRef: obj.output.scriptRef ?? void 0,
      scriptHash: obj.output.scriptHash ?? void 0
    }
  };
};

// src/core/adaptor/fromObj/index.ts
var txBuilderBodyFromObj = (objJson) => {
  const txBuilderBody = emptyTxBuilderBody2();
  const obj = JSON.parse(objJson);
  if (obj.inputs && Array.isArray(obj.inputs)) {
    txBuilderBody.inputs = obj.inputs.map(txInFromObj);
  }
  if (obj.outputs && Array.isArray(obj.outputs)) {
    txBuilderBody.outputs = obj.outputs.map(outputFromObj);
  }
  if (obj.fee) {
    txBuilderBody.fee = obj.fee.toString();
  }
  if (obj.mints && Array.isArray(obj.mints)) {
    const mintItems = obj.mints.map(mintItemFromObj);
    const visitedPolicyId = /* @__PURE__ */ new Set();
    const mintParams = {};
    mintItems.forEach((mintItem) => {
      const mintValueItem = {
        assetName: mintItem.assetName,
        amount: mintItem.amount
      };
      if (!visitedPolicyId.has(mintItem.policyId)) {
        const mintParam2 = {
          type: mintItem.type,
          policyId: mintItem.policyId,
          mintValue: [],
          redeemer: mintItem.redeemer,
          scriptSource: mintItem.scriptSource
        };
        mintParams[mintItem.policyId] = mintParam2;
      }
      const mintParam = mintParams[mintItem.policyId];
      mintParam.mintValue.push(mintValueItem);
      visitedPolicyId.add(mintItem.policyId);
    });
    txBuilderBody.mints = Object.values(mintParams);
  }
  if (obj.withdrawals && Array.isArray(obj.withdrawals)) {
    txBuilderBody.withdrawals = obj.withdrawals.map(withdrawalFromObj);
  }
  if (obj.certificates && Array.isArray(obj.certificates)) {
    txBuilderBody.certificates = obj.certificates.map(certificateFromObj);
  }
  if (obj.votes && Array.isArray(obj.votes)) {
    txBuilderBody.votes = obj.votes.map(voteFromObj);
  }
  if (obj.validityRange) {
    txBuilderBody.validityRange = validityRangeFromObj(obj.validityRange);
  }
  if (obj.metadata) {
    txBuilderBody.metadata = metadataFromObj(obj.metadata);
  }
  if (obj.requiredSignatures && Array.isArray(obj.requiredSignatures)) {
    txBuilderBody.requiredSignatures = [...obj.requiredSignatures];
  }
  if (obj.referenceInputs && Array.isArray(obj.referenceInputs)) {
    txBuilderBody.referenceInputs = [...obj.referenceInputs];
  }
  if (obj.collaterals && Array.isArray(obj.collaterals)) {
    txBuilderBody.collaterals = obj.collaterals.map(collateralTxInFromObj);
  }
  if (obj.changeAddress) {
    txBuilderBody.changeAddress = obj.changeAddress;
  }
  if (obj.signingKey && Array.isArray(obj.signingKey)) {
    txBuilderBody.signingKey = [...obj.signingKey];
  }
  if (obj.network) {
    txBuilderBody.network = networkFromObj(obj.network);
  }
  return txBuilderBody;
};

// src/core/serializer.ts
var VKEY_PUBKEY_SIZE_BYTES = 32;
var VKEY_SIGNATURE_SIZE_BYTES = 64;
var CHAIN_CODE_SIZE_BYTES = 32;
var CSLSerializer = class {
  /**
   * Set to true to enable verbose logging for the txBodyJson prior going into build
   */
  protocolParams;
  meshTxBuilderBody = emptyTxBuilderBody3();
  parserTxBody = emptyTxBuilderBody3();
  constructor(protocolParams) {
    this.protocolParams = protocolParams || DEFAULT_PROTOCOL_PARAMETERS;
  }
  serializeTxBody(txBody, protocolParams) {
    const txBodyJson = JSONbig4.stringify(meshTxBuilderBodyToObj(txBody));
    const params = JSONbig4.stringify(protocolParams || this.protocolParams);
    const txBuildResult = csl.js_serialize_tx_body(txBodyJson, params);
    if (txBuildResult.get_status() !== "success") {
      throw new Error(`txBuildResult error: ${txBuildResult.get_error()}`);
    }
    return txBuildResult.get_data();
  }
  addSigningKeys(txHex, signingKeys) {
    if (signingKeys.length > 0) {
      return signTransaction(txHex, signingKeys);
    }
    return txHex;
  }
  serializeData(data) {
    return builderDataToCbor(data);
  }
  serializeAddress(address, networkId) {
    return serialzeAddress(address, networkId);
  }
  serializePoolId(hash) {
    return serializePoolId(hash);
  }
  serializeRewardAddress(stakeKeyHash, isScriptHash, network_id) {
    return isScriptHash ? scriptHashToRewardAddress(stakeKeyHash, network_id) : keyHashToRewardAddress(stakeKeyHash, network_id);
  }
  deserializer = {
    key: {
      deserializeAddress: function(bech32) {
        return deserializeBech32Address(bech32);
      }
    },
    script: {
      deserializeNativeScript: function(script) {
        const nativeScript = toNativeScript(script);
        const scriptCbor = nativeScript.to_hex();
        const scriptHash = nativeScript.hash().to_hex();
        return {
          scriptHash,
          scriptCbor
        };
      },
      deserializePlutusScript: function(script) {
        const scriptHash = deserializePlutusScript(script.code, script.version).hash().to_hex();
        return { scriptHash, scriptCbor: script.code };
      }
    },
    cert: {
      deserializePoolId: function(poolId) {
        return resolveEd25519KeyHash(poolId);
      }
    }
  };
  resolver = {
    keys: {
      resolveStakeKeyHash: function(bech32) {
        return rewardAddressToKeyHash(bech32) || deserializeBech32Address(bech32).stakeCredentialHash;
      },
      resolvePrivateKey: function(words) {
        return resolvePrivateKey(words);
      },
      resolveRewardAddress: function(bech32) {
        return resolveRewardAddress(bech32);
      },
      resolveEd25519KeyHash: function(bech32) {
        return resolveEd25519KeyHash(bech32);
      }
    },
    tx: {
      resolveTxHash: function(txHex) {
        return calculateTxHash(txHex);
      }
    },
    data: {
      resolveDataHash: function(rawData, type = "Mesh") {
        return resolveDataHash(rawData, type);
      }
    },
    script: {
      resolveScriptRef: function(script) {
        return resolveScriptRef(script);
      }
    }
  };
  serializeOutput(output) {
    let cslOutputBuilder = csl.TransactionOutputBuilder.new().with_address(
      csl.Address.from_bech32(output.address)
    );
    if (output.datum?.type === "Hash") {
      cslOutputBuilder.with_data_hash(
        csl.hash_plutus_data(castDataToPlutusData(output.datum.data))
      );
    } else if (output.datum?.type === "Inline") {
      cslOutputBuilder.with_plutus_data(
        castDataToPlutusData(output.datum.data)
      );
    } else if (output.datum?.type === "Embedded") {
      throw new Error("Embedded datum not supported");
    }
    if (output.referenceScript) {
      switch (output.referenceScript.version) {
        case "V1": {
          cslOutputBuilder.with_script_ref(
            csl.ScriptRef.new_plutus_script(
              csl.PlutusScript.from_hex_with_version(
                output.referenceScript.code,
                csl.Language.new_plutus_v1()
              )
            )
          );
          break;
        }
        case "V2": {
          cslOutputBuilder.with_script_ref(
            csl.ScriptRef.new_plutus_script(
              csl.PlutusScript.from_hex_with_version(
                output.referenceScript.code,
                csl.Language.new_plutus_v2()
              )
            )
          );
          break;
        }
        case "V3": {
          cslOutputBuilder.with_script_ref(
            csl.ScriptRef.new_plutus_script(
              csl.PlutusScript.from_hex_with_version(
                output.referenceScript.code,
                csl.Language.new_plutus_v3()
              )
            )
          );
          break;
        }
        default: {
          cslOutputBuilder.with_script_ref(
            csl.ScriptRef.new_native_script(
              csl.NativeScript.from_hex(output.referenceScript.code)
            )
          );
          break;
        }
      }
    }
    return cslOutputBuilder.next().with_value(toCslValue(output.amount)).build().to_hex();
  }
  serializeTxBodyWithMockSignatures(txBuilderBody, protocolParams) {
    const txHex = this.serializeTxBody(txBuilderBody, protocolParams);
    const cslTx = csl.Transaction.from_hex(txHex);
    const mockWitnessSet = cslTx.witness_set();
    const mockVkeyWitnesses = mockWitnessSet.vkeys() ?? csl.Vkeywitnesses.new();
    const mockBootstrapWitnesses = mockWitnessSet.bootstraps() ?? csl.BootstrapWitnesses.new();
    for (let i = 0; i < txBuilderBody.expectedNumberKeyWitnesses; i++) {
      const numberInHex = this.numberToIntegerHex(i);
      const mockVkey = csl.Vkey.new(
        csl.PublicKey.from_hex(this.mockPubkey(numberInHex))
      );
      const mockSignature = csl.Ed25519Signature.from_hex(
        this.mockSignature(numberInHex)
      );
      mockVkeyWitnesses.add(csl.Vkeywitness.new(mockVkey, mockSignature));
    }
    this.meshTxBuilderBody.expectedByronAddressWitnesses.forEach(
      (bootstrapWitness, i) => {
        const address = csl.ByronAddress.from_base58(bootstrapWitness);
        const numberInHex = this.numberToIntegerHex(i);
        const pubKeyHex = this.mockPubkey(numberInHex);
        const mockVkey = csl.Vkey.new(csl.PublicKey.from_hex(pubKeyHex));
        const signature = this.mockSignature(numberInHex);
        const chainCode = this.mockChainCode(numberInHex);
        mockBootstrapWitnesses.add(
          csl.BootstrapWitness.new(
            mockVkey,
            csl.Ed25519Signature.from_hex(signature),
            Buffer.from(chainCode, "hex"),
            address.attributes()
          )
        );
      }
    );
    mockWitnessSet.set_vkeys(mockVkeyWitnesses);
    mockWitnessSet.set_bootstraps(mockBootstrapWitnesses);
    return csl.Transaction.new(
      cslTx.body(),
      mockWitnessSet,
      cslTx.auxiliary_data()
    ).to_hex();
  }
  serializeValue(value) {
    return toCslValue(value).to_hex();
  }
  parser = {
    getRequiredInputs: function(txHex) {
      return getRequiredInputs(txHex);
    },
    parse: (txHex, resolvedUtxos = []) => {
      const parser = new CSLParser(txHex, resolvedUtxos);
      this.parserTxBody = parser.txBuilderBody;
    },
    toTester: () => {
      return new TxTester(this.parserTxBody);
    },
    getBuilderBody: () => {
      return this.parserTxBody;
    },
    getBuilderBodyWithoutChange: () => {
      const txBuilderBody = { ...this.parserTxBody };
      txBuilderBody.outputs = txBuilderBody.outputs.slice(0, -1);
      return txBuilderBody;
    }
  };
  mockPubkey(numberInHex) {
    return "0".repeat(VKEY_PUBKEY_SIZE_BYTES * 2 - numberInHex.length).concat(numberInHex);
  }
  mockSignature(numberInHex) {
    return "0".repeat(VKEY_SIGNATURE_SIZE_BYTES * 2 - numberInHex.length).concat(numberInHex);
  }
  mockChainCode = (numberInHex) => {
    return "0".repeat(CHAIN_CODE_SIZE_BYTES * 2 - numberInHex.length).concat(numberInHex);
  };
  numberToIntegerHex = (number) => {
    return BigInt(number).toString(16);
  };
};

// src/offline-providers/offline-evaluator.ts
import {
  SLOT_CONFIG_NETWORK
} from "@meshsdk/common";
var OfflineEvaluator = class {
  fetcher;
  network;
  slotConfig;
  /**
   * Creates a new instance of OfflineEvaluator.
   * @param fetcher - An implementation of IFetcher to resolve transaction UTXOs
   * @param network - The network to evaluate scripts for
   * @param slotConfig - Slot configuration for the network (optional, defaults to network-specific values)
   */
  constructor(fetcher, network, slotConfig) {
    this.fetcher = fetcher;
    this.network = network;
    this.slotConfig = slotConfig ?? {
      slotLength: SLOT_CONFIG_NETWORK[network].slotLength,
      zeroSlot: SLOT_CONFIG_NETWORK[network].zeroSlot,
      zeroTime: SLOT_CONFIG_NETWORK[network].zeroTime
    };
  }
  /**
   * Evaluates Plutus scripts in a transaction by resolving its input UTXOs and calculating execution costs.
   *
   * The method performs these steps:
   * 1. Extracts input references from the transaction
   * 2. Resolves the corresponding UTXOs using the fetcher
   * 3. Verifies all required UTXOs are available
   * 4. Evaluates each Plutus script to determine its memory and CPU costs
   *
   * @param tx - Transaction in CBOR hex format
   * @returns Promise resolving to array of script evaluation results, each containing:
   *   - tag: Type of script (CERT | MINT | REWARD | SPEND | VOTE | PROPOSE)
   *   - index: Script execution index
   *   - budget: Memory units and CPU steps required
   * @throws Error if any required UTXOs cannot be resolved or if script evaluation fails
   */
  async evaluateTx(tx, additionalUtxos, additionalTxs) {
    const foundUtxos = /* @__PURE__ */ new Set();
    for (const utxo of additionalUtxos) {
      foundUtxos.add(`${utxo.input.txHash}:${utxo.input.outputIndex}`);
    }
    for (const tx2 of additionalTxs) {
      const outputs = getTransactionOutputs(tx2);
      for (const output of outputs) {
        foundUtxos.add(`${output.input.txHash}:${output.input.outputIndex}`);
      }
    }
    const inputsToResolve = getTransactionInputs(tx).filter(
      (input) => !foundUtxos.has(`${input.txHash}:${input.outputIndex}`)
    );
    const txHashesSet = new Set(inputsToResolve.map((input) => input.txHash));
    for (const txHash of txHashesSet) {
      const utxos = await this.fetcher.fetchUTxOs(txHash);
      for (const utxo of utxos) {
        if (utxo) {
          if (inputsToResolve.find(
            (input) => input.txHash === txHash && input.outputIndex === utxo.input.outputIndex
          )) {
            additionalUtxos.push(utxo);
            foundUtxos.add(`${utxo.input.txHash}:${utxo.input.outputIndex}`);
          }
        }
      }
    }
    const missing = inputsToResolve.filter(
      (input) => !foundUtxos.has(`${input.txHash}:${input.outputIndex}`)
    );
    if (missing.length > 0) {
      const missingList = missing.map((m) => `${m.txHash}:${m.outputIndex}`).join(", ");
      throw new Error(
        `Can't resolve these UTXOs to execute plutus scripts: ${missingList}`
      );
    }
    return evaluateTransaction(
      tx,
      additionalUtxos,
      additionalTxs,
      this.network,
      this.slotConfig
    );
  }
};
export {
  CSLSerializer,
  LANGUAGE_VERSIONS,
  OfflineEvaluator,
  POLICY_ID_LENGTH,
  REDEEMER_TAGS,
  addrBech32ToPlutusDataHex,
  addrBech32ToPlutusDataObj,
  applyCborEncoding,
  applyParamsToScript,
  baseAddressToStakeAddress,
  baseCertFromObj,
  baseCertToObj,
  builderDataToCbor,
  calculateTxHash,
  castDataToPlutusData,
  castRawDataToJsonString,
  cborToBuilderData,
  certificateFromObj,
  certificateToObj,
  collateralTxInFromObj,
  collateralTxInToObj,
  csl,
  dataFromObj,
  deserializeAddress,
  deserializeBech32Address,
  deserializeBip32PrivateKey,
  deserializeDataHash,
  deserializeEd25519KeyHash,
  deserializeEd25519Signature,
  deserializeNativeScript,
  deserializePlutusData,
  deserializePlutusScript,
  deserializePublicKey,
  deserializeScriptHash,
  deserializeScriptRef,
  deserializeTx,
  deserializeTxBody,
  deserializeTxHash,
  deserializeTxUnspentOutput,
  deserializeTxWitnessSet,
  deserializeValue,
  evaluateTransaction,
  fromBytes,
  fromLovelace,
  fromUTF8,
  getDRepIds,
  getRequiredInputs,
  getTransactionInputs,
  getTransactionOutputs,
  getV2ScriptHash,
  keyHashToRewardAddress,
  meshTxBuilderBodyToObj,
  metadataFromObj,
  mintItemFromObj,
  mintItemToObj,
  mintParametersFromObj,
  mintParametersObj,
  nativeMintItemFromObj,
  nativeMintItemToObj,
  networkFromObj,
  networkToObj,
  outputFromObj,
  outputToObj,
  parseDatumCbor,
  parseInlineDatum,
  plutusMintItemFromObj,
  plutusMintItemToObj,
  poolIdBech32ToHex,
  poolIdHexToBech32,
  poolMetadataFromObj,
  poolMetadataToObj,
  poolParamsFromObj,
  poolParamsToObj,
  redeemerFromObj,
  redeemerToObj,
  relayFromObj,
  relayToObj,
  resolveDataHash,
  resolveEd25519KeyHash,
  resolveNativeScriptAddress,
  resolveNativeScriptHash,
  resolveNativeScriptHex,
  resolvePlutusScriptAddress,
  resolvePrivateKey,
  resolveRewardAddress,
  resolveScriptHashDRepId,
  resolveScriptRef,
  resolveStakeKeyHash,
  rewardAddressToKeyHash,
  scriptHashToBech32,
  scriptHashToRewardAddress,
  scriptSourceFromObj,
  scriptSourceToObj,
  scriptTxInParameterFromObj,
  scriptTxInParameterToObj,
  serializeAddressObj,
  serializePlutusAddressToBech32,
  serializePoolId,
  serialzeAddress,
  signTransaction,
  simpleScriptSourceFromObj,
  simpleScriptSourceToObj,
  simpleScriptTxInParameterFromObj,
  simpleScriptTxInParameterToObj,
  skeyToPubKeyHash,
  toAddress,
  toBaseAddress,
  toBytes,
  toCslValue,
  toEnterpriseAddress,
  toLovelace,
  toNativeScript,
  toPlutusData,
  toRewardAddress,
  toScriptRef,
  toUTF8,
  txBuilderBodyFromObj,
  txInFromObj,
  txInParameterFromObj,
  txInParameterToObj,
  txInToObj,
  txMetadataToObj,
  utxoFromObj,
  utxoToObj,
  v2ScriptToBech32,
  voteFromObj,
  voteToObj,
  withdrawalFromObj,
  withdrawalToObj
};
