"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidValue = exports.hasNegativeAssetValue = exports.addTokenMaps = exports.subtractTokenMaps = exports.sortByCoins = exports.assertIsBalanceSufficient = exports.assertIsCoinBalanceSufficient = exports.getCoinQuantity = exports.assetQuantitySelector = exports.toValues = exports.preProcessArgs = exports.mintToImplicitTokens = exports.stubMaxSizeAddress = void 0;
const util_1 = require("@cardano-sdk/util");
const core_1 = require("@cardano-sdk/core");
const InputSelectionError_1 = require("./InputSelectionError");
const uniq_js_1 = __importDefault(require("lodash/uniq.js"));
exports.stubMaxSizeAddress = core_1.Cardano.PaymentAddress('addr_test1qqydn46r6mhge0kfpqmt36m6q43knzsd9ga32n96m89px3nuzcjqw982pcftgx53fu5527z2cj2tkx2h8ux2vxsg475qypp3m9');
const mintToImplicitTokens = (mintMap = new Map()) => {
    const mint = [...mintMap.entries()];
    const implicitTokensInput = new Map(mint.filter(([_, quantity]) => quantity > 0));
    const implicitTokensSpend = new Map(mint.filter(([_, quantity]) => quantity < 0).map(([assetId, quantity]) => [assetId, -quantity]));
    return { implicitTokensInput, implicitTokensSpend };
};
exports.mintToImplicitTokens = mintToImplicitTokens;
const preProcessArgs = (preSelectedUtxo, availableUtxo, outputSet, changeAddress, partialImplicitValue) => {
    const outputs = [...outputSet];
    const implicitCoin = {
        deposit: partialImplicitValue?.coin?.deposit || 0n,
        input: partialImplicitValue?.coin?.input || 0n,
        reclaimDeposit: partialImplicitValue?.coin?.reclaimDeposit || 0n,
        withdrawals: partialImplicitValue?.coin?.withdrawals || 0n
    };
    const mintMap = partialImplicitValue?.mint || new Map();
    const { implicitTokensInput, implicitTokensSpend } = (0, exports.mintToImplicitTokens)(mintMap);
    const implicitTokens = {
        input: (assetId) => implicitTokensInput.get(assetId) || 0n,
        spend: (assetId) => implicitTokensSpend.get(assetId) || 0n
    };
    const uniqueOutputAssetIDs = (0, uniq_js_1.default)(outputs.flatMap(({ value: { assets } }) => [...(assets?.keys() || [])]));
    const uniqueTxAssetIDs = (0, uniq_js_1.default)([...uniqueOutputAssetIDs, ...mintMap.keys()]);
    return {
        changeAddress,
        implicitValue: { implicitCoin, implicitTokens },
        outputs,
        requiredUtxo: [...preSelectedUtxo],
        uniqueTxAssetIDs,
        utxo: [...availableUtxo]
    };
};
exports.preProcessArgs = preProcessArgs;
const isUtxoArray = (outputsOrUtxo) => outputsOrUtxo.length > 0 && Array.isArray(outputsOrUtxo[0]);
function toValues(outputsOrUtxo) {
    if (isUtxoArray(outputsOrUtxo)) {
        return outputsOrUtxo.map(([_, { value }]) => value);
    }
    return outputsOrUtxo.map(({ value }) => value);
}
exports.toValues = toValues;
const assetQuantitySelector = (id) => (quantities) => util_1.BigIntMath.sum(quantities.map(({ assets }) => assets?.get(id) || 0n));
exports.assetQuantitySelector = assetQuantitySelector;
const getCoinQuantity = (quantities) => util_1.BigIntMath.sum(quantities.map(({ coins }) => coins));
exports.getCoinQuantity = getCoinQuantity;
const assertIsCoinBalanceSufficient = (utxoValues, outputValues, implicitCoin) => {
    const utxoCoinTotal = (0, exports.getCoinQuantity)(utxoValues);
    const outputsCoinTotal = (0, exports.getCoinQuantity)(outputValues);
    if (outputsCoinTotal + implicitCoin.deposit > utxoCoinTotal + implicitCoin.input) {
        throw new InputSelectionError_1.InputSelectionError(InputSelectionError_1.InputSelectionFailure.UtxoBalanceInsufficient);
    }
};
exports.assertIsCoinBalanceSufficient = assertIsCoinBalanceSufficient;
const assertIsBalanceSufficient = (uniqueTxAssetIDs, preSelectedUtxo, utxo, outputs, { implicitCoin, implicitTokens }) => {
    if (preSelectedUtxo.length + utxo.length === 0) {
        throw new InputSelectionError_1.InputSelectionError(InputSelectionError_1.InputSelectionFailure.UtxoBalanceInsufficient);
    }
    const utxoValues = [...toValues(utxo), ...toValues(preSelectedUtxo)];
    const outputsValues = toValues(outputs);
    for (const assetId of uniqueTxAssetIDs) {
        const getAssetQuantity = (0, exports.assetQuantitySelector)(assetId);
        const utxoTotal = getAssetQuantity(utxoValues);
        const outputsTotal = getAssetQuantity(outputsValues);
        if (outputsTotal + implicitTokens.spend(assetId) > utxoTotal + implicitTokens.input(assetId)) {
            throw new InputSelectionError_1.InputSelectionError(InputSelectionError_1.InputSelectionFailure.UtxoBalanceInsufficient);
        }
    }
    (0, exports.assertIsCoinBalanceSufficient)(utxoValues, outputsValues, implicitCoin);
};
exports.assertIsBalanceSufficient = assertIsBalanceSufficient;
const sortByCoins = (lhs, rhs) => {
    if (lhs.value.coins > rhs.value.coins) {
        return -1;
    }
    else if (lhs.value.coins < rhs.value.coins) {
        return 1;
    }
    return 0;
};
exports.sortByCoins = sortByCoins;
const subtractTokenMaps = (lhs, rhs) => {
    if (!rhs) {
        if (!lhs)
            return undefined;
        const nonEmptyValues = new Map();
        for (const [key, value] of lhs.entries()) {
            if (value !== 0n)
                nonEmptyValues.set(key, value);
        }
        return nonEmptyValues;
    }
    if (!lhs) {
        const negativeValues = new Map();
        for (const [key, value] of rhs.entries()) {
            if (value !== 0n)
                negativeValues.set(key, -value);
        }
        return negativeValues;
    }
    const result = new Map();
    const intersection = new Array();
    for (const [key, value] of lhs.entries()) {
        if (rhs.has(key)) {
            intersection.push(key);
            continue;
        }
        if (value !== 0n)
            result.set(key, value);
    }
    for (const [key, value] of rhs.entries()) {
        if (lhs.has(key)) {
            intersection.push(key);
            continue;
        }
        if (value !== 0n)
            result.set(key, -value);
    }
    const uniqIntersection = (0, uniq_js_1.default)(intersection);
    for (const id of uniqIntersection) {
        const lshVal = lhs.get(id);
        const rshVal = rhs.get(id);
        const remainingCoins = lshVal - rshVal;
        if (remainingCoins !== 0n)
            result.set(id, remainingCoins);
    }
    return result;
};
exports.subtractTokenMaps = subtractTokenMaps;
const addTokenMaps = (lhs, rhs) => {
    if (!lhs)
        return rhs;
    if (!rhs)
        return lhs;
    const result = new Map();
    const intersection = new Array();
    for (const [key, value] of lhs.entries()) {
        if (rhs.has(key)) {
            intersection.push(key);
            continue;
        }
        if (value !== 0n)
            result.set(key, value);
    }
    for (const [key, value] of rhs.entries()) {
        if (lhs.has(key)) {
            intersection.push(key);
            continue;
        }
        if (value !== 0n)
            result.set(key, value);
    }
    const uniqIntersection = (0, uniq_js_1.default)(intersection);
    for (const id of uniqIntersection) {
        const lshVal = lhs.get(id);
        const rshVal = rhs.get(id);
        if (lshVal + rshVal !== 0n)
            result.set(id, lshVal + rshVal);
    }
    return result;
};
exports.addTokenMaps = addTokenMaps;
const hasNegativeAssetValue = (assets) => {
    if (!assets)
        return false;
    const values = [...assets.values()];
    return values.some((quantity) => quantity < 0n);
};
exports.hasNegativeAssetValue = hasNegativeAssetValue;
const isValidValue = (value, computeMinimumCoinQuantity, tokenBundleSizeExceedsLimit, feeToDiscount) => {
    let isValid = value.coins - feeToDiscount >= computeMinimumCoinQuantity({ address: exports.stubMaxSizeAddress, value });
    if (value.assets)
        isValid = isValid && !tokenBundleSizeExceedsLimit(value.assets);
    return isValid;
};
exports.isValidValue = isValidValue;
//# sourceMappingURL=util.js.map