"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.roundRobinRandomImprove = exports.MAX_U64 = void 0;
const InputSelectionError_1 = require("../InputSelectionError");
const util_1 = require("../util");
const change_1 = require("./change");
const roundRobin_1 = require("./roundRobin");
const GreedySelection_1 = require("../GreedySelection");
exports.MAX_U64 = 18446744073709551615n;
const roundRobinRandomImprove = ({ changeAddressResolver, random = Math.random }) => ({
    select: async ({ preSelectedUtxo: preSelectedUtxoSet, utxo: utxoSet, outputs: outputSet, constraints: { computeMinimumCost, computeSelectionLimit, computeMinimumCoinQuantity, tokenBundleSizeExceedsLimit }, implicitValue: partialImplicitValue = {} }) => {
        const changeAddress = util_1.stubMaxSizeAddress;
        const { requiredUtxo, utxo, outputs, uniqueTxAssetIDs, implicitValue } = (0, util_1.preProcessArgs)(preSelectedUtxoSet, utxoSet, outputSet, changeAddress, partialImplicitValue);
        (0, util_1.assertIsBalanceSufficient)(uniqueTxAssetIDs, requiredUtxo, utxo, outputs, implicitValue);
        const roundRobinSelectionResult = (0, roundRobin_1.roundRobinSelection)({
            changeAddress,
            implicitValue,
            outputs,
            random,
            requiredUtxo,
            uniqueTxAssetIDs,
            utxo
        });
        const result = await (0, change_1.computeChangeAndAdjustForFee)({
            computeMinimumCoinQuantity,
            estimateTxCosts: (utxos, changeValues) => computeMinimumCost({
                change: changeValues.map((value) => ({
                    address: changeAddress,
                    value
                })),
                fee: exports.MAX_U64,
                inputs: new Set(utxos),
                outputs: outputSet
            }),
            implicitValue,
            outputValues: (0, util_1.toValues)(outputs),
            random,
            tokenBundleSizeExceedsLimit,
            uniqueTxAssetIDs,
            utxoSelection: roundRobinSelectionResult
        });
        const inputs = new Set(result.inputs);
        const selection = {
            change: result.change.map((value) => ({
                address: changeAddress,
                value
            })),
            fee: result.fee,
            inputs,
            outputs: outputSet
        };
        selection.change = await changeAddressResolver.resolve(selection);
        if (result.inputs.length >
            (await computeSelectionLimit({ change: selection.change, fee: selection.fee, inputs, outputs: outputSet }))) {
            throw new InputSelectionError_1.InputSelectionError(InputSelectionError_1.InputSelectionFailure.MaximumInputCountExceeded);
        }
        selection.inputs = new Set([...selection.inputs].sort(GreedySelection_1.sortUtxoByTxIn));
        return {
            redeemers: result.redeemers,
            remainingUTxO: new Set(result.remainingUTxO),
            selection
        };
    }
});
exports.roundRobinRandomImprove = roundRobinRandomImprove;
//# sourceMappingURL=index.js.map