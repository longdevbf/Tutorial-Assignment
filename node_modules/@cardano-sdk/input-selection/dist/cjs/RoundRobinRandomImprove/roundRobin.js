"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.roundRobinSelection = void 0;
const util_1 = require("@cardano-sdk/util");
const util_2 = require("../util");
const improvesSelection = (utxoAlreadySelected, input, minimumTarget, getQuantity) => {
    const oldQuantity = getQuantity(utxoAlreadySelected);
    if (oldQuantity < minimumTarget)
        return true;
    const newQuantity = oldQuantity + getQuantity([input]);
    const idealTarget = 2n * minimumTarget;
    const newDistance = util_1.BigIntMath.abs(idealTarget - newQuantity);
    const oldDistance = util_1.BigIntMath.abs(idealTarget - oldQuantity);
    if (newDistance < oldDistance)
        return true;
    return false;
};
const listTokensWithin = (uniqueOutputAssetIDs, outputs, { implicitCoin, implicitTokens }) => [
    ...uniqueOutputAssetIDs.map((id) => {
        const getQuantity = (0, util_2.assetQuantitySelector)(id);
        const implicitInput = implicitTokens.input(id);
        const implicitSpend = implicitTokens.spend(id);
        return {
            filterUtxo: (utxo) => utxo.filter(([_, { value: { assets } }]) => assets?.get(id)),
            getTotalSelectedQuantity: (utxo) => getQuantity((0, util_2.toValues)(utxo)) + implicitInput,
            minimumTarget: getQuantity((0, util_2.toValues)(outputs)) + implicitSpend
        };
    }),
    {
        filterUtxo: (utxo) => utxo,
        getTotalSelectedQuantity: (utxo) => (0, util_2.getCoinQuantity)((0, util_2.toValues)(utxo)) + implicitCoin.input,
        minimumTarget: (0, util_2.getCoinQuantity)((0, util_2.toValues)(outputs)) + implicitCoin.deposit
    }
];
const roundRobinSelection = ({ requiredUtxo: requiredUtxoWithValue, utxo: utxosWithValue, outputs: outputsWithValue, uniqueTxAssetIDs, random, implicitValue }) => {
    const utxoSelected = requiredUtxoWithValue;
    const utxoRemaining = [...utxosWithValue];
    const tokensRemaining = listTokensWithin(uniqueTxAssetIDs, outputsWithValue, implicitValue);
    while (tokensRemaining.length > 0) {
        for (const [tokenIdx, { filterUtxo, minimumTarget, getTotalSelectedQuantity }] of tokensRemaining.entries()) {
            const utxo = filterUtxo(utxoRemaining);
            if (utxo.length > 0) {
                const inputIdx = Math.floor(random() * utxo.length);
                const input = utxo[inputIdx];
                if (improvesSelection(utxoSelected, input, minimumTarget, getTotalSelectedQuantity)) {
                    utxoSelected.push(input);
                    utxoRemaining.splice(utxoRemaining.indexOf(input), 1);
                }
                else {
                    tokensRemaining.splice(tokenIdx, 1);
                }
            }
            else {
                tokensRemaining.splice(tokenIdx, 1);
            }
        }
    }
    if (utxoSelected.length === 0) {
        utxoSelected.push(utxoRemaining[0]);
        utxoRemaining.splice(0, 1);
    }
    return { utxoRemaining, utxoSelected };
};
exports.roundRobinSelection = roundRobinSelection;
//# sourceMappingURL=roundRobin.js.map