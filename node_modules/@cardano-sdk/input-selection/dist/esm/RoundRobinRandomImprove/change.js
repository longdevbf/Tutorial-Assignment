import { coalesceValueQuantities } from '@cardano-sdk/core';
import { InputSelectionError, InputSelectionFailure } from '../InputSelectionError.js';
import { assetQuantitySelector, getCoinQuantity, stubMaxSizeAddress, toValues } from '../util.js';
import minBy from 'lodash/minBy.js';
import orderBy from 'lodash/orderBy.js';
import pick from 'lodash/pick.js';
const getLeftoverAssets = (utxoSelected, uniqueTxAssetIDs) => {
    const leftovers = new Map();
    for (const [_, { value: { assets } }] of utxoSelected) {
        if (assets) {
            const leftoverAssetKeys = [...assets.keys()].filter((id) => !uniqueTxAssetIDs.includes(id));
            for (const assetKey of leftoverAssetKeys) {
                const quantity = assets.get(assetKey);
                if (quantity === 0n)
                    continue;
                const assetLeftovers = leftovers.get(assetKey) || [];
                leftovers.set(assetKey, [...assetLeftovers, quantity]);
            }
        }
    }
    return leftovers;
};
const redistributeLeftoverAssets = (utxoSelected, requestedAssetChangeBundles, uniqueTxAssetIDs) => {
    const leftovers = getLeftoverAssets(utxoSelected, uniqueTxAssetIDs);
    const resultBundles = [...requestedAssetChangeBundles];
    for (const assetId of leftovers.keys()) {
        const quantities = orderBy(leftovers.get(assetId), (q) => q, 'desc');
        if (resultBundles.length === 0) {
            resultBundles.push({ coins: 0n });
        }
        while (quantities.length > resultBundles.length) {
            const smallestQuantity = quantities.pop();
            quantities[quantities.length - 1] += smallestQuantity;
        }
        for (const [idx, quantity] of quantities.entries()) {
            const originalBundle = resultBundles[idx];
            const originalBundleAssets = originalBundle.assets?.entries() || [];
            resultBundles.splice(idx, 1, {
                assets: new Map([...originalBundleAssets, [assetId, quantity]]),
                coins: originalBundle.coins
            });
        }
    }
    return resultBundles;
};
const createBundlePerOutput = (outputValues, coinTotalRequested, coinChangeTotal, assetTotals) => {
    let totalCoinBundled = 0n;
    const totalAssetsBundled = new Map();
    const bundles = outputValues.map((value) => {
        const coins = coinTotalRequested > 0n ? (coinChangeTotal * value.coins) / coinTotalRequested : 0n;
        totalCoinBundled += coins;
        if (!value.assets) {
            return { coins };
        }
        const assets = new Map();
        for (const [assetId, outputAmount] of value.assets.entries()) {
            const { selected, requested } = assetTotals.get(assetId);
            const assetChangeTotal = selected - requested;
            const assetChange = (assetChangeTotal * outputAmount) / selected;
            totalAssetsBundled.set(assetId, (totalAssetsBundled.get(assetId) || 0n) + assetChange);
            assets.set(assetId, assetChange);
        }
        return { assets, coins };
    });
    return { bundles, totalAssetsBundled, totalCoinBundled };
};
const smallestBundleTokenMap = (bundles) => {
    if (bundles.length === 0) {
        const bundle = { assets: new Map(), coins: 0n };
        bundles.push(bundle);
        return bundle.assets;
    }
    const bundle = minBy(bundles, ({ assets }) => assets?.size || 0);
    if (!bundle.assets)
        bundle.assets = new Map();
    return bundle.assets;
};
const computeRequestedAssetChangeBundles = (utxoSelected, outputValues, uniqueTxAssetIDs, { implicitCoin, implicitTokens }, fee) => {
    const assetTotals = new Map();
    const utxoSelectedValues = toValues(utxoSelected);
    for (const assetId of uniqueTxAssetIDs) {
        assetTotals.set(assetId, {
            requested: assetQuantitySelector(assetId)(outputValues) + implicitTokens.spend(assetId),
            selected: assetQuantitySelector(assetId)(utxoSelectedValues) + implicitTokens.input(assetId)
        });
    }
    const coinTotalSelected = getCoinQuantity(utxoSelectedValues) + implicitCoin.input;
    const coinTotalRequested = getCoinQuantity(outputValues) + fee + implicitCoin.deposit;
    const coinChangeTotal = coinTotalSelected - coinTotalRequested;
    const { totalCoinBundled, bundles, totalAssetsBundled } = createBundlePerOutput(outputValues, coinTotalRequested, coinChangeTotal, assetTotals);
    const coinLost = coinChangeTotal - totalCoinBundled;
    if (coinLost > 0) {
        if (bundles.length === 0) {
            bundles.push({ coins: coinLost });
        }
        else {
            bundles[0].coins += coinLost;
        }
    }
    for (const assetId of uniqueTxAssetIDs) {
        const assetTotal = assetTotals.get(assetId);
        const bundled = totalAssetsBundled.get(assetId) || 0n;
        const assetLost = assetTotal.selected - assetTotal.requested - bundled;
        if (assetLost > 0n) {
            const anyChangeTokenBundle = bundles.find(({ assets }) => assets?.has(assetId))?.assets || smallestBundleTokenMap(bundles);
            const assetQuantityAlreadyInBundle = anyChangeTokenBundle.get(assetId) || 0n;
            anyChangeTokenBundle.set(assetId, assetQuantityAlreadyInBundle + assetLost);
        }
    }
    return bundles;
};
const pickExtraRandomUtxo = ({ utxoRemaining, utxoSelected }, random) => {
    const remainingUtxoOfOnlyCoin = utxoRemaining.filter(([_, { value }]) => !value.assets);
    const pickFrom = remainingUtxoOfOnlyCoin.length > 0 ? remainingUtxoOfOnlyCoin : utxoRemaining;
    const pickIdx = Math.floor(random() * pickFrom.length);
    const newUtxoSelected = [...utxoSelected, pickFrom[pickIdx]];
    const originalIdx = utxoRemaining.indexOf(pickFrom[pickIdx]);
    const newUtxoRemaining = [...utxoRemaining.slice(0, originalIdx), ...utxoRemaining.slice(originalIdx + 1)];
    return { utxoRemaining: newUtxoRemaining, utxoSelected: newUtxoSelected };
};
const mergeWithSmallestBundle = (values, index) => {
    let result = [...values];
    const toBeMerged = result.splice(index, 1)[0];
    if (result.length === 0)
        return [toBeMerged];
    const last = result.splice(-1, 1)[0];
    const merged = coalesceValueQuantities([toBeMerged, last]);
    result = [...result, merged];
    result = orderBy(result, ({ coins }) => coins, 'desc');
    return result;
};
export const coalesceChangeBundlesForMinCoinRequirement = (changeBundles, computeMinimumCoinQuantity) => {
    if (changeBundles.length === 0) {
        return changeBundles;
    }
    const noZeroQuantityAssetChangeBundles = changeBundles.map(({ coins, assets }) => ({
        assets: assets ? new Map([...assets.entries()].filter(([_, quantity]) => quantity > 0n)) : undefined,
        coins
    }));
    let sortedBundles = orderBy(noZeroQuantityAssetChangeBundles, ({ coins }) => coins, 'desc');
    const satisfiesMinCoinRequirement = (value) => {
        const stubTxOut = { address: stubMaxSizeAddress, value };
        return value.coins >= computeMinimumCoinQuantity(stubTxOut);
    };
    let allBundlesSatisfyMinCoin = false;
    while (sortedBundles.length > 1 && !allBundlesSatisfyMinCoin) {
        allBundlesSatisfyMinCoin = true;
        for (let i = sortedBundles.length - 1; i >= 0; --i) {
            const satisfies = satisfiesMinCoinRequirement(sortedBundles[i]);
            allBundlesSatisfyMinCoin = allBundlesSatisfyMinCoin && satisfies;
            if (!satisfies) {
                sortedBundles = mergeWithSmallestBundle(sortedBundles, i);
                break;
            }
        }
    }
    if (!satisfiesMinCoinRequirement(sortedBundles[0])) {
        return undefined;
    }
    return sortedBundles.filter((bundle) => bundle.coins > 0n || (bundle.assets?.size || 0) > 0);
};
const splitChangeIfTokenBundlesSizeExceedsLimit = (changeBundles, computeMinimumCoinQuantity, tokenBundleSizeExceedsLimit) => {
    const result = [];
    for (const bundle of changeBundles) {
        const { assets, coins } = bundle;
        if (!assets || assets.size === 0 || !tokenBundleSizeExceedsLimit(assets)) {
            result.push({ assets, coins });
            continue;
        }
        const newValues = [];
        let newValue = { assets: new Map(), coins: 0n };
        for (const [assetId, quantity] of assets.entries()) {
            newValue.assets.set(assetId, quantity);
            if (tokenBundleSizeExceedsLimit(newValue.assets) && newValue.assets.size > 1) {
                newValue.assets.delete(assetId);
                newValues.push(newValue);
                newValue = { assets: new Map([[assetId, quantity]]), coins: 0n };
            }
        }
        newValues.push(newValue);
        let totalMinCoin = 0n;
        for (const value of newValues) {
            const minCoin = computeMinimumCoinQuantity({ address: stubMaxSizeAddress, value });
            value.coins = minCoin;
            totalMinCoin += minCoin;
        }
        if (coins < totalMinCoin) {
            throw new InputSelectionError(InputSelectionFailure.UtxoFullyDepleted);
        }
        newValues[0].coins += coins - totalMinCoin;
        result.push(...newValues);
    }
    return result;
};
const computeChangeBundles = ({ utxoSelection, outputValues, uniqueTxAssetIDs, implicitValue, computeMinimumCoinQuantity, tokenBundleSizeExceedsLimit, fee = 0n }) => {
    const requestedAssetChangeBundles = computeRequestedAssetChangeBundles(utxoSelection.utxoSelected, outputValues, uniqueTxAssetIDs, implicitValue, fee);
    const requestedAssetChangeBundlesWithLeftoverAssets = redistributeLeftoverAssets(utxoSelection.utxoSelected, requestedAssetChangeBundles, uniqueTxAssetIDs);
    const changeBundles = coalesceChangeBundlesForMinCoinRequirement(requestedAssetChangeBundlesWithLeftoverAssets, computeMinimumCoinQuantity);
    if (!changeBundles) {
        return false;
    }
    const adjustedChange = splitChangeIfTokenBundlesSizeExceedsLimit(changeBundles, computeMinimumCoinQuantity, tokenBundleSizeExceedsLimit);
    return { changeBundles: adjustedChange, ...utxoSelection };
};
const validateChangeBundles = (changeBundles, tokenBundleSizeExceedsLimit) => {
    for (const { assets } of changeBundles) {
        if (!assets)
            continue;
        if (tokenBundleSizeExceedsLimit(assets)) {
            throw new InputSelectionError(InputSelectionFailure.UtxoFullyDepleted);
        }
    }
    return changeBundles;
};
export const computeChangeAndAdjustForFee = async ({ computeMinimumCoinQuantity, tokenBundleSizeExceedsLimit, estimateTxCosts, outputValues, uniqueTxAssetIDs, implicitValue, random, utxoSelection }) => {
    const recomputeChangeAndAdjustForFeeWithExtraUtxo = (currentUtxoSelection) => {
        if (currentUtxoSelection.utxoRemaining.length > 0) {
            return computeChangeAndAdjustForFee({
                computeMinimumCoinQuantity,
                estimateTxCosts,
                implicitValue,
                outputValues,
                random,
                tokenBundleSizeExceedsLimit,
                uniqueTxAssetIDs,
                utxoSelection: pickExtraRandomUtxo(currentUtxoSelection, random)
            });
        }
        throw new InputSelectionError(InputSelectionFailure.UtxoFullyDepleted);
    };
    const selectionWithChangeAndFee = computeChangeBundles({
        computeMinimumCoinQuantity,
        implicitValue,
        outputValues,
        tokenBundleSizeExceedsLimit,
        uniqueTxAssetIDs,
        utxoSelection
    });
    if (!selectionWithChangeAndFee)
        return recomputeChangeAndAdjustForFeeWithExtraUtxo(utxoSelection);
    const estimatedCosts = await estimateTxCosts(selectionWithChangeAndFee.utxoSelected, validateChangeBundles(selectionWithChangeAndFee.changeBundles, tokenBundleSizeExceedsLimit));
    const totalOutputCoin = getCoinQuantity(outputValues) + estimatedCosts.fee + implicitValue.implicitCoin.deposit;
    const totalInputCoin = getCoinQuantity(toValues(selectionWithChangeAndFee.utxoSelected)) + implicitValue.implicitCoin.input;
    if (totalOutputCoin > totalInputCoin) {
        if (selectionWithChangeAndFee.utxoRemaining.length === 0) {
            throw new InputSelectionError(InputSelectionFailure.UtxoBalanceInsufficient);
        }
        return recomputeChangeAndAdjustForFeeWithExtraUtxo(selectionWithChangeAndFee);
    }
    const finalSelection = computeChangeBundles({
        computeMinimumCoinQuantity,
        fee: estimatedCosts.fee,
        implicitValue,
        outputValues,
        tokenBundleSizeExceedsLimit,
        uniqueTxAssetIDs,
        utxoSelection: pick(selectionWithChangeAndFee, ['utxoRemaining', 'utxoSelected'])
    });
    if (!finalSelection) {
        return recomputeChangeAndAdjustForFeeWithExtraUtxo(selectionWithChangeAndFee);
    }
    const { changeBundles, utxoSelected, utxoRemaining } = finalSelection;
    return {
        change: validateChangeBundles(changeBundles, tokenBundleSizeExceedsLimit),
        fee: estimatedCosts.fee,
        inputs: utxoSelected,
        redeemers: estimatedCosts.redeemers,
        remainingUTxO: utxoRemaining
    };
};
//# sourceMappingURL=change.js.map