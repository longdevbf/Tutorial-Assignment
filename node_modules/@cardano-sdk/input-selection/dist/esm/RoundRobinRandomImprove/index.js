import { InputSelectionError, InputSelectionFailure } from '../InputSelectionError.js';
import { assertIsBalanceSufficient, preProcessArgs, stubMaxSizeAddress, toValues } from '../util.js';
import { computeChangeAndAdjustForFee } from './change.js';
import { roundRobinSelection } from './roundRobin.js';
import { sortUtxoByTxIn } from '../GreedySelection/index.js';
export const MAX_U64 = 18446744073709551615n;
export const roundRobinRandomImprove = ({ changeAddressResolver, random = Math.random }) => ({
    select: async ({ preSelectedUtxo: preSelectedUtxoSet, utxo: utxoSet, outputs: outputSet, constraints: { computeMinimumCost, computeSelectionLimit, computeMinimumCoinQuantity, tokenBundleSizeExceedsLimit }, implicitValue: partialImplicitValue = {} }) => {
        const changeAddress = stubMaxSizeAddress;
        const { requiredUtxo, utxo, outputs, uniqueTxAssetIDs, implicitValue } = preProcessArgs(preSelectedUtxoSet, utxoSet, outputSet, changeAddress, partialImplicitValue);
        assertIsBalanceSufficient(uniqueTxAssetIDs, requiredUtxo, utxo, outputs, implicitValue);
        const roundRobinSelectionResult = roundRobinSelection({
            changeAddress,
            implicitValue,
            outputs,
            random,
            requiredUtxo,
            uniqueTxAssetIDs,
            utxo
        });
        const result = await computeChangeAndAdjustForFee({
            computeMinimumCoinQuantity,
            estimateTxCosts: (utxos, changeValues) => computeMinimumCost({
                change: changeValues.map((value) => ({
                    address: changeAddress,
                    value
                })),
                fee: MAX_U64,
                inputs: new Set(utxos),
                outputs: outputSet
            }),
            implicitValue,
            outputValues: toValues(outputs),
            random,
            tokenBundleSizeExceedsLimit,
            uniqueTxAssetIDs,
            utxoSelection: roundRobinSelectionResult
        });
        const inputs = new Set(result.inputs);
        const selection = {
            change: result.change.map((value) => ({
                address: changeAddress,
                value
            })),
            fee: result.fee,
            inputs,
            outputs: outputSet
        };
        selection.change = await changeAddressResolver.resolve(selection);
        if (result.inputs.length >
            (await computeSelectionLimit({ change: selection.change, fee: selection.fee, inputs, outputs: outputSet }))) {
            throw new InputSelectionError(InputSelectionFailure.MaximumInputCountExceeded);
        }
        selection.inputs = new Set([...selection.inputs].sort(sortUtxoByTxIn));
        return {
            redeemers: result.redeemers,
            remainingUTxO: new Set(result.remainingUTxO),
            selection
        };
    }
});
//# sourceMappingURL=index.js.map