import { BigIntMath } from '@cardano-sdk/util';
import { assetQuantitySelector, getCoinQuantity, toValues } from '../util.js';
const improvesSelection = (utxoAlreadySelected, input, minimumTarget, getQuantity) => {
    const oldQuantity = getQuantity(utxoAlreadySelected);
    if (oldQuantity < minimumTarget)
        return true;
    const newQuantity = oldQuantity + getQuantity([input]);
    const idealTarget = 2n * minimumTarget;
    const newDistance = BigIntMath.abs(idealTarget - newQuantity);
    const oldDistance = BigIntMath.abs(idealTarget - oldQuantity);
    if (newDistance < oldDistance)
        return true;
    return false;
};
const listTokensWithin = (uniqueOutputAssetIDs, outputs, { implicitCoin, implicitTokens }) => [
    ...uniqueOutputAssetIDs.map((id) => {
        const getQuantity = assetQuantitySelector(id);
        const implicitInput = implicitTokens.input(id);
        const implicitSpend = implicitTokens.spend(id);
        return {
            filterUtxo: (utxo) => utxo.filter(([_, { value: { assets } }]) => assets?.get(id)),
            getTotalSelectedQuantity: (utxo) => getQuantity(toValues(utxo)) + implicitInput,
            minimumTarget: getQuantity(toValues(outputs)) + implicitSpend
        };
    }),
    {
        filterUtxo: (utxo) => utxo,
        getTotalSelectedQuantity: (utxo) => getCoinQuantity(toValues(utxo)) + implicitCoin.input,
        minimumTarget: getCoinQuantity(toValues(outputs)) + implicitCoin.deposit
    }
];
export const roundRobinSelection = ({ requiredUtxo: requiredUtxoWithValue, utxo: utxosWithValue, outputs: outputsWithValue, uniqueTxAssetIDs, random, implicitValue }) => {
    const utxoSelected = requiredUtxoWithValue;
    const utxoRemaining = [...utxosWithValue];
    const tokensRemaining = listTokensWithin(uniqueTxAssetIDs, outputsWithValue, implicitValue);
    while (tokensRemaining.length > 0) {
        for (const [tokenIdx, { filterUtxo, minimumTarget, getTotalSelectedQuantity }] of tokensRemaining.entries()) {
            const utxo = filterUtxo(utxoRemaining);
            if (utxo.length > 0) {
                const inputIdx = Math.floor(random() * utxo.length);
                const input = utxo[inputIdx];
                if (improvesSelection(utxoSelected, input, minimumTarget, getTotalSelectedQuantity)) {
                    utxoSelected.push(input);
                    utxoRemaining.splice(utxoRemaining.indexOf(input), 1);
                }
                else {
                    tokensRemaining.splice(tokenIdx, 1);
                }
            }
            else {
                tokensRemaining.splice(tokenIdx, 1);
            }
        }
    }
    if (utxoSelected.length === 0) {
        utxoSelected.push(utxoRemaining[0]);
        utxoRemaining.splice(0, 1);
    }
    return { utxoRemaining, utxoSelected };
};
//# sourceMappingURL=roundRobin.js.map