import { BigNumber } from 'bignumber.js';
import { coalesceValueQuantities } from '@cardano-sdk/core';
import { InputSelectionError, InputSelectionFailure } from '../InputSelectionError.js';
import { addTokenMaps, isValidValue, sortByCoins } from '../util.js';
const PERCENTAGE_TOLERANCE = 0.05;
const distributeAssets = (outputs, computeMinimumCoinQuantity, tokenBundleSizeExceedsLimit, fee) => {
    const adjustedOutputs = [...outputs];
    if (adjustedOutputs.length === 0)
        return adjustedOutputs;
    const totalAssets = coalesceValueQuantities(adjustedOutputs.map((out) => out.value)).assets;
    if (!totalAssets || totalAssets.size === 0)
        return adjustedOutputs;
    for (const utxo of adjustedOutputs)
        utxo.value.assets = undefined;
    let i = 0;
    const availableOutputs = adjustedOutputs;
    const alreadyFullOutputs = [];
    while (totalAssets.size > 0) {
        const splicedAsset = new Map([...totalAssets.entries()].splice(0, 1));
        const currentUtxoIndex = i % availableOutputs.length;
        const currentValue = { ...availableOutputs[currentUtxoIndex].value };
        currentValue.assets = addTokenMaps(currentValue.assets, splicedAsset);
        if (!isValidValue(currentValue, computeMinimumCoinQuantity, tokenBundleSizeExceedsLimit, fee)) {
            alreadyFullOutputs.push(...availableOutputs.splice(currentUtxoIndex, 1));
        }
        else {
            availableOutputs[currentUtxoIndex].value = currentValue;
            totalAssets.delete([...splicedAsset.keys()][0]);
        }
        if (availableOutputs.length === 0)
            throw new InputSelectionError(InputSelectionFailure.UtxoFullyDepleted);
        ++i;
    }
    return [...adjustedOutputs, ...alreadyFullOutputs];
};
const getMinUtxoAmount = (amount) => {
    const granularityFactor = new BigNumber(0.03);
    let tens = amount.toString().length - 1;
    let minLovelaceStr = '1';
    while (tens > 0) {
        minLovelaceStr += '0';
        --tens;
    }
    return BigInt(new BigNumber(minLovelaceStr).multipliedBy(granularityFactor).toFixed(0, 0));
};
const splitChangeOutput = (output, computeMinimumCoinQuantity, fee) => {
    const amount = output.value.coins;
    const minUtxoAdaAmount = getMinUtxoAmount(amount);
    let remaining = amount;
    let runningAmount = 0n;
    const amounts = new Array();
    const divisor = new BigNumber(2);
    while (remaining >= minUtxoAdaAmount) {
        const val = BigInt(new BigNumber(remaining.toString()).dividedBy(divisor).toFixed(0, 0));
        const updatedRemaining = remaining - val;
        if (updatedRemaining <= minUtxoAdaAmount ||
            updatedRemaining <=
                computeMinimumCoinQuantity({
                    address: output.address,
                    value: { assets: output.value.assets, coins: amount - runningAmount }
                }) +
                    fee) {
            amounts.push(amount - runningAmount);
            break;
        }
        runningAmount += val;
        amounts.push(val);
        remaining -= val;
    }
    return amounts.map((coins) => ({
        address: output.address,
        value: { assets: output.value.assets, coins }
    }));
};
export const splitChange = async (getChangeAddresses, totalChangeLovelace, totalChangeAssets, computeMinimumCoinQuantity, tokenBundleSizeExceedsLimit, fee) => {
    const changeAddresses = await getChangeAddresses();
    const totalWeight = [...changeAddresses.values()].reduce((sum, current) => sum + current, 0);
    const changeAsPercent = new Map([...changeAddresses.entries()].map((value) => [value[0], value[1] / totalWeight]));
    const totalPercentage = [...changeAsPercent.values()].reduce((sum, current) => sum + current, 0);
    if (Math.abs(1 - totalPercentage) > PERCENTAGE_TOLERANCE)
        throw new InputSelectionError(InputSelectionFailure.UtxoBalanceInsufficient);
    const changeOutputs = [...changeAsPercent.entries()].map((val) => ({
        address: val[0],
        value: { coins: 0n }
    }));
    let runningTotal = 0n;
    const totalCoinAllocation = new BigNumber(totalChangeLovelace.toString());
    for (const txOut of changeOutputs) {
        const factor = new BigNumber(changeAsPercent.get(txOut.address));
        const coinAllocation = BigInt(totalCoinAllocation.multipliedBy(factor).toFixed(0, 0));
        runningTotal += coinAllocation;
        txOut.value.coins =
            runningTotal > totalChangeLovelace ? coinAllocation - (runningTotal - totalChangeLovelace) : coinAllocation;
    }
    if (runningTotal < totalChangeLovelace) {
        const missingAllocation = totalChangeLovelace - runningTotal;
        changeOutputs[changeOutputs.length - 1].value.coins += missingAllocation;
    }
    const splitOutputs = changeOutputs.flatMap((output) => splitChangeOutput(output, computeMinimumCoinQuantity, fee));
    const sortedOutputs = splitOutputs.sort(sortByCoins).filter((out) => out.value.coins > 0n);
    if (sortedOutputs && sortedOutputs.length > 0)
        sortedOutputs[0].value.assets = totalChangeAssets;
    if (!totalChangeAssets || totalChangeAssets.size === 0)
        return sortedOutputs;
    return distributeAssets(sortedOutputs, computeMinimumCoinQuantity, tokenBundleSizeExceedsLimit, fee);
};
export const sortTxIn = (lhs, rhs) => {
    const txIdComparison = lhs.txId.localeCompare(rhs.txId);
    if (txIdComparison !== 0)
        return txIdComparison;
    return lhs.index - rhs.index;
};
export const sortUtxoByTxIn = (lhs, rhs) => sortTxIn(lhs[0], rhs[0]);
//# sourceMappingURL=util.js.map