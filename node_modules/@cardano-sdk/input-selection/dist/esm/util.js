import { BigIntMath } from '@cardano-sdk/util';
import { Cardano } from '@cardano-sdk/core';
import { InputSelectionError, InputSelectionFailure } from './InputSelectionError.js';
import uniq from 'lodash/uniq.js';
export const stubMaxSizeAddress = Cardano.PaymentAddress('addr_test1qqydn46r6mhge0kfpqmt36m6q43knzsd9ga32n96m89px3nuzcjqw982pcftgx53fu5527z2cj2tkx2h8ux2vxsg475qypp3m9');
export const mintToImplicitTokens = (mintMap = new Map()) => {
    const mint = [...mintMap.entries()];
    const implicitTokensInput = new Map(mint.filter(([_, quantity]) => quantity > 0));
    const implicitTokensSpend = new Map(mint.filter(([_, quantity]) => quantity < 0).map(([assetId, quantity]) => [assetId, -quantity]));
    return { implicitTokensInput, implicitTokensSpend };
};
export const preProcessArgs = (preSelectedUtxo, availableUtxo, outputSet, changeAddress, partialImplicitValue) => {
    const outputs = [...outputSet];
    const implicitCoin = {
        deposit: partialImplicitValue?.coin?.deposit || 0n,
        input: partialImplicitValue?.coin?.input || 0n,
        reclaimDeposit: partialImplicitValue?.coin?.reclaimDeposit || 0n,
        withdrawals: partialImplicitValue?.coin?.withdrawals || 0n
    };
    const mintMap = partialImplicitValue?.mint || new Map();
    const { implicitTokensInput, implicitTokensSpend } = mintToImplicitTokens(mintMap);
    const implicitTokens = {
        input: (assetId) => implicitTokensInput.get(assetId) || 0n,
        spend: (assetId) => implicitTokensSpend.get(assetId) || 0n
    };
    const uniqueOutputAssetIDs = uniq(outputs.flatMap(({ value: { assets } }) => [...(assets?.keys() || [])]));
    const uniqueTxAssetIDs = uniq([...uniqueOutputAssetIDs, ...mintMap.keys()]);
    return {
        changeAddress,
        implicitValue: { implicitCoin, implicitTokens },
        outputs,
        requiredUtxo: [...preSelectedUtxo],
        uniqueTxAssetIDs,
        utxo: [...availableUtxo]
    };
};
const isUtxoArray = (outputsOrUtxo) => outputsOrUtxo.length > 0 && Array.isArray(outputsOrUtxo[0]);
export function toValues(outputsOrUtxo) {
    if (isUtxoArray(outputsOrUtxo)) {
        return outputsOrUtxo.map(([_, { value }]) => value);
    }
    return outputsOrUtxo.map(({ value }) => value);
}
export const assetQuantitySelector = (id) => (quantities) => BigIntMath.sum(quantities.map(({ assets }) => assets?.get(id) || 0n));
export const getCoinQuantity = (quantities) => BigIntMath.sum(quantities.map(({ coins }) => coins));
export const assertIsCoinBalanceSufficient = (utxoValues, outputValues, implicitCoin) => {
    const utxoCoinTotal = getCoinQuantity(utxoValues);
    const outputsCoinTotal = getCoinQuantity(outputValues);
    if (outputsCoinTotal + implicitCoin.deposit > utxoCoinTotal + implicitCoin.input) {
        throw new InputSelectionError(InputSelectionFailure.UtxoBalanceInsufficient);
    }
};
export const assertIsBalanceSufficient = (uniqueTxAssetIDs, preSelectedUtxo, utxo, outputs, { implicitCoin, implicitTokens }) => {
    if (preSelectedUtxo.length + utxo.length === 0) {
        throw new InputSelectionError(InputSelectionFailure.UtxoBalanceInsufficient);
    }
    const utxoValues = [...toValues(utxo), ...toValues(preSelectedUtxo)];
    const outputsValues = toValues(outputs);
    for (const assetId of uniqueTxAssetIDs) {
        const getAssetQuantity = assetQuantitySelector(assetId);
        const utxoTotal = getAssetQuantity(utxoValues);
        const outputsTotal = getAssetQuantity(outputsValues);
        if (outputsTotal + implicitTokens.spend(assetId) > utxoTotal + implicitTokens.input(assetId)) {
            throw new InputSelectionError(InputSelectionFailure.UtxoBalanceInsufficient);
        }
    }
    assertIsCoinBalanceSufficient(utxoValues, outputsValues, implicitCoin);
};
export const sortByCoins = (lhs, rhs) => {
    if (lhs.value.coins > rhs.value.coins) {
        return -1;
    }
    else if (lhs.value.coins < rhs.value.coins) {
        return 1;
    }
    return 0;
};
export const subtractTokenMaps = (lhs, rhs) => {
    if (!rhs) {
        if (!lhs)
            return undefined;
        const nonEmptyValues = new Map();
        for (const [key, value] of lhs.entries()) {
            if (value !== 0n)
                nonEmptyValues.set(key, value);
        }
        return nonEmptyValues;
    }
    if (!lhs) {
        const negativeValues = new Map();
        for (const [key, value] of rhs.entries()) {
            if (value !== 0n)
                negativeValues.set(key, -value);
        }
        return negativeValues;
    }
    const result = new Map();
    const intersection = new Array();
    for (const [key, value] of lhs.entries()) {
        if (rhs.has(key)) {
            intersection.push(key);
            continue;
        }
        if (value !== 0n)
            result.set(key, value);
    }
    for (const [key, value] of rhs.entries()) {
        if (lhs.has(key)) {
            intersection.push(key);
            continue;
        }
        if (value !== 0n)
            result.set(key, -value);
    }
    const uniqIntersection = uniq(intersection);
    for (const id of uniqIntersection) {
        const lshVal = lhs.get(id);
        const rshVal = rhs.get(id);
        const remainingCoins = lshVal - rshVal;
        if (remainingCoins !== 0n)
            result.set(id, remainingCoins);
    }
    return result;
};
export const addTokenMaps = (lhs, rhs) => {
    if (!lhs)
        return rhs;
    if (!rhs)
        return lhs;
    const result = new Map();
    const intersection = new Array();
    for (const [key, value] of lhs.entries()) {
        if (rhs.has(key)) {
            intersection.push(key);
            continue;
        }
        if (value !== 0n)
            result.set(key, value);
    }
    for (const [key, value] of rhs.entries()) {
        if (lhs.has(key)) {
            intersection.push(key);
            continue;
        }
        if (value !== 0n)
            result.set(key, value);
    }
    const uniqIntersection = uniq(intersection);
    for (const id of uniqIntersection) {
        const lshVal = lhs.get(id);
        const rshVal = rhs.get(id);
        if (lshVal + rshVal !== 0n)
            result.set(id, lshVal + rshVal);
    }
    return result;
};
export const hasNegativeAssetValue = (assets) => {
    if (!assets)
        return false;
    const values = [...assets.values()];
    return values.some((quantity) => quantity < 0n);
};
export const isValidValue = (value, computeMinimumCoinQuantity, tokenBundleSizeExceedsLimit, feeToDiscount) => {
    let isValid = value.coins - feeToDiscount >= computeMinimumCoinQuantity({ address: stubMaxSizeAddress, value });
    if (value.assets)
        isValid = isValid && !tokenBundleSizeExceedsLimit(value.assets);
    return isValid;
};
//# sourceMappingURL=util.js.map